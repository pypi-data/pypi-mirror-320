<?xml version="1.0" encoding="UTF-8"?>
<keywordspec name="RPA.Cloud.AWS" type="LIBRARY" format="REST" scope="GLOBAL" generated="2025-01-13T19:28:09+00:00" specversion="6" source="./RPA/Cloud/AWS/__init__.py" lineno="1886">
<version/>
<doc>`AWS` is a library for operating with Amazon AWS services S3, SQS,
Textract and Comprehend.

Services are initialized with keywords like ``Init S3 Client`` for S3.

**AWS authentication**

Authentication for AWS is set with `key id` and `access key` which can be given to the library
in three different ways.

- Method 1 as environment variables, ``AWS_KEY_ID`` and ``AWS_KEY``.
- Method 2 as keyword parameters to ``Init Textract Client`` for example.
- Method 3 as Robocorp vault secret. The vault name needs to be given in library init or
  with keyword ``Set Robocorp Vault``. Secret keys are expected to match environment variable
  names.

**Note.** Starting from `rpaframework-aws` **1.0.3** `region` can be given as environment
variable ``AWS_REGION`` or include as Robocorp Vault secret with the same key name.

**Redshift Data authentication:** Depending on the authorization method, use
one of the following combinations of request parameters, which can only
be passed via method 2:

    * Secrets Manager - when connecting to a cluster, specify the Amazon
      Resource Name (ARN) of the secret, the database name, and the
      cluster identifier that matches the cluster in the secret. When
      connecting to a serverless endpoint, specify the Amazon Resource
      Name (ARN) of the secret and the database name.
    * Temporary credentials - when connecting to a cluster, specify the
      cluster identifier, the database name, and the database user name.
      Also, permission to call the ``redshift:GetClusterCredentials``
      operation is required. When connecting to a serverless endpoint,
      specify the database name.

**Role Assumption:** With the use of the STS service client, you are able
to assume another role, which will return temporary credentials. The
temporary credentials will include an access key and session token, see
keyword documentation for ``Assume Role`` for details of how the
credentials are returned. You can use these temporary credentials
as part of method 2, but you must also include the session token.

Method 1. credentials using environment variable

.. code-block:: robotframework

    *** Settings ***
    Library   RPA.Cloud.AWS

    *** Tasks ***
    Init AWS services
        # NO parameters for client, expecting to get credentials
        # with AWS_KEY, AWS_KEY_ID and AWS_REGION environment variables
        Init S3 Client

Method 2. credentials with keyword parameter

.. code-block:: robotframework

    *** Settings ***
    Library   RPA.Cloud.AWS   region=us-east-1

    *** Tasks ***
    Init AWS services
        Init S3 Client  aws_key_id=${AWS_KEY_ID}  aws_key=${AWS_KEY}

Method 3. setting Robocorp Vault in the library init

.. code-block:: robotframework

    *** Settings ***
    Library   RPA.Cloud.AWS  robocorp_vault_name=aws

    *** Tasks ***
    Init AWS services
        Init S3 Client  use_robocorp_vault=${TRUE}

Method 3. setting Robocorp Vault with keyword

.. code-block:: robotframework

    *** Settings ***
    Library   RPA.Cloud.AWS

    *** Tasks ***
    Init AWS services
        Set Robocorp Vault     vault_name=aws
        Init Textract Client    use_robocorp_vault=${TRUE}

**Requirements**

The default installation depends on `boto3`_ library. Due to the size of the
dependency, this library is available separate package ``rpaframework-aws`` but can
also be installed as an optional package for ``rpaframework``.

Recommended installation is `rpaframework-aws` plus `rpaframework` package.
Remember to check latest versions from `rpaframework Github repository`_.

.. code-block:: yaml

    channels:
      - conda-forge
    dependencies:
      - python=3.7.5
      - pip=20.1
      - pip:
        - rpaframework==13.0.2
        - rpaframework-aws==1.0.3

.. _boto3:
    https://boto3.amazonaws.com/v1/documentation/api/latest/index.html
.. _rpaframework Github repository:
    https://github.com/robocorp/rpaframework

**Example**

.. code-block:: robotframework

    *** Settings ***
    Library   RPA.Cloud.AWS   region=us-east-1

    *** Variables ***
    ${BUCKET_NAME}        testbucket12213123123

    *** Tasks ***
    Upload a file into S3 bucket
        [Setup]   Init S3 Client
        Upload File      ${BUCKET_NAME}   ${/}path${/}to${/}file.pdf
        @{files}         List Files   ${BUCKET_NAME}
        FOR   ${file}  IN   @{files}
            Log  ${file}
        END</doc>
<tags>
</tags>
<inits>
<init name="__init__" lineno="2030">
<arguments repr="region: str = eu-west-1, robocorp_vault_name: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="region: str = eu-west-1">
<name>region</name>
<type name="str" typedoc="string"/>
<default>eu-west-1</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="robocorp_vault_name: str | None = None">
<name>robocorp_vault_name</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<doc>Initialize self.  See help(type(self)) for accurate signature.</doc>
<shortdoc>Initialize self.  See help(type(self)) for accurate signature.</shortdoc>
</init>
</inits>
<keywords>
<kw name="Analyze Document" lineno="618">
<arguments repr="image_file: str | None = None, json_file: str | None = None, bucket_name: str | None = None, model: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="image_file: str | None = None">
<name>image_file</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="json_file: str | None = None">
<name>json_file</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="bucket_name: str | None = None">
<name>bucket_name</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="model: bool = False">
<name>model</name>
<type name="bool" typedoc="boolean"/>
<default>False</default>
</arg>
</arguments>
<returntype name="bool" typedoc="boolean"/>
<doc>Analyzes an input document for relationships between detected items

:param image_file: filepath (or object name) of image file
:param json_file: filepath to resulting json file
:param bucket_name: if given then using `image_file` from the bucket
:param model: set `True` to return Textract Document model, default `False`
:return: analysis response in json or TextractDocument model

Example:

.. code-block:: robotframework

    ${response}    Analyze Document    ${filename}    model=True
    FOR    ${page}    IN    @{response.pages}
        Log Many    ${page.tables}
        Log Many    ${page.form}
        Log Lines    ${page.lines}
        Log Many    ${page}
        Log    ${page}
        Log    ${page.form}
    END</doc>
<shortdoc>Analyzes an input document for relationships between detected items</shortdoc>
</kw>
<kw name="Assume Role" lineno="1788">
<arguments repr="role_arn: str, role_session_name: str, policy_arns: List[Dict] | None = None, policy: str | None = None, duration: int = 900, tags: List[Dict] | None = None, transitive_tag_keys: List[str] | None = None, external_id: str | None = None, serial_number: str | None = None, token_code: str | None = None, source_identity: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="role_arn: str">
<name>role_arn</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="role_session_name: str">
<name>role_session_name</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="policy_arns: List[Dict] | None = None">
<name>policy_arns</name>
<type name="Union" union="true">
<type name="List" typedoc="list">
<type name="Dict" typedoc="dictionary"/>
</type>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="policy: str | None = None">
<name>policy</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="duration: int = 900">
<name>duration</name>
<type name="int" typedoc="integer"/>
<default>900</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="tags: List[Dict] | None = None">
<name>tags</name>
<type name="Union" union="true">
<type name="List" typedoc="list">
<type name="Dict" typedoc="dictionary"/>
</type>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="transitive_tag_keys: List[str] | None = None">
<name>transitive_tag_keys</name>
<type name="Union" union="true">
<type name="List" typedoc="list">
<type name="str" typedoc="string"/>
</type>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="external_id: str | None = None">
<name>external_id</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="serial_number: str | None = None">
<name>serial_number</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="token_code: str | None = None">
<name>token_code</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="source_identity: str | None = None">
<name>source_identity</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<returntype name="Dict" typedoc="dictionary"/>
<doc>Returns a set of temporary security credentials that you can
use to access Amazon Web Services resources that you might not
normally have access to. These temporary credentials consist of
an access key ID, a secret access key, and a security token.
Typically, you use ``Assume Role`` within your account or for
cross-account access.

The credentials are returned as a dictionary with data structure
similar to the following JSON:

.. code-block:: json

    {
        "Credentials": {
            "AccessKeyId": "string",
            "SecretAccessKey": "string",
            "SessionToken": "string",
            "Expiration": "2015-01-01"
        },
        "AssumedRoleUser": {
            "AssumedRoleId": "string",
            "Arn": "string"
        },
        "PackedPolicySize": 123,
        "SourceIdentity": "string"
    }

These credentials can be used to re-initialize services available
in this library with the assumed role instead of the original
role.

**NOTE**: For detailed information on the available arguments to this
keyword, please see the `Boto3 STS documentation`_.

.. _Boto3 STS documentation: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/sts.html

:param role_arn: The Amazon Resource Name (ARN) of the role to assume.
:param role_session_name: An identifier for the assumed role session.
:param policy_arns: The Amazon Resource Names (ARNs) of the IAM
    managed policies that you want to use as managed session policies.
    The policies must exist in the same account as the role.
:param policy: An IAM policy in JSON format that you want to use
    as an inline session policy.
:param duration: The duration, in seconds, of the role session.
    The value specified can range from 900 seconds (15 minutes
    and the default) up to the maximum session duration set for
    the role.
:param tags: A list of session tags that you want to pass. Each
    session tag consists of a key name and an associated value.
:param transitive_tag_keys: A list of keys for session tags that
    you want to set as transitive. If you set a tag key as
    transitive, the corresponding key and value passes to
    subsequent sessions in a role chain.
:param external_id: A unique identifier that might be required
    when you assume a role in another account. If the
    administrator of the account to which the role belongs
    provided you with an external ID, then provide that value in
    this parameter.
:param serial_number: The identification number of the MFA device
    that is associated with the user who is making the
    using the ``assume_role`` keyword.
:param token_code: The value provided by the MFA device, if the
    trust policy of the role being assumed requires MFA.
:param source_identity: The source identity specified by the
    principal that is using the ``assume_role`` keyword.</doc>
<shortdoc>Returns a set of temporary security credentials that you can use to access Amazon Web Services resources that you might not normally have access to. These temporary credentials consist of an access key ID, a secret access key, and a security token. Typically, you use ``Assume Role`` within your account or for cross-account access.</shortdoc>
</kw>
<kw name="Convert Textract Response To Model" lineno="1013">
<arguments repr="response">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="response">
<name>response</name>
</arg>
</arguments>
<doc>Convert AWS Textract JSON response into TextractDocument object,
which has following structure:

    - Document
    - Page
    - Tables
    - Rows
    - Cells
    - Lines
    - Words
    - Form
    - Field

:param response: JSON response from AWS Textract service
:return: `TextractDocument` object

Example:

.. code-block:: robotframework

    ${response}    Analyze Document    ${filename}
    ${model}=    Convert Textract Response To Model    ${response}
    FOR    ${page}    IN    @{model.pages}
        Log Many    ${page.tables}
        Log Many    ${page.form}
        Log Lines    ${page.lines}
        Log Many    ${page}
        Log    ${page}
        Log    ${page.form}
    END</doc>
<shortdoc>Convert AWS Textract JSON response into TextractDocument object, which has following structure:</shortdoc>
</kw>
<kw name="Create Bucket" lineno="202">
<arguments repr="bucket_name: str | None = None, **kwargs">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="bucket_name: str | None = None">
<name>bucket_name</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="VAR_NAMED" required="false" repr="**kwargs">
<name>kwargs</name>
</arg>
</arguments>
<returntype name="bool" typedoc="boolean"/>
<doc>Create S3 bucket with name

**note** This keyword accepts additional parameters in key=value format

More info on `additional parameters &lt;https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3.html#S3.Client.create_bucket/&gt;`_.

:param bucket_name: name for the bucket
:return: boolean indicating status of operation

Robot Framework example:

.. code-block:: robotframework

    Create Bucket  public-bucket   ACL=public-read-write</doc>
<shortdoc>Create S3 bucket with name</shortdoc>
</kw>
<kw name="Create Queue" lineno="1203">
<arguments repr="queue_name: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="queue_name: str | None = None">
<name>queue_name</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<doc>Create queue with name

:param queue_name: [description], defaults to None
:return: create queue response as dict</doc>
<shortdoc>Create queue with name</shortdoc>
</kw>
<kw name="Create Redshift Statement Parameters" lineno="1495">
<arguments repr="**params">
<arg kind="VAR_NAMED" required="false" repr="**params">
<name>params</name>
</arg>
</arguments>
<returntype name="List" typedoc="list">
<type name="Dict" typedoc="dictionary">
<type name="str" typedoc="string"/>
<type name="str" typedoc="string"/>
</type>
</returntype>
<doc>Returns a formatted dictionary to be used in
Redshift Data Api SQL statements.

**Example:**

Assume the ``${SQL}`` statement has the parameters ``:id`` and
``:name``:

.. code-block:: robotframework

    *** Tasks ***

    ${params}=    Create sql parameters    id=123    name=Nokia
    # params produces a data structure like so:
    #   [
    #        {"name":"id", "value":"123"},
    #        {"name":"name", "value":"Nokia"}
    #    ]

    # Which can be used for the 'parameters' argument.
    ${response}=    Execute redshift statement    ${SQL}    ${params}</doc>
<shortdoc>Returns a formatted dictionary to be used in Redshift Data Api SQL statements.</shortdoc>
</kw>
<kw name="Delete Bucket" lineno="228">
<arguments repr="bucket_name: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="bucket_name: str | None = None">
<name>bucket_name</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<returntype name="bool" typedoc="boolean"/>
<doc>Delete S3 bucket with name

:param bucket_name: name for the bucket
:return: boolean indicating status of operation</doc>
<shortdoc>Delete S3 bucket with name</shortdoc>
</kw>
<kw name="Delete Files" lineno="254">
<arguments repr="bucket_name: str | None = None, files: list | None = None, **kwargs">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="bucket_name: str | None = None">
<name>bucket_name</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="files: list | None = None">
<name>files</name>
<type name="Union" union="true">
<type name="list" typedoc="list"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="VAR_NAMED" required="false" repr="**kwargs">
<name>kwargs</name>
</arg>
</arguments>
<doc>Delete files in the bucket

**note** This keyword accepts additional parameters in key=value format

More info on `additional parameters &lt;https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3.html#S3.Client.delete_objects/&gt;`_.

:param bucket_name: name for the bucket
:param files: list of files to delete
:return: number of files deleted or `False`</doc>
<shortdoc>Delete files in the bucket</shortdoc>
</kw>
<kw name="Delete Message" lineno="1189">
<arguments repr="receipt_handle: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="receipt_handle: str | None = None">
<name>receipt_handle</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<doc>Delete message in the queue

:param receipt_handle: message handle to delete
:return: delete message response as dict</doc>
<shortdoc>Delete message in the queue</shortdoc>
</kw>
<kw name="Delete Queue" lineno="1215">
<arguments repr="queue_name: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="queue_name: str | None = None">
<name>queue_name</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<doc>Delete queue with name

:param queue_name: [description], defaults to None
:return: delete queue response as dict</doc>
<shortdoc>Delete queue with name</shortdoc>
</kw>
<kw name="Describe Redshift Table" lineno="1597">
<arguments repr="database: str, schema: str | None = None, table: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="database: str">
<name>database</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="schema: str | None = None">
<name>schema</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="table: str | None = None">
<name>table</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<returntype name="Union" union="true">
<type name="Dict" typedoc="dictionary"/>
<type name="List" typedoc="list">
<type name="Dict" typedoc="dictionary"/>
</type>
</returntype>
<doc>Describes the detailed information about a table from metadata
in the cluster. The information includes its columns.

If ``schema`` and/or ``table`` is not provided, the API searches
all schemas for the provided table, or returns all tables in the
schema or entire database.

The response object is provided as a list of table meta data objects,
utilize dot-notation or the ``RPA.JSON`` library to access members:

.. code-block:: json

    {
        "ColumnList": [
            {
                "columnDefault": "string",
                "isCaseSensitive": true,
                "isCurrency": false,
                "isSigned": false,
                "label": "string",
                "length": 123,
                "name": "string",
                "nullable": 123,
                "precision": 123,
                "scale": 123,
                "schemaName": "string",
                "tableName": "string",
                "typeName": "string"
            },
        ],
        "TableName": "string"
    }

:param database: The name of the database that contains the tables
    to be described. If ommitted, will use the connected Database.
:param schema: The schema that contains the table. If no schema
    is specified, then matching tables for all schemas are returned.
:param table: The table name. If no table is specified, then all
    tables for all matching schemas are returned. If no table and
    no schema is specified, then all tables for all schemas in the
    database are returned</doc>
<shortdoc>Describes the detailed information about a table from metadata in the cluster. The information includes its columns.</shortdoc>
</kw>
<kw name="Detect Document Text" lineno="753">
<arguments repr="image_file: str | None = None, json_file: str | None = None, bucket_name: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="image_file: str | None = None">
<name>image_file</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="json_file: str | None = None">
<name>json_file</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="bucket_name: str | None = None">
<name>bucket_name</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<returntype name="bool" typedoc="boolean"/>
<doc>Detects text in the input document.

:param image_file: filepath (or object name) of image file
:param json_file: filepath to resulting json file
:param bucket_name: if given then using `image_file` from the bucket
:return: analysis response in json</doc>
<shortdoc>Detects text in the input document.</shortdoc>
</kw>
<kw name="Detect Entities" lineno="1109">
<arguments repr="text: str | None = None, lang=en">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="text: str | None = None">
<name>text</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="lang=en">
<name>lang</name>
<default>en</default>
</arg>
</arguments>
<returntype name="dict" typedoc="dictionary"/>
<doc>Inspects text for named entities, and returns information about them

:param text: A UTF-8 text string. Each string must contain fewer
    that 5,000 bytes of UTF-8 encoded characters
:param lang: language code of the text, defaults to "en"</doc>
<shortdoc>Inspects text for named entities, and returns information about them</shortdoc>
</kw>
<kw name="Detect Sentiment" lineno="1089">
<arguments repr="text: str | None = None, lang=en">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="text: str | None = None">
<name>text</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="lang=en">
<name>lang</name>
<default>en</default>
</arg>
</arguments>
<returntype name="dict" typedoc="dictionary"/>
<doc>Inspects text and returns an inference of the prevailing sentiment

:param text: A UTF-8 text string. Each string must contain fewer
    that 5,000 bytes of UTF-8 encoded characters
:param lang: language code of the text, defaults to "en"</doc>
<shortdoc>Inspects text and returns an inference of the prevailing sentiment</shortdoc>
</kw>
<kw name="Download Files" lineno="513">
<arguments repr="bucket_name: str | None = None, files: list | None = None, target_directory: str | None = None, **kwargs">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="bucket_name: str | None = None">
<name>bucket_name</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="files: list | None = None">
<name>files</name>
<type name="Union" union="true">
<type name="list" typedoc="list"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="target_directory: str | None = None">
<name>target_directory</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="VAR_NAMED" required="false" repr="**kwargs">
<name>kwargs</name>
</arg>
</arguments>
<returntype name="list" typedoc="list"/>
<doc>Download files from bucket to local filesystem

**note** This keyword accepts additional parameters in key=value format.

More info on `additional parameters &lt;https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3.html#S3.Client.download_file/&gt;`_.

:param bucket_name: name for the bucket
:param files: list of S3 object names
:param target_directory: location for the downloaded files, default
    current directory
:return: number of files downloaded</doc>
<shortdoc>Download files from bucket to local filesystem</shortdoc>
</kw>
<kw name="Execute Redshift Statement" lineno="1289">
<arguments repr="sql: str, parameters: list | None = None, statement_name: str | None = None, with_event: bool = False, timeout: int = 40">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="sql: str">
<name>sql</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="parameters: list | None = None">
<name>parameters</name>
<type name="Union" union="true">
<type name="list" typedoc="list"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="statement_name: str | None = None">
<name>statement_name</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="with_event: bool = False">
<name>with_event</name>
<type name="bool" typedoc="boolean"/>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: int = 40">
<name>timeout</name>
<type name="int" typedoc="integer"/>
<default>40</default>
</arg>
</arguments>
<returntype name="Union" union="true">
<type name="Dict" typedoc="dictionary"/>
<type name="str" typedoc="string"/>
</returntype>
<doc>Runs an SQL statement, which can be data manipulation language
(DML) or data definition language (DDL). This statement must be a
single SQL statement.

SQL statements can be parameterized with named parameters through
the use of the ``parameters`` argument. Parameters must be dictionaries
with the following two keys:

* ``name``: The name of the parameter. In the SQL statement this
  will be referenced as ``:name``.
* ``value``: The value of the parameter. Amazon Redshift implicitly
  converts to the proper data type. For more information, see
  `Data types`_ in the `Amazon Redshift Database Developer Guide`.

For simplicity, a helper keyword, \`Create redshift statement parameters\`,
is available and can be used more naturally in Robot Framework contexts.

.. _Data types: https://docs.aws.amazon.com/redshift/latest/dg/c_Supported_data_types.html

If tabular data is returned, this keyword tries to return it as
a table (see ``RPA.Tables``), if ``RPA.Tables`` is not available
in the keyword's scope, the data will be returned as a list of dictionaries.
Other types of data (SQL errors and result statements) are returned
as strings.

**NOTE:** You may modify the max built-in wait time by providing
a timeout in seconds (default 40 seconds)

**Robot framework example:**

.. code-block:: robotframework

    *** Tasks ***

        ${SQL}=    Set variable    insert into mytable values (:id, :address)
        ${params}=    Create redshift statement parameters
        ...    id=1
        ...    address=Seattle
        ${response}=    Execute redshift statement    ${SQL}    ${params}
        Log    ${response}

**Python example:**

.. code-block:: python

    sql = "insert into mytable values (:id, :address)"
    parameters = [
        {"name": "id", "value": "1"},
        {"name": "address", "value": "Seattle"},
    ]
    response = aws.execute_redshift_statement(sql, parameters)
    print(response)

:param parameters: The parameters for the SQL statement. Must consist
    of a list of dictionaries with two keys: ``name`` and ``value``.
:param sql: The SQL statement text to run.
:param statement_name: The name of the SQL statement. You can name
    the SQL statement when you create it to identify the query.
:param with_event: A value that indicates whether to send an event
    to the Amazon EventBridge event bus after the SQL statement runs.
:param timeout: Used to calculate the maximum wait. Exact timing
    depends on system variability becuase the underlying waiter
    does not utilize a timeout directly.</doc>
<shortdoc>Runs an SQL statement, which can be data manipulation language (DML) or data definition language (DDL). This statement must be a single SQL statement.</shortdoc>
</kw>
<kw name="Execute Redshift Statement Asyncronously" lineno="1375">
<arguments repr="sql: str, parameters: list | None = None, statement_name: str | None = None, with_event: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="sql: str">
<name>sql</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="parameters: list | None = None">
<name>parameters</name>
<type name="Union" union="true">
<type name="list" typedoc="list"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="statement_name: str | None = None">
<name>statement_name</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="with_event: bool = False">
<name>with_event</name>
<type name="bool" typedoc="boolean"/>
<default>False</default>
</arg>
</arguments>
<returntype name="str" typedoc="string"/>
<doc>Submit a sql statement for Redshift to execute asyncronously.
Returns the statement ID which can be used to retrieve statement
results later.

:param parameters: The parameters for the SQL statement. Must consist
    of a list of dictionaries with two keys: ``name`` and ``value``.
:param sql: The SQL statement text to run.
:param statement_name: The name of the SQL statement. You can name
    the SQL statement when you create it to identify the query.
:param with_event: A value that indicates whether to send an event
    to the Amazon EventBridge event bus after the SQL statement runs.</doc>
<shortdoc>Submit a sql statement for Redshift to execute asyncronously. Returns the statement ID which can be used to retrieve statement results later.</shortdoc>
</kw>
<kw name="Generate Presigned Url" lineno="551">
<arguments repr="bucket_name: str, object_name: str, expires_in: int | None = None, **extra_params">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="bucket_name: str">
<name>bucket_name</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="object_name: str">
<name>object_name</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="expires_in: int | None = None">
<name>expires_in</name>
<type name="Union" union="true">
<type name="int" typedoc="integer"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="VAR_NAMED" required="false" repr="**extra_params">
<name>extra_params</name>
</arg>
</arguments>
<returntype name="tuple" typedoc="tuple"/>
<doc>Generate presigned URL for the file.

:param bucket_name: name for the bucket
:param object_name: name of the file in the bucket
:param expires_in: optional expiration time for the url (in seconds).
 The default expiration time is 3600 seconds (one hour).
:param extra_params: allows setting any extra `Params`
:return: URL for accessing the file</doc>
<shortdoc>Generate presigned URL for the file.</shortdoc>
</kw>
<kw name="Get Cells" lineno="745">
<arguments repr="">
</arguments>
<doc>Get parsed cells from the response

:return: cells</doc>
<shortdoc>Get parsed cells from the response</shortdoc>
</kw>
<kw name="Get Document Analysis" lineno="829">
<arguments repr="job_id: str | None = None, max_results: int = 1000, next_token: str | None = None, collect_all_results: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="job_id: str | None = None">
<name>job_id</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="max_results: int = 1000">
<name>max_results</name>
<type name="int" typedoc="integer"/>
<default>1000</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="next_token: str | None = None">
<name>next_token</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="collect_all_results: bool = False">
<name>collect_all_results</name>
<type name="bool" typedoc="boolean"/>
<default>False</default>
</arg>
</arguments>
<returntype name="dict" typedoc="dictionary"/>
<doc>Get the results of Textract asynchronous `Document Analysis` operation

:param job_id: job identifier, defaults to None
:param max_results: number of blocks to get at a time, defaults to 1000
:param next_token: pagination token for getting next set of results,
 defaults to None
:param collect_all_results: when set to True will wait until analysis is
 complete and returns all blocks of the analysis result, by default (False)
 the all blocks need to be specifically collected using `next_token` variable
:return: dictionary

Response dictionary has key `JobStatus` with value `SUCCEEDED` when analysis
has been completed.

Example:

.. code-block:: robotframework

    Init Textract Client  %{AWS_KEY_ID}  %{AWS_KEY_SECRET}  %{AWS_REGION}
    ${jobid}=    Start Document Analysis  s3bucket_name  invoice.pdf
    # Wait for job completion and collect all blocks
    ${response}=    Get Document Analysis  ${jobid}  collect_all_results=True
    # Model will contain all pages of the invoice.pdf
    ${model}=    Convert Textract Response To Model    ${response}</doc>
<shortdoc>Get the results of Textract asynchronous `Document Analysis` operation</shortdoc>
</kw>
<kw name="Get Document Text Detection" lineno="951">
<arguments repr="job_id: str | None = None, max_results: int = 1000, next_token: str | None = None, collect_all_results: bool = False">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="job_id: str | None = None">
<name>job_id</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="max_results: int = 1000">
<name>max_results</name>
<type name="int" typedoc="integer"/>
<default>1000</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="next_token: str | None = None">
<name>next_token</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="collect_all_results: bool = False">
<name>collect_all_results</name>
<type name="bool" typedoc="boolean"/>
<default>False</default>
</arg>
</arguments>
<returntype name="dict" typedoc="dictionary"/>
<doc>Get the results of Textract asynchronous `Document Text Detection` operation

:param job_id: job identifier, defaults to None
:param max_results: number of blocks to get at a time, defaults to 1000
:param next_token: pagination token for getting next set of results,
 defaults to None
:param collect_all_results: when set to True will wait until analysis is
 complete and returns all blocks of the analysis result, by default (False)
 the all blocks need to be specifically collected using `next_token` variable
:return: dictionary

Response dictionary has key `JobStatus` with value `SUCCEEDED` when analysis
has been completed.

Example:

.. code-block:: robotframework

    Init Textract Client  %{AWS_KEY_ID}  %{AWS_KEY_SECRET}  %{AWS_REGION}
    ${jobid}=    Start Document Text Detection  s3bucket_name  invoice.pdf
    # Wait for job completion and collect all blocks
    ${response}=   Get Document Text Detection    ${jobid}  collect_all_results=True
    # Model will contain all pages of the invoice.pdf
    ${model}=    Convert Textract Response To Model    ${response}</doc>
<shortdoc>Get the results of Textract asynchronous `Document Text Detection` operation</shortdoc>
</kw>
<kw name="Get Pages And Text" lineno="891">
<arguments repr="textract_response: dict">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="textract_response: dict">
<name>textract_response</name>
<type name="dict" typedoc="dictionary"/>
</arg>
</arguments>
<returntype name="dict" typedoc="dictionary"/>
<doc>Get pages and text out of Textract response json

:param textract_response: JSON from Textract
:return: dictionary, page numbers as keys and value is a list
 of text lines</doc>
<shortdoc>Get pages and text out of Textract response json</shortdoc>
</kw>
<kw name="Get Redshift Statement Results" lineno="1427">
<arguments repr="statement_id: str, timeout: int = 40">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="statement_id: str">
<name>statement_id</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="timeout: int = 40">
<name>timeout</name>
<type name="int" typedoc="integer"/>
<default>40</default>
</arg>
</arguments>
<returntype name="Union" union="true">
<type name="Dict" typedoc="dictionary"/>
<type name="int" typedoc="integer"/>
</returntype>
<doc>Retrieve the results of a SQL statement previously submitted
to Redshift. If that statement has not yet completed, this keyword
will wait for results. See \`Execute Redshift Statement\` for
additional information.

If the statement has tabular results, this keyword returns them
as a table from ``RPA.Tables`` if that library is available, or
as a list of dictionaries if not. If the statement does not have
tabular results, it will return the number of rows affected.

:param statement_id: The statement id to use to retreive results.
:param timeout: An integer used to calculate the maximum wait.
    Exact timing depends on system variability becuase the
    underlying waiter does not utilize a timeout directly.
    Defaults to 40.</doc>
<shortdoc>Retrieve the results of a SQL statement previously submitted to Redshift. If that statement has not yet completed, this keyword will wait for results. See \`Execute Redshift Statement\` for additional information.</shortdoc>
</kw>
<kw name="Get Tables" lineno="729">
<arguments repr="">
</arguments>
<doc>Get parsed tables from the response

Returns `RPA.Tables.Table` if possible otherwise returns an dictionary.

:return: tables</doc>
<shortdoc>Get parsed tables from the response</shortdoc>
</kw>
<kw name="Get Words" lineno="738">
<arguments repr="">
</arguments>
<doc>Get parsed words from the response

:return: words</doc>
<shortdoc>Get parsed words from the response</shortdoc>
</kw>
<kw name="Init Comprehend Client" lineno="1062">
<arguments repr="aws_key_id: str | None = None, aws_key: str | None = None, region: str | None = None, use_robocorp_vault: bool = False, session_token: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="aws_key_id: str | None = None">
<name>aws_key_id</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="aws_key: str | None = None">
<name>aws_key</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="region: str | None = None">
<name>region</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="use_robocorp_vault: bool = False">
<name>use_robocorp_vault</name>
<type name="bool" typedoc="boolean"/>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="session_token: str | None = None">
<name>session_token</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<doc>Initialize AWS Comprehend client

:param aws_key_id: access key ID
:param aws_key: secret access key
:param region: AWS region
:param use_robocorp_vault: use secret stored in `Robocorp Vault`
:param session_token: a session token associated with temporary
    credentials, such as from ``Assume Role``.</doc>
<shortdoc>Initialize AWS Comprehend client</shortdoc>
</kw>
<kw name="Init Redshift Data Client" lineno="1240">
<arguments repr="aws_key_id: str | None = None, aws_key: str | None = None, region: str | None = None, cluster_identifier: str | None = None, database: str | None = None, database_user: str | None = None, secret_arn: str | None = None, use_robocorp_vault: bool = False, session_token: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="aws_key_id: str | None = None">
<name>aws_key_id</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="aws_key: str | None = None">
<name>aws_key</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="region: str | None = None">
<name>region</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="cluster_identifier: str | None = None">
<name>cluster_identifier</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="database: str | None = None">
<name>database</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="database_user: str | None = None">
<name>database_user</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="secret_arn: str | None = None">
<name>secret_arn</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="use_robocorp_vault: bool = False">
<name>use_robocorp_vault</name>
<type name="bool" typedoc="boolean"/>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="session_token: str | None = None">
<name>session_token</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<doc>Initialize AWS Redshift Data API client

:param aws_key_id: access key ID
:param aws_key: secret access key
:param region: AWS region
:param cluster_identifier: The cluster identifier. This parameter
    is required when connecting to a cluster and authenticating
    using either Secrets Manager or temporary credentials.
:param database: The name of the database. This parameter is required
    when authenticating using either Secrets Manager or temporary
    credentials.
:param database_user: The database user name. This parameter is
    required when connecting to a cluster and authenticating using
    temporary credentials.
:param secret_arn: The name or ARN of the secret that enables access
    to the database. This parameter is required when authenticating
    using Secrets Manager.
:param use_robocorp_vault: use secret stored in ``Robocorp Vault``
:param session_token: a session token associated with temporary
    credentials, such as from ``Assume Role``.</doc>
<shortdoc>Initialize AWS Redshift Data API client</shortdoc>
</kw>
<kw name="Init S3 Client" lineno="180">
<arguments repr="aws_key_id: str | None = None, aws_key: str | None = None, region: str | None = None, use_robocorp_vault: bool = False, session_token: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="aws_key_id: str | None = None">
<name>aws_key_id</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="aws_key: str | None = None">
<name>aws_key</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="region: str | None = None">
<name>region</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="use_robocorp_vault: bool = False">
<name>use_robocorp_vault</name>
<type name="bool" typedoc="boolean"/>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="session_token: str | None = None">
<name>session_token</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<doc>Initialize AWS S3 client

:param aws_key_id: access key ID
:param aws_key: secret access key
:param region: AWS region
:param use_robocorp_vault: use secret stored in `Robocorp Vault`
:param session_token: a session token associated with temporary
    credentials, such as from ``Assume Role``.</doc>
<shortdoc>Initialize AWS S3 client</shortdoc>
</kw>
<kw name="Init Sqs Client" lineno="1130">
<arguments repr="aws_key_id: str | None = None, aws_key: str | None = None, region: str | None = None, queue_url: str | None = None, use_robocorp_vault: bool = False, session_token: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="aws_key_id: str | None = None">
<name>aws_key_id</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="aws_key: str | None = None">
<name>aws_key</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="region: str | None = None">
<name>region</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="queue_url: str | None = None">
<name>queue_url</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="use_robocorp_vault: bool = False">
<name>use_robocorp_vault</name>
<type name="bool" typedoc="boolean"/>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="session_token: str | None = None">
<name>session_token</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<doc>Initialize AWS SQS client

:param aws_key_id: access key ID
:param aws_key: secret access key
:param region: AWS region
:param queue_url: SQS queue url
:param use_robocorp_vault: use secret stored into `Robocorp Vault`
:param session_token: a session token associated with temporary
    credentials, such as from ``Assume Role``.</doc>
<shortdoc>Initialize AWS SQS client</shortdoc>
</kw>
<kw name="Init Sts Client" lineno="1766">
<arguments repr="aws_key_id: str | None = None, aws_key: str | None = None, region: str | None = None, use_robocorp_vault: bool = False, session_token: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="aws_key_id: str | None = None">
<name>aws_key_id</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="aws_key: str | None = None">
<name>aws_key</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="region: str | None = None">
<name>region</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="use_robocorp_vault: bool = False">
<name>use_robocorp_vault</name>
<type name="bool" typedoc="boolean"/>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="session_token: str | None = None">
<name>session_token</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<doc>Initialize AWS STS client.

:param aws_key_id: access key ID
:param aws_key: secret access key
:param region: AWS region
:param use_robocorp_vault: use secret stored in `Robocorp Vault`
:param session_token: a session token associated with temporary
    credentials, such as from ``Assume Role``.</doc>
<shortdoc>Initialize AWS STS client.</shortdoc>
</kw>
<kw name="Init Textract Client" lineno="596">
<arguments repr="aws_key_id: str | None = None, aws_key: str | None = None, region: str | None = None, use_robocorp_vault: bool = False, session_token: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="aws_key_id: str | None = None">
<name>aws_key_id</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="aws_key: str | None = None">
<name>aws_key</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="region: str | None = None">
<name>region</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="use_robocorp_vault: bool = False">
<name>use_robocorp_vault</name>
<type name="bool" typedoc="boolean"/>
<default>False</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="session_token: str | None = None">
<name>session_token</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<doc>Initialize AWS Textract client

:param aws_key_id: access key ID
:param aws_key: secret access key
:param region: AWS region
:param use_robocorp_vault: use secret stored in `Robocorp Vault`
:param session_token: a session token associated with temporary
    credentials, such as from ``Assume Role``.</doc>
<shortdoc>Initialize AWS Textract client</shortdoc>
</kw>
<kw name="List Buckets" lineno="244">
<arguments repr="">
</arguments>
<returntype name="list" typedoc="list"/>
<doc>List all buckets for this account

:return: list of buckets</doc>
<shortdoc>List all buckets for this account</shortdoc>
</kw>
<kw name="List Files" lineno="287">
<arguments repr="bucket_name: str, limit: int | None = None, search: str | None = None, prefix: str | None = None, **kwargs">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="bucket_name: str">
<name>bucket_name</name>
<type name="str" typedoc="string"/>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="limit: int | None = None">
<name>limit</name>
<type name="Union" union="true">
<type name="int" typedoc="integer"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="search: str | None = None">
<name>search</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="prefix: str | None = None">
<name>prefix</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="VAR_NAMED" required="false" repr="**kwargs">
<name>kwargs</name>
</arg>
</arguments>
<returntype name="list" typedoc="list"/>
<doc>List files in the bucket

**note** This keyword accepts additional parameters in key=value format

More info on `additional parameters &lt;https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3.html#S3.Client.list_objects_v2/&gt;`_.

:param bucket_name: name for the bucket
:param limit: limits the response to maximum number of items
:param search: `JMESPATH &lt;https://jmespath.org/&gt;`_ expression to filter
 objects
:param prefix: limits the response to keys that begin with the
 specified prefix
:param kwargs: allows setting all extra parameters for
 `list_objects_v2` method
:return: list of files

**Python examples**

.. code:: python

    # List all files in a bucket
    files = AWSlibrary.list_files("bucket_name")

    # List files in a bucket matching `.yaml`
    files = AWSlibrary.list_files(
        "bucket_name", search="Contents[?contains(Key, '.yaml')]"
    )

    # List files in a bucket matching `.png` and limit results to max 3
    files = AWSlibrary.list_files(
        "bucket_name", limit=3, search="Contents[?contains(Key, '.png')]"
    )

    # List files in a bucket prefixed with `special` and get only 1
    files = AWSlibrary.list_files(
        "bucket_name", prefix="special", limit=1
    )

**Robot Framework examples**

.. code:: robotframework

    # List all files in a bucket
    @{files}=   List Files   bucket-name

    # List files in a bucket matching `.yaml`
    @{files}=   List Files
    ...    bucket-name
    ...    search=Contents[?contains(Key, '.yaml')]

    # List files in a bucket matching `.png` and limit results to max 3
    @{files}=  List Files
    ...   bucket-name
    ...   limit=3
    ...   search=Contents[?contains(Key, '.png')]

    # List files in a bucket prefixed with `special` and get only 1
    @{files}=   List Files
    ...   bucket-name
    ...   prefix=special
    ...   limit=1
    )</doc>
<shortdoc>List files in the bucket</shortdoc>
</kw>
<kw name="List Redshift Databases" lineno="1699">
<arguments repr="">
</arguments>
<returntype name="List" typedoc="list">
<type name="str" typedoc="string"/>
</returntype>
<doc>List the databases in a cluster.

Database names are returned as a list of strings.</doc>
<shortdoc>List the databases in a cluster.</shortdoc>
</kw>
<kw name="List Redshift Schemas" lineno="1712">
<arguments repr="database: str | None = None, schema_pattern: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="database: str | None = None">
<name>database</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="schema_pattern: str | None = None">
<name>schema_pattern</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<returntype name="List" typedoc="list">
<type name="Dict" typedoc="dictionary"/>
</returntype>
<doc>Lists the schemas in a database.

Schema names are returned as a list of strings.

:param database: The name of the database that contains the schemas
    to list. If ommitted, will use the connected Database.
:param schema_pattern: A pattern to filter results by schema name.
    Within a schema pattern, "%" means match any substring of 0
    or more characters and "_" means match any one character.
    Only schema name entries matching the search pattern are returned.
    If ``schema_pattern`` is not specified, then all schemas are returned.</doc>
<shortdoc>Lists the schemas in a database.</shortdoc>
</kw>
<kw name="List Redshift Tables" lineno="1652">
<arguments repr="database: str | None = None, schema_pattern: str | None = None, table_pattern: str | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="database: str | None = None">
<name>database</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="schema_pattern: str | None = None">
<name>schema_pattern</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="table_pattern: str | None = None">
<name>table_pattern</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<returntype name="List" typedoc="list">
<type name="Dict" typedoc="dictionary"/>
</returntype>
<doc>List the tables in a database. If neither ``schema_pattern`` nor
``table_pattern`` are specified, then all tables in the database
are returned.

Returned objects are structured like the below JSON in a list:

.. code-block:: json

    {
        "name": "string",
        "schema": "string",
        "type": "string"
    }

:param database: The name of the database that contains the tables
    to be described. If ommitted, will use the connected Database.
:param schema_pattern: A pattern to filter results by schema name.
    Within a schema pattern, "%" means match any substring of 0
    or more characters and "_" means match any one character.
    Only schema name entries matching the search pattern are returned.
    If ``schema_pattern`` is not specified, then all tables that match
    ``table_pattern`` are returned. If neither ``schema_pattern``
    or ``table_pattern`` are specified, then all tables are returned.
:param table_pattern: A pattern to filter results by table name.
    Within a table pattern, "%" means match any substring of 0 or
    more characters and "_" means match any one character. Only
    table name entries matching the search pattern are returned.
    If ``table_pattern`` is not specified, then all tables that
    match ``schema_pattern`` are returned. If neither ``schema_pattern`` or
    ``table_pattern`` are specified, then all tables are returned.</doc>
<shortdoc>List the tables in a database. If neither ``schema_pattern`` nor ``table_pattern`` are specified, then all tables in the database are returned.</shortdoc>
</kw>
<kw name="Receive Message" lineno="1177">
<arguments repr="">
</arguments>
<returntype name="dict" typedoc="dictionary"/>
<doc>Receive message from queue

:return: message as dict</doc>
<shortdoc>Receive message from queue</shortdoc>
</kw>
<kw name="Send Message" lineno="1155">
<arguments repr="message: str | None = None, message_attributes: dict | None = None">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message: str | None = None">
<name>message</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="message_attributes: dict | None = None">
<name>message_attributes</name>
<type name="Union" union="true">
<type name="dict" typedoc="dictionary"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
</arguments>
<returntype name="dict" typedoc="dictionary"/>
<doc>Send message to the queue

:param message: body of the message
:param message_attributes: attributes of the message
:return: send message response as dict</doc>
<shortdoc>Send message to the queue</shortdoc>
</kw>
<kw name="Set Robocorp Vault" lineno="140">
<arguments repr="vault_name">
<arg kind="POSITIONAL_OR_NAMED" required="true" repr="vault_name">
<name>vault_name</name>
</arg>
</arguments>
<doc>Set Robocorp Vault name

:param vault_name: Robocorp Vault name</doc>
<shortdoc>Set Robocorp Vault name</shortdoc>
</kw>
<kw name="Start Document Analysis" lineno="783">
<arguments repr="bucket_name_in: str | None = None, object_name_in: str | None = None, object_version_in: str | None = None, bucket_name_out: str | None = None, prefix_object_out: str = textract_output">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="bucket_name_in: str | None = None">
<name>bucket_name_in</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="object_name_in: str | None = None">
<name>object_name_in</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="object_version_in: str | None = None">
<name>object_version_in</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="bucket_name_out: str | None = None">
<name>bucket_name_out</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="prefix_object_out: str = textract_output">
<name>prefix_object_out</name>
<type name="str" typedoc="string"/>
<default>textract_output</default>
</arg>
</arguments>
<doc>Starts the asynchronous analysis of an input document
for relationships between detected items such as key-value pairs,
tables, and selection elements.

:param bucket_name_in: name of the S3 bucket for the input object,
    defaults to None
:param object_name_in: name of the input object, defaults to None
:param object_version_in: version of the input object, defaults to None
:param bucket_name_out: name of the S3 bucket where to save analysis result
    object, defaults to None
:param prefix_object_out: name of the S3 bucket for the analysis result object,
:return: job identifier

Input object can be in JPEG, PNG or PDF format. Documents should
be located in the Amazon S3 bucket.

By default Amazon Textract will save the analysis result internally
to be accessed by keyword ``Get Document Analysis``. This can
be overridden by giving parameter ``bucket_name_out``.</doc>
<shortdoc>Starts the asynchronous analysis of an input document for relationships between detected items such as key-value pairs, tables, and selection elements.</shortdoc>
</kw>
<kw name="Start Document Text Detection" lineno="908">
<arguments repr="bucket_name_in: str | None = None, object_name_in: str | None = None, object_version_in: str | None = None, bucket_name_out: str | None = None, prefix_object_out: str = textract_output">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="bucket_name_in: str | None = None">
<name>bucket_name_in</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="object_name_in: str | None = None">
<name>object_name_in</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="object_version_in: str | None = None">
<name>object_version_in</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="bucket_name_out: str | None = None">
<name>bucket_name_out</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="prefix_object_out: str = textract_output">
<name>prefix_object_out</name>
<type name="str" typedoc="string"/>
<default>textract_output</default>
</arg>
</arguments>
<doc>Starts the asynchronous detection of text in a document.
Amazon Textract can detect lines of text and the words that make up a
line of text.

:param bucket_name_in: name of the S3 bucket for the input object,
    defaults to None
:param object_name_in: name of the input object, defaults to None
:param object_version_in: version of the input object, defaults to None
:param bucket_name_out: name of the S3 bucket where to save analysis result
    object, defaults to None
:param prefix_object_out: name of the S3 bucket for the analysis result object,
:return: job identifier

Input object can be in JPEG, PNG or PDF format. Documents should
be located in the Amazon S3 bucket.

By default Amazon Textract will save the analysis result internally
to be accessed by keyword ``Get Document Text Detection``. This can
be overridden by giving parameter ``bucket_name_out``.</doc>
<shortdoc>Starts the asynchronous detection of text in a document. Amazon Textract can detect lines of text and the words that make up a line of text.</shortdoc>
</kw>
<kw name="Upload File" lineno="413">
<arguments repr="bucket_name: str | None = None, filename: str | None = None, object_name: str | None = None, **kwargs">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="bucket_name: str | None = None">
<name>bucket_name</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="filename: str | None = None">
<name>filename</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="object_name: str | None = None">
<name>object_name</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="VAR_NAMED" required="false" repr="**kwargs">
<name>kwargs</name>
</arg>
</arguments>
<returntype name="tuple" typedoc="tuple"/>
<doc>Upload single file into bucket

:param bucket_name: name for the bucket
:param filename: filepath for the file to be uploaded
:param object_name: name of the object in the bucket, defaults to None
:return: tuple of upload status and error

If `object_name` is not given then basename of the file is
used as `object_name`.

**note** This keyword accepts additional parameters in key=value format (see below code example).

More info on `additional parameters &lt;https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3.html#S3.Client.upload_file/&gt;`_.

Robot Framework example:

.. code-block:: robotframework

    &amp;{extras}=    Evaluate    {'ContentType': 'image/png'}
    ${uploaded}    ${error}=    Upload File
    ...    mybucket
    ...    ${CURDIR}${/}image.png
    ...    image.png
    ...    ExtraArgs=${extras}</doc>
<shortdoc>Upload single file into bucket</shortdoc>
</kw>
<kw name="Upload Files" lineno="451">
<arguments repr="bucket_name: str | None = None, files: list | None = None, **kwargs">
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="bucket_name: str | None = None">
<name>bucket_name</name>
<type name="Union" union="true">
<type name="str" typedoc="string"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="POSITIONAL_OR_NAMED" required="false" repr="files: list | None = None">
<name>files</name>
<type name="Union" union="true">
<type name="list" typedoc="list"/>
<type name="None" typedoc="None"/>
</type>
<default>None</default>
</arg>
<arg kind="VAR_NAMED" required="false" repr="**kwargs">
<name>kwargs</name>
</arg>
</arguments>
<returntype name="list" typedoc="list"/>
<doc>Upload multiple files into bucket

:param bucket_name: name for the bucket
:param files: list of files (2 possible ways, see above)
:return: number of files uploaded

Giving files as list of filepaths:
    ['/path/to/file1.txt', '/path/to/file2.txt']

Giving files as list of dictionaries (including filepath and object name):
    [{'filename':'/path/to/file1.txt', 'object_name': 'file1.txt'},
    {'filename': '/path/to/file2.txt', 'object_name': 'file2.txt'}]

**note** This keyword accepts additional parameters in key=value format (see below code example).

More info on `additional parameters &lt;https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3.html#S3.Client.upload_file/&gt;`_.

Python example (passing ExtraArgs):

.. code-block:: python

    upload_files = [
        {
            "filename": "./image.png",
            "object_name": "image.png",
            "ExtraArgs": {"ContentType": "image/png", "Metadata": {"importance": "1"}},
        },
        {
            "filename": "./doc.pdf",
            "object_name": "doc.pdf",
            "ExtraArgs": {"ContentType": "application/pdf"},
        },
    ]
    awslibrary.upload_files("mybucket", files=upload_files)</doc>
<shortdoc>Upload multiple files into bucket</shortdoc>
</kw>
</keywords>
<typedocs>
<type name="boolean" type="Standard">
<doc>Strings ``TRUE``, ``YES``, ``ON`` and ``1`` are converted to Boolean ``True``,
the empty string as well as strings ``FALSE``, ``NO``, ``OFF`` and ``0``
are converted to Boolean ``False``, and the string ``NONE`` is converted
to the Python ``None`` object. Other strings and other accepted values are
passed as-is, allowing keywords to handle them specially if
needed. All string comparisons are case-insensitive.

Examples: ``TRUE`` (converted to ``True``), ``off`` (converted to ``False``),
``example`` (used as-is)
</doc>
<accepts>
<type>string</type>
<type>integer</type>
<type>float</type>
<type>None</type>
</accepts>
<usages>
<usage>Analyze Document</usage>
<usage>Create Bucket</usage>
<usage>Delete Bucket</usage>
<usage>Detect Document Text</usage>
<usage>Execute Redshift Statement</usage>
<usage>Execute Redshift Statement Asyncronously</usage>
<usage>Get Document Analysis</usage>
<usage>Get Document Text Detection</usage>
<usage>Init Comprehend Client</usage>
<usage>Init Redshift Data Client</usage>
<usage>Init S3 Client</usage>
<usage>Init Sqs Client</usage>
<usage>Init Sts Client</usage>
<usage>Init Textract Client</usage>
</usages>
</type>
<type name="dictionary" type="Standard">
<doc>Strings must be Python [https://docs.python.org/library/stdtypes.html#dict|dictionary]
literals. They are converted to actual dictionaries using the
[https://docs.python.org/library/ast.html#ast.literal_eval|ast.literal_eval]
function. They can contain any values ``ast.literal_eval`` supports, including
dictionaries and other containers.

If the type has nested types like ``dict[str, int]``, items are converted
to those types automatically. This in new in Robot Framework 6.0.

Examples: ``{'a': 1, 'b': 2}``, ``{'key': 1, 'nested': {'key': 2}}``
</doc>
<accepts>
<type>string</type>
<type>Mapping</type>
</accepts>
<usages>
<usage>Assume Role</usage>
<usage>Create Redshift Statement Parameters</usage>
<usage>Describe Redshift Table</usage>
<usage>Detect Entities</usage>
<usage>Detect Sentiment</usage>
<usage>Execute Redshift Statement</usage>
<usage>Get Document Analysis</usage>
<usage>Get Document Text Detection</usage>
<usage>Get Pages And Text</usage>
<usage>Get Redshift Statement Results</usage>
<usage>List Redshift Schemas</usage>
<usage>List Redshift Tables</usage>
<usage>Receive Message</usage>
<usage>Send Message</usage>
</usages>
</type>
<type name="integer" type="Standard">
<doc>Conversion is done using Python's [https://docs.python.org/library/functions.html#int|int]
built-in function. Floating point
numbers are accepted only if they can be represented as integers exactly.
For example, ``1.0`` is accepted and ``1.1`` is not.

Starting from RF 4.1, it is possible to use hexadecimal, octal and binary
numbers by prefixing values with ``0x``, ``0o`` and ``0b``, respectively.

Starting from RF 4.1, spaces and underscores can be used as visual separators
for digit grouping purposes.

Examples: ``42``, ``-1``, ``0b1010``, ``10 000 000``, ``0xBAD_C0FFEE``
</doc>
<accepts>
<type>string</type>
<type>float</type>
</accepts>
<usages>
<usage>Assume Role</usage>
<usage>Execute Redshift Statement</usage>
<usage>Generate Presigned Url</usage>
<usage>Get Document Analysis</usage>
<usage>Get Document Text Detection</usage>
<usage>Get Redshift Statement Results</usage>
<usage>List Files</usage>
</usages>
</type>
<type name="list" type="Standard">
<doc>Strings must be Python [https://docs.python.org/library/stdtypes.html#list|list]
literals. They are converted to actual lists using the
[https://docs.python.org/library/ast.html#ast.literal_eval|ast.literal_eval]
function. They can contain any values ``ast.literal_eval`` supports, including
lists and other containers.

If the type has nested types like ``list[int]``, items are converted
to those types automatically. This in new in Robot Framework 6.0.

Examples: ``['one', 'two']``, ``[('one', 1), ('two', 2)]``
</doc>
<accepts>
<type>string</type>
<type>Sequence</type>
</accepts>
<usages>
<usage>Assume Role</usage>
<usage>Create Redshift Statement Parameters</usage>
<usage>Delete Files</usage>
<usage>Describe Redshift Table</usage>
<usage>Download Files</usage>
<usage>Execute Redshift Statement</usage>
<usage>Execute Redshift Statement Asyncronously</usage>
<usage>List Buckets</usage>
<usage>List Files</usage>
<usage>List Redshift Databases</usage>
<usage>List Redshift Schemas</usage>
<usage>List Redshift Tables</usage>
<usage>Upload Files</usage>
</usages>
</type>
<type name="None" type="Standard">
<doc>String ``NONE`` (case-insensitive) is converted to Python ``None`` object.
Other values cause an error.
</doc>
<accepts>
<type>string</type>
</accepts>
<usages>
<usage>__init__</usage>
<usage>Analyze Document</usage>
<usage>Assume Role</usage>
<usage>Create Bucket</usage>
<usage>Create Queue</usage>
<usage>Delete Bucket</usage>
<usage>Delete Files</usage>
<usage>Delete Message</usage>
<usage>Delete Queue</usage>
<usage>Describe Redshift Table</usage>
<usage>Detect Document Text</usage>
<usage>Detect Entities</usage>
<usage>Detect Sentiment</usage>
<usage>Download Files</usage>
<usage>Execute Redshift Statement</usage>
<usage>Execute Redshift Statement Asyncronously</usage>
<usage>Generate Presigned Url</usage>
<usage>Get Document Analysis</usage>
<usage>Get Document Text Detection</usage>
<usage>Init Comprehend Client</usage>
<usage>Init Redshift Data Client</usage>
<usage>Init S3 Client</usage>
<usage>Init Sqs Client</usage>
<usage>Init Sts Client</usage>
<usage>Init Textract Client</usage>
<usage>List Files</usage>
<usage>List Redshift Schemas</usage>
<usage>List Redshift Tables</usage>
<usage>Send Message</usage>
<usage>Start Document Analysis</usage>
<usage>Start Document Text Detection</usage>
<usage>Upload File</usage>
<usage>Upload Files</usage>
</usages>
</type>
<type name="string" type="Standard">
<doc>All arguments are converted to Unicode strings.</doc>
<accepts>
<type>Any</type>
</accepts>
<usages>
<usage>__init__</usage>
<usage>Analyze Document</usage>
<usage>Assume Role</usage>
<usage>Create Bucket</usage>
<usage>Create Queue</usage>
<usage>Create Redshift Statement Parameters</usage>
<usage>Delete Bucket</usage>
<usage>Delete Files</usage>
<usage>Delete Message</usage>
<usage>Delete Queue</usage>
<usage>Describe Redshift Table</usage>
<usage>Detect Document Text</usage>
<usage>Detect Entities</usage>
<usage>Detect Sentiment</usage>
<usage>Download Files</usage>
<usage>Execute Redshift Statement</usage>
<usage>Execute Redshift Statement Asyncronously</usage>
<usage>Generate Presigned Url</usage>
<usage>Get Document Analysis</usage>
<usage>Get Document Text Detection</usage>
<usage>Get Redshift Statement Results</usage>
<usage>Init Comprehend Client</usage>
<usage>Init Redshift Data Client</usage>
<usage>Init S3 Client</usage>
<usage>Init Sqs Client</usage>
<usage>Init Sts Client</usage>
<usage>Init Textract Client</usage>
<usage>List Files</usage>
<usage>List Redshift Databases</usage>
<usage>List Redshift Schemas</usage>
<usage>List Redshift Tables</usage>
<usage>Send Message</usage>
<usage>Start Document Analysis</usage>
<usage>Start Document Text Detection</usage>
<usage>Upload File</usage>
<usage>Upload Files</usage>
</usages>
</type>
<type name="tuple" type="Standard">
<doc>Strings must be Python [https://docs.python.org/library/stdtypes.html#tuple|tuple]
literals. They are converted to actual tuples using the
[https://docs.python.org/library/ast.html#ast.literal_eval|ast.literal_eval]
function. They can contain any values ``ast.literal_eval`` supports, including
tuples and other containers.

If the type has nested types like ``tuple[str, int, int]``, items are converted
to those types automatically. This in new in Robot Framework 6.0.

Examples: ``('one', 'two')``, ``(('one', 1), ('two', 2))``
</doc>
<accepts>
<type>string</type>
<type>Sequence</type>
</accepts>
<usages>
<usage>Generate Presigned Url</usage>
<usage>Upload File</usage>
</usages>
</type>
</typedocs>
</keywordspec>
