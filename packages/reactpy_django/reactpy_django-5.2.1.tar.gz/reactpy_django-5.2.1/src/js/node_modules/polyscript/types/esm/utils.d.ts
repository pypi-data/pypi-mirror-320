export function createFunction(value: any): any;
export function createResolved(module: any, type: any, config: any, interpreter: any): {
    type: any;
    config: any;
    interpreter: any;
    io: any;
    run: (code: any, ...args: any[]) => any;
    runAsync: (code: any, ...args: any[]) => any;
    runEvent: (...args: any[]) => any;
};
export function createOverload(module: any, name: any, before: any, after: any): void;
export const js_modules: unique symbol;
export const JSModules: Map<any, any>;
export function registerJSModules(type: any, module: any, interpreter: any, modules: any): void;
export function importJS(source: any, name: any): Promise<void>;
export function importCSS(href: any): Promise<any>;
export function isCSS(source: any): boolean;
export function isSync(element: any): boolean;
import IDBMapSync from '@webreflection/idb-map/sync';
/** @type {(tpl: string | TemplateStringsArray, ...values:any[]) => string} */
export const dedent: (tpl: string | TemplateStringsArray, ...values: any[]) => string;
/** @type {(value:string) => string} */
export const unescape: (value: string) => string;
/**
 * Notify the main thread about element "readiness".
 * @param {HTMLScriptElement | HTMLElement} target the script or custom-type element
 * @param {string} type the custom/type as event prefix
 * @param {string} what the kind of event to dispatch, i.e. `ready` or `done`
 * @param {boolean} [worker = false] `true` if dispatched form a worker, `false` by default if in main
 * @param {globalThis.CustomEvent} [CustomEvent = globalThis.CustomEvent] the `CustomEvent` to use
 */
export function dispatch(target: HTMLScriptElement | HTMLElement, type: string, what: string, worker?: boolean, CE?: {
    new <T>(type: string, eventInitDict?: CustomEventInit<T>): CustomEvent<T>;
    prototype: CustomEvent;
}): void;
export const isArray: (arg: any) => arg is any[];
export const assign: {
    <T extends {}, U>(target: T, source: U): T & U;
    <T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V;
    <T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;
    (target: object, ...sources: any[]): any;
};
export const create: {
    (o: object | null): any;
    (o: object | null, properties: PropertyDescriptorMap & ThisType<any>): any;
};
export const defineProperties: <T>(o: T, properties: PropertyDescriptorMap & ThisType<any>) => T;
export const defineProperty: <T>(o: T, p: PropertyKey, attributes: PropertyDescriptor & ThisType<any>) => T;
export const entries: {
    <T>(o: {
        [s: string]: T;
    } | ArrayLike<T>): [string, T][];
    (o: {}): [string, any][];
};
export const all: {
    <T>(values: Iterable<T | PromiseLike<T>>): Promise<Awaited<T>[]>;
    <T extends readonly unknown[] | []>(values: T): Promise<{ -readonly [P in keyof T]: Awaited<T[P]>; }>;
};
export const resolve: {
    (): Promise<void>;
    <T>(value: T): Promise<Awaited<T>>;
    <T>(value: T | PromiseLike<T>): Promise<Awaited<T>>;
};
export function absoluteURL(path: any, base?: string): string;
export function nodeInfo(node: any, type: any): {
    id: any;
    tag: any;
};
export { IDBMapSync };
