"""Sherlock is a python SDK for AI agents to interact with the Sherlock API."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['API_URL', 'me_endpoint', 'get_offers_endpoint', 'Sherlock', 'Contact', 'main']

# %% ../nbs/00_core.ipynb 3
from typing import Dict, Any
import httpx, json, time
from cryptography.hazmat.primitives.asymmetric import ed25519
import fastcore.utils as fc
from fastcore.test import *
from fastcore.script import *
from fastcore.utils import first, last, L, patch
from fastcore.all import asdict
from .crypto import *

# %% ../nbs/00_core.ipynb 4
API_URL = "https://api.sherlockdomains.com"

# %% ../nbs/00_core.ipynb 9
def _handle_response(r):
    "Process response: raise for status and return json if possible. 402 status is expected for payment required."
    if r.status_code != 402: r.raise_for_status()
    try: return r.json()
    except: return r

def _get_challenge(pub_key: str): # public key
    "Get authentication challenge for a public key"
    r = httpx.post(f"{API_URL}/api/v0/auth/challenge", json={"public_key": pub_key})
    return _handle_response(r)['challenge']


# %% ../nbs/00_core.ipynb 13
def _sign_challenge(pk: ed25519.Ed25519PrivateKey, 
                   c: str): # challenge
    "Sign a challenge with a private key"
    return pk.sign(bytes.fromhex(c)).hex()

# %% ../nbs/00_core.ipynb 17
def _submit_challenge(pub: str, # public key
          c: str, # challenge
          sig: str): # signature
    "Submit a challenge and signature to the server to get access and refresh tokens"
    r = httpx.post(f"{API_URL}/api/v0/auth/login", json={
        "public_key": pub,
        "challenge": c,
        "signature": sig
    })
    r = _handle_response(r)
    return r['access'], r['refresh']

# %% ../nbs/00_core.ipynb 21
from .config import *

# %% ../nbs/00_core.ipynb 22
class Sherlock:
    "Sherlock client class to interact with the Sherlock API."
    def __init__(self,
                priv : str = ''): # private key
        """
        Initialize Sherlock with a private key. If no key is provided, a new one is generated and stored in the config file.
        """
        cfg = get_cfg()

        if priv: self.pk, self.pub = from_pk_hex(priv) # if provided use the private key
        elif cfg.priv: self.pk, self.pub = from_pk_hex(cfg.priv) # if not provided use the private key from the config file
        else: 
            self.pk, self.pub = generate_keys()
            save_cfg({'priv': priv_key_hex(self.pk)})

        # access & refresh token for authenticated requests
        self.atok, self.rtok = self._authenticate()
        
    def _authenticate(self):
        "Authenticate with the server with a public key and private key"
        c = _get_challenge(self.pub)
        sig = _sign_challenge(self.pk, c)
        return _submit_challenge(self.pub, c, sig)
    
    def __str__(self): return f"Sherlock(pubkey={self.pub})"
    __repr__ = __str__

# %% ../nbs/00_core.ipynb 27
me_endpoint = f"{API_URL}/api/v0/auth/me"

# %% ../nbs/00_core.ipynb 28
def _mk_headers(tok): return {"Authorization": f"Bearer {tok}"}

# %% ../nbs/00_core.ipynb 30
@patch
def me(self: Sherlock):
    "Get authenticated user information"
    r = httpx.get(me_endpoint, headers=_mk_headers(self.atok))
    return _handle_response(r)

# %% ../nbs/00_core.ipynb 31
@patch
def _me(self: Sherlock):
    """Makes an authenticated request to verify the current authentication status.

    Returns:
        dict: Authentication status containing:
            - logged_in (bool): Whether the user is authenticated

    Raises:
        HTTPError: If the request fails or authentication is invalid
    """
    return self.me()

# %% ../nbs/00_core.ipynb 35
@patch
def search(self: Sherlock,
                  q: str): # query
    "Search for domains with a query. Returns prices in USD cents."
    r = httpx.get(f"{API_URL}/api/v0/domains/search", params={"query": q})
    return _handle_response(r)

# %% ../nbs/00_core.ipynb 36
@patch
def _search(self: Sherlock,
                  q: str):
    """Search for available domains matching the query.
    
    Args:
        q (str): Query string to search for domains (can be a full domain name or partial text)
    
    Returns:
        dict: Search results containing:
            - id (str): Unique search ID used for subsequent purchase requests
            - created_at (str): ISO timestamp of when the search was performed
            - available (list): List of available domains, each containing:
                - name (str): Full domain name
                - tld (str): Top-level domain
                - tags (list): Domain categories or features
                - price (int): Price in USD cents
                - currency (str): Currency code (e.g., 'USD')
                - available (bool): Domain availability status
            - unavailable (list): List of unavailable domain names
    
    Raises:
        HTTPError: If the search request fails
        ValueError: If query contains invalid characters
    """
    return self.search(q)

# %% ../nbs/00_core.ipynb 39
class Contact(fc.BasicRepr):
    "Contact information for a domain purchase"
    first_name: str
    last_name: str
    email: str
    address: str
    city: str
    state: str
    postal_code: str
    country: str

    def __init__(self, first_name, last_name, email, address, city, state, postal_code, country): fc.store_attr()
    def asdict(self): return self.__dict__['__stored_args__']
    def from_dict(d): return Contact(**d) if d else None


# %% ../nbs/00_core.ipynb 40
@patch
def is_valid(self: Contact):
    "Check if the contact information is valid"
    return all(self.__dict__.values())

@patch
def set_contact_information(self: Sherlock,
                      cfn: str = '', # contact first name
                      cln: str = '', # contact last name
                      cem: str = '', # contact email
                      cadd: str = '', # contact address
                      cct: str = '', # contact city
                      cst: str = '', # contact state
                      cpc: str = '', # contact postal code
                      ccn: str = ''): # contact country
    "Set the contact information for the Sherlock user"
    c = Contact(cfn, cln, cem, cadd, cct, cst, cpc, ccn)
    if not c.is_valid(): raise ValueError("Invalid contact information")

    data = {
        "first_name": cfn,
        "last_name": cln,
        "email": cem,
        "address": cadd,
        "city": cct,
        "state": cst,
        "postal_code": cpc,
        "country": ccn
    }
    r = httpx.post(f"{API_URL}/api/v0/users/contact-information", json=data, headers=_mk_headers(self.atok))
    return _handle_response(r)


@patch
def get_contact_information(self: Sherlock):
    "Get the contact information for the Sherlock user."

    #| hide
    r = httpx.get(f"{API_URL}/api/v0/users/contact-information", headers=_mk_headers(self.atok))
    return _handle_response(r)
   

# %% ../nbs/00_core.ipynb 41
@patch
def _set_contact_information(self: Sherlock,
                      cfn: str = '', # contact first name
                      cln: str = '', # contact last name
                      cem: str = '', # contact email
                      cadd: str = '', # contact address
                      cct: str = '', # contact city
                      cst: str = '', # contact state
                      cpc: str = '', # contact postal code
                      ccn: str = ''): # contact country
    """Set the contact information that will be used for domain purchases and ICANN registration
    
    Args:
        cfn (str): First name
        cln (str): Last name
        cem (str): Email address
        cadd (str): Street address
        cct (str): City
        cst (str): State/Province (e.g., 'CA', 'AZ', 'NY', 'BC', 'Madrid', etc.)
        cpc (str): Postal code
        ccn (str): Country code (e.g., 'US', 'ES', 'FR', etc.)
    
    Raises:
        ValueError: If any required field is empty
    """
    return self.set_contact_information(cfn, cln, cem, cadd, cct, cst, cpc, ccn)


@patch
def _get_contact_information(self: Sherlock):
    """Retrieve the currently configured contact information that will be used for domain purchases and ICANN registration
    
    Returns:
        Contact: Contact information object
    """
    return self.get_contact_information()


# %% ../nbs/00_core.ipynb 47
get_offers_endpoint = f"{API_URL}/api/v0/domains/purchase"

# %% ../nbs/00_core.ipynb 48
def _get_offers_data(domain: str, # domain
                   contact: Contact, # contact
                   sid: str): # search id
    "Make a purchase payload"
    return {"domain": domain, "contact_information": contact.asdict(), "search_id": sid}

# %% ../nbs/00_core.ipynb 51
@patch
def get_purchase_offers(self: Sherlock,
                      sid: str, # search id
                      domain: str): # domain
    """Request purchase offers for a domain.
    
    Args:
        sid (str): Search ID from previous search request
        domain (str): Domain name to purchase

       
    
    Returns:
        dict: L402  payment offers containing:
            - version (str): API version
            - payment_request_url (str): URL for payment processing
            - payment_context_token (str): Token for payment context
            - offers (list): List of payment offers, each containing:
                - id (str): Offer ID
                - title (str): Domain name
                - description (str): Purchase description
                - type (str): Payment type (e.g., 'one-time')
                - amount (int): Price in cents
                - currency (str): Currency code
                - payment_methods (list): Available payment methods
    
    Raises:
        ValueError: If contact information is missing
        HTTPError: If request fails
    """
    c = Contact(**self.get_contact_information())
    if not c or not c.is_valid(): raise ValueError("Contact information is required")

    r = httpx.post(get_offers_endpoint, json=_get_offers_data(domain, c, sid), headers=_mk_headers(self.atok))
    return _handle_response(r)

# %% ../nbs/00_core.ipynb 56
@patch
def get_payment_request(self: Sherlock,
                    prurl: str, # payment request url
                    oid: str, # offer id
                    pm: str, # payment method
                    pct: str): # payment context token
    """Get payment request for an offer. `offer_id` and `payment_context_token` are returned by `get_purchase_offers`. The supported payment methods are currently 'credit_card' and 'lightning'."""
    data = {
        "offer_id": oid,
        "payment_method": pm,
        "payment_context_token": pct
    }
    r = httpx.post(prurl, json=data)
    return _handle_response(r)


# %% ../nbs/00_core.ipynb 58
@patch
def _purchase_domain(self: Sherlock,
                    sid: str, # search id
                    domain: str, # domain
                    payment_method: str = 'credit_card'): # payment method {'credit_card', 'lightning'}
    """
    Purchase a domain. This method won't charge your account, it will return the payment information for purchasing a domain.
    For credit card payments it returns a checkout URL. For Lightning Network payments it returns an invoice.

    NOTE: Before calling this method the contact information needs to be set for the Sherlock object.

    Args:
        sid (str): Search ID from previous search request
        domain (str): Domain name to purchase
        payment_method (str): Payment method {'credit_card', 'lightning'}
    
    Returns:
        dict:
            - payment_method (dict): 
                - checkout_url (str): URL for credit card payment processing
                - lightning_invoice (str): Lightning Network invoice
            - expires_at (str): ISO timestamp of when the payment expires
    """
    return self.purchase_domain(sid, domain, payment_method)

@patch
def purchase_domain(self: Sherlock,
                    sid: str, # search id
                    domain: str, # domain
                    payment_method: str = 'credit_card'): # payment method {'credit_card', 'lightning'}
    """
    Purchase a domain, it will return the payment information for purchasing a domain.
    This method won't charge your account, the payment needs to be processed outband (checkout url, lightning invoice, etc.).
    """
    c = Contact(**self.get_contact_information())
    if not c or not c.is_valid(): raise ValueError("Contact information is required")
    offers = self.get_purchase_offers(sid, domain)
    return self.get_payment_request(offers['payment_request_url'], offers['offers'][0]['id'], payment_method, offers['payment_context_token'])


# %% ../nbs/00_core.ipynb 60
@patch
def domains(self:Sherlock):
    "List of domains owned by the authenticated user"
    r = httpx.get(f"{API_URL}/api/v0/domains/domains", headers=_mk_headers(self.atok))
    return _handle_response(r)

# %% ../nbs/00_core.ipynb 61
@patch
def _domains(self:Sherlock):
    """List domains owned by the authenticated user.
    
    Returns:
        list: List of domain objects containing:
            - id (str): Unique domain identifier (domain_id in other methods)
            - domain_name (str): The registered domain name
            - created_at (str): ISO timestamp of domain creation
            - expires_at (str): ISO timestamp of domain expiration
            - auto_renew (bool): Whether domain is set to auto-renew
            - locked (bool): Domain transfer lock status
            - private (bool): WHOIS privacy protection status
            - nameservers (list): List of nameserver hostnames
            - status (str): Domain status (e.g. 'active')
    
    Raises:
        HTTPError: If the request fails or authentication is invalid
    """
    return self.domains()


# %% ../nbs/00_core.ipynb 63
@patch
def dns_records(self:Sherlock,
                domain_id: str): # domain id
    "Get DNS records for a domain."
    r = httpx.get(f"{API_URL}/api/v0/domains/{domain_id}/dns/records", 
                 headers=_mk_headers(self.atok))
    return _handle_response(r)

# %% ../nbs/00_core.ipynb 64
@patch
def _dns_records(self:Sherlock,
                domain_id: str):
    """Get DNS records for a domain.

    Args
        domain_id: str - domain uuid (e.g: 'd1234567-89ab-cdef-0123-456789abcdef')
    
    Returns:
        str: Domain name
        list: List of DNS records with:
            - id (str): Unique record identifier
            - type (str): DNS record type (e.g. 'A', 'CNAME', 'MX', 'TXT')
            - name (str): DNS record name
            - value (str): DNS record value
            - ttl (int): Time to live in seconds
    """
    return self.dns_records(domain_id)

# %% ../nbs/00_core.ipynb 66
@patch
def create_dns(self:Sherlock,
               domain_id: str, # domain id
               type: str = "TXT", # type
               name: str = "test", # name
               value: str = "test-1", # value
               ttl: int = 3600): # ttl
    "Create a new DNS record"
    data = {"records": [{"type":type, "name":name, "value":value, "ttl":ttl}]}
    r = httpx.post(f"{API_URL}/api/v0/domains/{domain_id}/dns/records",
                  headers=_mk_headers(self.atok), json=data)
    return _handle_response(r)

# %% ../nbs/00_core.ipynb 68
@patch
def _create_dns_record(self:Sherlock,
                domain_id: str, # domain id
                type: str = "TXT", # type
                name: str = "test", # name
                value: str = "test-1", # value
                ttl: int = 3600): # ttl
    """Create a new DNS record for a domain.
    
    Args:
        domain_id (str): Domain UUID (e.g., 'd1234567-89ab-cdef-0123-456789abcdef')
        type (str): DNS record type ('A', 'AAAA', 'CNAME', 'MX', 'TXT', etc.)
        name (str): Subdomain or record name (e.g., 'www' creates www.yourdomain.com)
        value (str): Record value (e.g., IP address for A records, domain for CNAME)
        ttl (int): Time To Live in seconds (default: 3600)
    
    Returns:
        dict: Created DNS record containing:
            - records (list): List with the created record containing:
                - id (str): Unique record identifier
                - type (str): DNS record type
                - name (str): Record name
                - value (str): Record value
                - ttl (int): Time to live in seconds
    
    Raises:
        HTTPError: If the request fails or authentication is invalid
    """
    return self.create_dns(domain_id, type, name, value, ttl)


# %% ../nbs/00_core.ipynb 70
@patch
def update_dns(self:Sherlock,
               domain_id: str, # domain id
               record_id: str, # record id
               type: str = "TXT", # type
               name: str = "test-2", # name
               value: str = "test-2", # value
               ttl: int = 3600): # ttl
    "Update a DNS record"
    data = {"records": [{"id":record_id, "type":type, "name":name, 
                        "value":value, "ttl":ttl}]}
    r = httpx.patch(f"{API_URL}/api/v0/domains/{domain_id}/dns/records",
                   headers=_mk_headers(self.atok), json=data)
    return _handle_response(r)

# %% ../nbs/00_core.ipynb 72
@patch
def _update_dns_record(self:Sherlock,
                domain_id: str, # domain id
                record_id: str, # record id
                type: str = "TXT", # type
                name: str = "test-2", # name
                value: str = "test-2", # value
                ttl: int = 3600): # ttl
    """Update an existing DNS record for a domain.

    NOTE: Updating a record will change its record id.
    
    Args:
        domain_id (str): Domain UUID (e.g., 'd1234567-89ab-cdef-0123-456789abcdef')
        record_id (str): DNS record UUID to update
        type (str): DNS record type ('A', 'AAAA', 'CNAME', 'MX', 'TXT', etc.)
        name (str): Subdomain or record name (e.g., 'www' for www.yourdomain.com)
        value (str): New record value (e.g., IP address for A records)
        ttl (int): Time To Live in seconds (default: 3600)
    
    Returns:
        dict: Updated DNS record containing:
            - records (list): List with the modified record containing:
                - id (str): Record identifier
                - type (str): DNS record type
                - name (str): Record name
                - value (str): Updated value
                - ttl (int): Time to live in seconds
    
    Raises:
        HTTPError: If the request fails, record doesn't exist, or authentication is invalid
    """
    return self.update_dns(domain_id, record_id, type, name, value, ttl)


# %% ../nbs/00_core.ipynb 73
@patch
def delete_dns(self:Sherlock,
               domain_id: str, # domain id
               record_id: str): # record id
    "Delete a DNS record"
    r = httpx.delete(f"{API_URL}/api/v0/domains/{domain_id}/dns/records/{record_id}",
                    headers=_mk_headers(self.atok))
    return _handle_response(r)

# %% ../nbs/00_core.ipynb 75
@patch
def _delete_dns_record(self:Sherlock,
                domain_id: str, # domain id
                record_id: str): # record id
    """Delete a DNS record for a domain.
    
    Args:
        domain_id (str): Domain UUID (e.g., 'd1234567-89ab-cdef-0123-456789abcdef')
        record_id (str): DNS record ID to delete
    
    Returns:
        dict: Empty response
    """
    return self.delete_dns(domain_id, record_id)


# %% ../nbs/00_core.ipynb 77
@patch
def as_tools(self:Sherlock):
    "Return the Sherlock class as a list of tools ready for agents to use"
    return L([
        self._me,
        self._set_contact_information,
        self._get_contact_information,
        self._search, 
        self._purchase_domain,
        self._domains,
        self._dns_records,
        self._create_dns_record,
        self._update_dns_record,
        self._delete_dns_record,
    ])

# %% ../nbs/00_core.ipynb 80
from inspect import signature, Parameter
import argparse

# %% ../nbs/00_core.ipynb 81
@patch
def as_cli(self:Sherlock):
    "Return the Sherlock class as a list of tools ready for agents to use"
    return L([
        self.me,
        self.set_contact_information,
        self.get_contact_information,
        self.search, 
        self.purchase_domain,
        self.domains,
        self.dns_records,
        self.create_dns,
        self.update_dns,
        self.delete_dns,
    ])

# %% ../nbs/00_core.ipynb 83
def main():
    "CLI interface for Sherlock"
    parser = argparse.ArgumentParser()
    sub = parser.add_subparsers(dest='cmd')
    s = Sherlock()
    
    for m in s.as_cli():
        p = sub.add_parser(m.__name__, help=m.__doc__)
        for name,param in signature(m).parameters.items():
            if name != 'self': 
                required = param.default == param.empty
                p.add_argument(f'--{name}', required=required)
    
    args = parser.parse_args()
    if args.cmd: print(getattr(s,args.cmd)(**{k:v for k,v in vars(args).items() 
                                             if k!='cmd' and v is not None}))
    else: parser.print_help()
