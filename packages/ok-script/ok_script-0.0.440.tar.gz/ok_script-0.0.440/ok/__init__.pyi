import numpy as np

import queue
import re
import threading
from dataclasses import dataclass, field
from typing import List, Dict, Union, Tuple, Optional, Callable, Any


class Box:
    x: int
    y: int
    width: int
    height: int
    confidence: float
    name: Optional[str]

    def __init__(self, x: int, y: int, width: int = 0, height: int = 0, confidence: float = 1.0,
                 name: Optional[str] = None, to_x: int = -1, to_y: int = -1) -> None: ...

    def __eq__(self, other: object) -> bool: ...

    def in_boundary(self, boxes: List['Box']) -> List['Box']: ...

    def __repr__(self) -> str: ...

    def __str__(self) -> str: ...

    def scale(self, width_ratio: float, height_ratio: float) -> 'Box': ...

    def closest_distance(self, other: 'Box') -> float: ...

    def relative_with_variance(self, relative_x: float = 0.5, relative_y: float = 0.5) -> Tuple[int, int]: ...

    def copy(self, x_offset: int = 0, y_offset: int = 0, width_offset: int = 0, height_offset: int = 0,
             name: Optional[str] = None) -> 'Box': ...

    def crop_frame(self, frame: np.ndarray) -> np.ndarray: ...

    def center(self) -> Tuple[float, float]: ...

    def find_closest_box(self, direction: str, boxes: List['Box'],
                         condition: Optional[Callable[['Box'], bool]] = None) -> Optional['Box']: ...


def box_intersect(box1: Box, box2: Box) -> bool: ...


def compare_boxes(box1: Box, box2: Box) -> int: ...


def find_highest_confidence_box(boxes: List[Box]) -> Optional[Box]: ...


def sort_boxes(boxes: List[Box]) -> List[Box]: ...


def find_box_by_name(boxes: List[Box], names: Union[str, List[Union[str, re.Pattern]]]) -> Optional[Box]: ...


def get_bounding_box(boxes: List[Box]) -> Box: ...


def find_boxes_within_boundary(boxes: List[Box], boundary_box: Box, sort: bool = True) -> List[Box]: ...


def average_width(boxes: List[Box]) -> int: ...


def crop_image(image: np.ndarray, box: Optional[Box] = None) -> np.ndarray: ...


def relative_box(frame_width: int, frame_height: int, x: float, y: float, to_x: float = 1, to_y: float = 1,
                 width: float = 0, height: float = 0, name: Optional[str] = None) -> Box: ...


def find_boxes_by_name(boxes: List[Box], names: Union[str, re.Pattern, List[Union[str, re.Pattern]]]) -> List[Box]: ...


class Logger:
    @staticmethod
    def get_logger(name: str) -> 'Logger': ...

    def debug(self, message: object) -> None: ...

    def info(self, message: object) -> None: ...

    def warning(self, message: object) -> None: ...

    def error(self, message: object, exception: Optional[Exception] = None) -> None: ...

    def critical(self, message: object) -> None: ...


def config_logger(config: Optional[Dict[str, Any]] = None, name: str = 'ok-script') -> None: ...


def read_json_file(file_path: str) -> Optional[Dict[str, Any]]: ...


def write_json_file(file_path: str, data: Dict[str, Any]) -> bool: ...


def is_admin() -> bool: ...


def get_first_item(lst: Optional[List[Any]], default: Any = None) -> Any: ...


def safe_get(lst: List[Any], idx: int, default: Any = None) -> Any: ...


def find_index_in_list(my_list: List[Any], target_string: str, default_index: int = -1) -> int: ...


def get_path_relative_to_exe(*files: str) -> str: ...


def get_relative_path(*files: str) -> str: ...


def install_path_isascii() -> Tuple[bool, str]: ...


def resource_path(relative_path: str) -> str: ...


def ensure_dir_for_file(file_path: str) -> str: ...


def ensure_dir(directory: str, clear: bool = False) -> str: ...


def delete_if_exists(file_path: str) -> None: ...


def delete_folders_starts_with(path: str, starts_with: str) -> None: ...


def handle_remove_error(func: Callable, path: str, exc_info: Tuple) -> None: ...


def sanitize_filename(filename: str) -> str: ...


def clear_folder(folder_path: str) -> None: ...


def find_first_existing_file(filenames: List[str], directory: str) -> Optional[str]: ...


def get_path_in_package(base: str, file: str) -> str: ...


def dir_checksum(directory: str, excludes: Optional[List[str]] = None) -> str: ...


def find_folder_with_file(root_folder: str, target_file: str) -> Optional[str]: ...


def get_folder_size(folder_path: str) -> int: ...


def run_in_new_thread(func: Callable) -> threading.Thread: ...


def check_mutex() -> bool: ...


def all_pids() -> List[int]: ...


def ratio_text_to_number(supported_ratio: str) -> float: ...


def data_to_base64(data: Union[Dict, List[Dict]]) -> str: ...


def base64_to_data(base64_str: str) -> Union[Dict, List[Dict]]: ...


def get_readable_file_size(file_path: str) -> str: ...


def bytes_to_readable_size(size_bytes: int) -> str: ...


def execute(game_path: str) -> bool: ...


@dataclass(order=True)
class ScheduledTask:
    execute_at: float
    task: Callable = field(compare=False)


class Handler:
    def __init__(self, event: threading.Event, name: Optional[str] = None) -> None: ...

    def post(self, task: Callable, delay: float = 0, remove_existing: bool = False,
             skip_if_running: bool = False) -> bool: ...

    def stop(self) -> None: ...


def init_class_by_name(module_name: str, class_name: str, *args: Any, **kwargs: Any) -> Any: ...


class ExitEvent(threading.Event):
    queues: set
    to_stops: set

    def bind_queue(self, queue: queue.Queue) -> None: ...

    def bind_stop(self, to_stop: Any) -> None: ...

    def set(self) -> None: ...
