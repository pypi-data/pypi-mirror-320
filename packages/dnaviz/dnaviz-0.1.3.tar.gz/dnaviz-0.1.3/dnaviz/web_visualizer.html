<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNA/RNA Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f5f5f5;
        }
        
        #canvas-container {
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }
        
        canvas {
            border: 1px solid #ddd;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            padding: 10px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            flex-wrap: wrap;
        }

        .sequence-inputs {
            display: flex;
            gap: 10px;
            align-items: flex-start;
            flex-direction: column;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .sequence-input {
            display: flex;
            gap: 10px;
            align-items: center;
            width: 100%;
            justify-content: center;
        }

        .sequence-row {
            display: flex;
            gap: 10px;
            align-items: center;
            width: 100%;
            justify-content: center;
        }

        input[type="text"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            width: 300px;
        }

        select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background-color: #2ecc71;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        button:hover {
            background-color: #27ae60;
        }

        .remove-btn {
            background-color: #e74c3c;
        }

        .remove-btn:hover {
            background-color: #c0392b;
        }
        
        #scale-slider {
            width: 200px;
        }

        .error {
            color: #e74c3c;
            font-size: 14px;
            margin-top: 5px;
            text-align: center;
            width: 100%;
        }

        .sequence-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            width: 100%;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <div class="sequence-inputs" id="sequence-container">
            <!-- Sequence inputs will be added here dynamically -->
        </div>
        <div class="sequence-controls">
            <button id="add-sequence-btn">Add Sequence</button>
            <button id="update-btn">Update Sequences</button>
        </div>
        <div id="error-message" class="error"></div>
        <div class="controls-row">
            <button id="reset-btn">Reset Positions</button>
            <button id="save-btn">Save PNG</button>
            <input type="range" id="scale-slider" min="50" max="200" value="100">
            <span id="scale-value">100%</span>
        </div>
    </div>
    <div id="canvas-container">
        <canvas id="dna-canvas"></canvas>
    </div>

    <script>
        const COLORS = {
            background: '#f5f5f5',
            grid: '#e6e6e6',
            gridMajor: '#d2d2d2',
            unpaired: '#b4b4b4',
            paired: '#2ecc71',
            wrongDirection: '#e67e22',
            selection: '#3498db',
            backbone: '#2c3e50',
            hydrogenBonds: '#2ecc71',
            text: '#34495e',
            labelBackground: '#ffffff',
            labelBorder: '#34495e'
        };

        class Base {
            constructor(nucleotide, x, y, strand = 1, isFivePrime = true) {
                this.nucleotide = nucleotide;
                this.x = x;
                this.y = y;
                this.strand = strand;
                this.isFivePrime = isFivePrime;
                this.isPaired = false;
                this.isDragging = false;
                this.radius = 20;
                this.color = COLORS.unpaired;
                this.targetX = x;
                this.targetY = y;
            }

            isClicked(pos) {
                const dx = pos.x - this.x;
                const dy = pos.y - this.y;
                return (dx * dx + dy * dy) <= this.radius * this.radius;
            }

            updateColor(paired, correctDirection) {
                if (paired && correctDirection) {
                    this.color = COLORS.paired;
                } else if (paired) {
                    this.color = COLORS.wrongDirection;
                } else {
                    this.color = COLORS.unpaired;
                }
            }

            updatePosition(lerpFactor = 0.3) {
                if (this.isDragging) {
                    this.x = this.targetX;
                    this.y = this.targetY;
                } else {
                    this.x += (this.targetX - this.x) * lerpFactor;
                    this.y += (this.targetY - this.y) * lerpFactor;

                    if (Math.abs(this.targetX - this.x) < 0.1 && Math.abs(this.targetY - this.y) < 0.1) {
                        this.x = this.targetX;
                        this.y = this.targetY;
                    }
                }
            }
        }

        class DNAVisualizer {
            constructor(sequences, directions) {
                this.canvas = document.getElementById('dna-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();

                this.strands = [];
                this.initializeStrands(sequences, directions);
                
                this.scrollX = 0;
                this.scrollY = 0;
                this.baseScale = 1.0;
                this.selectedBases = [];
                this.originalPositions = this.saveOriginalPositions();
                this.gridSize = 50;

                this.setupEventListeners();
                this.animate();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth - 40;
                this.canvas.height = window.innerHeight - 120;
            }

            initializeStrands(sequences, directions) {
                const spacing = 100;
                sequences.forEach((seq, i) => {
                    const strand = [];
                    const isFivePrime = directions[i] === '53';
                    seq.split('').forEach((base, j) => {
                        const x = 200 + j * 50;
                        const y = 200 + i * spacing;
                        strand.push(new Base(base, x, y, i + 1, isFivePrime));
                    });
                    this.strands.push(strand);
                });
            }

            saveOriginalPositions() {
                const positions = [];
                this.strands.forEach(strand => {
                    strand.forEach(base => {
                        positions.push([base, { x: base.x, y: base.y }]);
                    });
                });
                return positions;
            }

            canPair(base1, base2) {
                if (base1.strand === base2.strand) return false;
                
                const pairs = {
                    'A': new Set(['T', 'U']),
                    'T': new Set(['A']),
                    'U': new Set(['A']),
                    'G': new Set(['C']),
                    'C': new Set(['G'])
                };

                return pairs[base1.nucleotide]?.has(base2.nucleotide) ||
                       pairs[base2.nucleotide]?.has(base1.nucleotide);
            }

            checkPairing() {
                // Reset pairing state
                this.strands.forEach(strand => {
                    strand.forEach(base => {
                        base.isPaired = false;
                        base.updateColor(false, false);
                    });
                });

                const pairedBases = new Set();

                this.strands.forEach((strand1, i) => {
                    strand1.forEach(base1 => {
                        if (pairedBases.has(base1)) return;

                        let closestBase = null;
                        let minDistance = Infinity;

                        this.strands.forEach((strand2, j) => {
                            if (i === j) return;

                            strand2.forEach(base2 => {
                                if (pairedBases.has(base2)) return;

                                if (this.canPair(base1, base2)) {
                                    const dx = Math.abs(base1.x - base2.x);
                                    if (dx < 50) {
                                        const dy = Math.abs(base1.y - base2.y);
                                        if (dy < 150) {
                                            const distance = Math.sqrt(dx * dx + dy * dy);
                                            if (distance < minDistance) {
                                                minDistance = distance;
                                                closestBase = base2;
                                            }
                                        }
                                    }
                                }
                            });
                        });

                        if (closestBase) {
                            base1.isPaired = true;
                            closestBase.isPaired = true;
                            pairedBases.add(base1);
                            pairedBases.add(closestBase);

                            const correctDirection = base1.isFivePrime !== closestBase.isFivePrime;
                            base1.updateColor(true, correctDirection);
                            closestBase.updateColor(true, correctDirection);
                        }
                    });
                });
            }

            draw() {
                this.ctx.fillStyle = COLORS.background;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw grid
                const gridSize = Math.floor(50 * this.baseScale);
                this.ctx.beginPath();
                for (let x = 0; x < this.canvas.width + gridSize; x += gridSize) {
                    const adjustedX = x - this.scrollX % gridSize;
                    const isMajor = x % (gridSize * 5) === 0;
                    this.ctx.strokeStyle = isMajor ? COLORS.gridMajor : COLORS.grid;
                    this.ctx.lineWidth = isMajor ? 2 : 1;
                    this.ctx.moveTo(adjustedX, 0);
                    this.ctx.lineTo(adjustedX, this.canvas.height);
                }
                for (let y = 0; y < this.canvas.height + gridSize; y += gridSize) {
                    const adjustedY = y - this.scrollY % gridSize;
                    const isMajor = y % (gridSize * 5) === 0;
                    this.ctx.strokeStyle = isMajor ? COLORS.gridMajor : COLORS.grid;
                    this.ctx.lineWidth = isMajor ? 2 : 1;
                    this.ctx.moveTo(0, adjustedY);
                    this.ctx.lineTo(this.canvas.width, adjustedY);
                }
                this.ctx.stroke();

                // Draw backbone lines
                this.strands.forEach(strand => {
                    if (strand.length > 1) {
                        this.ctx.beginPath();
                        this.ctx.strokeStyle = COLORS.backbone;
                        this.ctx.lineWidth = 2;
                        this.ctx.moveTo(strand[0].x - this.scrollX, strand[0].y - this.scrollY);
                        strand.slice(1).forEach(base => {
                            this.ctx.lineTo(base.x - this.scrollX, base.y - this.scrollY);
                        });
                        this.ctx.stroke();
                    }
                });

                // Draw hydrogen bonds
                this.strands.forEach(strand1 => {
                    strand1.forEach(base1 => {
                        if (base1.isPaired) {
                            this.strands.forEach(strand2 => {
                                if (strand2 !== strand1) {
                                    strand2.forEach(base2 => {
                                        if (base2.isPaired && this.canPair(base1, base2)) {
                                            const dx = Math.abs(base1.x - base2.x);
                                            if (dx < 50) {
                                                const dy = Math.abs(base1.y - base2.y);
                                                if (dy < 150) {
                                                    this.ctx.beginPath();
                                                    this.ctx.strokeStyle = COLORS.hydrogenBonds;
                                                    this.ctx.lineWidth = 2;
                                                    this.ctx.moveTo(base1.x - this.scrollX, base1.y - this.scrollY);
                                                    this.ctx.lineTo(base2.x - this.scrollX, base2.y - this.scrollY);
                                                    this.ctx.stroke();
                                                }
                                            }
                                        }
                                    });
                                }
                            });
                        }
                    });
                });

                // Draw bases
                this.strands.forEach(strand => {
                    strand.forEach((base, i) => {
                        const screenX = base.x - this.scrollX;
                        const screenY = base.y - this.scrollY;

                        base.updatePosition();

                        // Draw selection highlight
                        if (this.selectedBases.includes(base)) {
                            this.ctx.beginPath();
                            this.ctx.fillStyle = COLORS.selection;
                            this.ctx.arc(screenX, screenY, base.radius + 4, 0, Math.PI * 2);
                            this.ctx.fill();
                        }

                        // Draw base circle
                        this.ctx.beginPath();
                        this.ctx.fillStyle = base.color;
                        this.ctx.arc(screenX, screenY, base.radius, 0, Math.PI * 2);
                        this.ctx.fill();

                        // Draw base letter
                        this.ctx.font = '24px sans-serif';
                        this.ctx.fillStyle = COLORS.text;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(base.nucleotide, screenX, screenY);

                        // Draw direction labels
                        if (i === 0 || i === strand.length - 1) {
                            const isFive = (i === 0 && base.isFivePrime) || 
                                         (i === strand.length - 1 && !base.isFivePrime);
                            const label = isFive ? "5'" : "3'";
                            this.ctx.font = '16px sans-serif';
                            this.ctx.fillText(label, screenX, screenY - base.radius - 15);
                        }
                    });
                });
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                window.addEventListener('keydown', this.handleKeyDown.bind(this));
                window.addEventListener('resize', this.handleResize.bind(this));

                document.getElementById('reset-btn').addEventListener('click', () => this.resetPositions());
                document.getElementById('save-btn').addEventListener('click', () => this.savePNG());
                document.getElementById('scale-slider').addEventListener('input', (e) => {
                    this.baseScale = e.target.value / 100;
                    document.getElementById('scale-value').textContent = `${e.target.value}%`;
                });
            }

            handleMouseDown(event) {
                const rect = this.canvas.getBoundingClientRect();
                const mouseX = event.clientX - rect.left;
                const mouseY = event.clientY - rect.top;
                const worldPos = {
                    x: mouseX + this.scrollX,
                    y: mouseY + this.scrollY
                };

                let clickedBase = null;
                this.strands.forEach(strand => {
                    strand.forEach(base => {
                        if (base.isClicked(worldPos)) {
                            clickedBase = base;
                        }
                    });
                });

                if (clickedBase) {
                    if (event.shiftKey) {
                        if (!this.selectedBases.includes(clickedBase)) {
                            this.selectedBases.push(clickedBase);
                        }
                    } else {
                        this.selectedBases = [clickedBase];
                    }
                    clickedBase.isDragging = true;
                    this.dragStart = { x: mouseX, y: mouseY };
                } else {
                    if (!event.shiftKey) {
                        this.selectedBases = [];
                    }
                }
            }

            handleMouseMove(event) {
                if (this.selectedBases.some(base => base.isDragging)) {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = event.clientX - rect.left;
                    const mouseY = event.clientY - rect.top;
                    const dx = mouseX - this.dragStart.x;
                    const dy = mouseY - this.dragStart.y;

                    this.selectedBases.forEach(base => {
                        base.x += dx;
                        base.y += dy;
                        base.targetX = base.x;
                        base.targetY = base.y;
                    });

                    this.dragStart = { x: mouseX, y: mouseY };
                    this.checkPairing();
                }
            }

            handleMouseUp() {
                if (this.selectedBases.some(base => base.isDragging)) {
                    this.selectedBases.forEach(base => {
                        base.isDragging = false;
                        if (!event.ctrlKey && !event.metaKey) {
                            const gridSize = Math.floor(50 * this.baseScale);
                            base.targetX = Math.round(base.x / gridSize) * gridSize;
                            base.targetY = Math.round(base.y / gridSize) * gridSize;
                        }
                    });
                }
            }

            handleKeyDown(event) {
                const scrollAmount = 50;
                switch (event.key) {
                    case 'ArrowLeft':
                        this.scrollX = Math.max(0, this.scrollX - scrollAmount);
                        break;
                    case 'ArrowRight':
                        this.scrollX += scrollAmount;
                        break;
                    case 'ArrowUp':
                        this.scrollY = Math.max(0, this.scrollY - scrollAmount);
                        break;
                    case 'ArrowDown':
                        this.scrollY += scrollAmount;
                        break;
                    case 'r':
                        this.resetPositions();
                        break;
                }
            }

            handleResize() {
                this.resizeCanvas();
            }

            resetPositions() {
                if (this.selectedBases.length === 0) return;

                const selectedStrands = new Set();
                this.selectedBases.forEach(base => {
                    this.strands.forEach(strand => {
                        if (strand.includes(base)) {
                            selectedStrands.add(strand);
                        }
                    });
                });

                selectedStrands.forEach(strand => {
                    strand.forEach(base => {
                        const originalPos = this.originalPositions.find(([b]) => b === base);
                        if (originalPos) {
                            base.targetX = originalPos[1].x;
                            base.targetY = originalPos[1].y;
                        }
                    });
                });
            }

            savePNG() {
                const link = document.createElement('a');
                link.download = `dna_viz_${new Date().toISOString().slice(0,19).replace(/[-:]/g, '')}.png`;
                link.href = this.canvas.toDataURL();
                link.click();
            }

            animate() {
                this.draw();
                requestAnimationFrame(this.animate.bind(this));
            }

            updateScale(scale) {
                const oldScale = this.baseScale;
                this.baseScale = scale;
                
                // Update base radius and positions based on scale change
                const scaleRatio = this.baseScale / oldScale;
                
                this.strands.forEach(strand => {
                    strand.forEach(base => {
                        // Scale positions relative to canvas center
                        const centerX = this.canvas.width / 2;
                        const centerY = this.canvas.height / 2;
                        
                        base.x = centerX + (base.x - centerX) * scaleRatio;
                        base.y = centerY + (base.y - centerY) * scaleRatio;
                        
                        // Snap to grid
                        const gridSize = Math.floor(50 * this.baseScale);
                        base.x = Math.round(base.x / gridSize) * gridSize;
                        base.y = Math.round(base.y / gridSize) * gridSize;
                        
                        base.targetX = base.x;
                        base.targetY = base.y;
                        base.radius = Math.floor(20 * this.baseScale);
                    });
                });
                
                // Update grid size
                this.gridSize = Math.floor(50 * this.baseScale);
            }
        }

        // Sequence management
        class SequenceManager {
            constructor() {
                this.container = document.getElementById('sequence-container');
                this.sequences = [
                    { seq: 'ATCG', dir: '53' },
                    { seq: 'TAGC', dir: '35' }
                ];
                this.render();
                this.setupEventListeners();
            }

            createSequenceRow(index, sequence) {
                const row = document.createElement('div');
                row.className = 'sequence-row';
                row.innerHTML = `
                    <input type="text" class="sequence-input" placeholder="Enter sequence (e.g., ATCG)" 
                           value="${sequence.seq}" data-index="${index}">
                    <select class="direction-select" data-index="${index}">
                        <option value="53" ${sequence.dir === '53' ? 'selected' : ''}>5' → 3'</option>
                        <option value="35" ${sequence.dir === '35' ? 'selected' : ''}>3' → 5'</option>
                    </select>
                    ${index > 1 ? '<button class="remove-btn">Remove</button>' : ''}
                `;

                if (index > 1) {
                    row.querySelector('.remove-btn').addEventListener('click', () => {
                        this.removeSequence(index);
                    });
                }

                return row;
            }

            render() {
                this.container.innerHTML = '';
                this.sequences.forEach((seq, index) => {
                    this.container.appendChild(this.createSequenceRow(index, seq));
                });
            }

            addSequence() {
                this.sequences.push({ seq: 'ATCG', dir: '53' });
                this.render();
            }

            removeSequence(index) {
                this.sequences.splice(index, 1);
                this.render();
            }

            getSequences() {
                return {
                    sequences: this.sequences.map(s => s.seq),
                    directions: this.sequences.map(s => s.dir)
                };
            }

            updateFromInputs() {
                const inputs = document.querySelectorAll('.sequence-input');
                const selects = document.querySelectorAll('.direction-select');
                
                this.sequences = Array.from(inputs).map((input, i) => ({
                    seq: input.value.toUpperCase(),
                    dir: selects[i].value
                }));
            }

            setupEventListeners() {
                document.getElementById('add-sequence-btn').addEventListener('click', () => {
                    this.addSequence();
                });
            }
        }

        // Initialize
        const sequenceManager = new SequenceManager();
        let visualizer = new DNAVisualizer(
            sequenceManager.getSequences().sequences,
            sequenceManager.getSequences().directions
        );

        // Update event listeners
        function validateSequence(sequence) {
            return /^[ATCGU]+$/.test(sequence);
        }

        function updateVisualization() {
            sequenceManager.updateFromInputs();
            const { sequences, directions } = sequenceManager.getSequences();
            const errorElement = document.getElementById('error-message');

            if (sequences.some(seq => !validateSequence(seq))) {
                errorElement.textContent = 'Invalid sequence. Use only A, T, C, G, or U.';
                return;
            }

            errorElement.textContent = '';
            visualizer = new DNAVisualizer(sequences, directions);
        }

        document.getElementById('update-btn').addEventListener('click', updateVisualization);
        document.getElementById('scale-slider').addEventListener('input', (e) => {
            const scale = e.target.value / 100;
            document.getElementById('scale-value').textContent = `${e.target.value}%`;
            visualizer.updateScale(scale);
        });
    </script>
</body>
</html> 