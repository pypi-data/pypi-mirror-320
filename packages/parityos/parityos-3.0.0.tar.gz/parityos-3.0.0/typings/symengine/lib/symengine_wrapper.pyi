"""
This type stub file was generated by pyright.
"""

from __future__ import annotations

from typing import Callable, ClassVar, Union

from _typeshed import Incomplete
from symengine.utilities import is_sequence as is_sequence
from typing_extensions import Self, TypeAlias, override

PyNumber: TypeAlias = Union[int, float, complex]
ParseType: TypeAlias = Union[str, bool, PyNumber, Basic]

def sympify(a: ParseType | tuple[ParseType] | list[ParseType]) -> Expr: ...

class Abs(OneArgFunction):
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    @override
    def func(self): ...  # pyright: ignore[reportIncompatibleMethodOverride]
    @property
    @override
    def is_negative(self) -> bool: ...  # pyright: ignore[reportIncompatibleVariableOverride]
    @property
    @override
    def is_real(self) -> bool: ...  # pyright: ignore[reportIncompatibleVariableOverride]

class Add(AssocOp):
    identity: ClassVar[int] = ...
    def __init__(self, *args, **kwargs) -> None: ...
    @override
    def as_coefficients_dict(self, *args, **kwargs): ...
    @property
    def func(self): ...
    @property
    @override
    def is_Add(self) -> bool: ...  # pyright: ignore[reportIncompatibleVariableOverride]

class AssocOp(Expr):
    make_args: ClassVar[Callable[[Expr], tuple[Expr]]] = ...

class Basic:
    args: tuple[Expr, ...]
    free_symbols: set[Symbol]
    is_Add: bool
    is_AlgebraicNumber: bool
    is_Atom: bool
    is_Boolean: bool
    is_Derivative: bool
    is_Dummy: bool
    is_Equality: bool
    is_Float: bool
    is_Function: bool
    is_Integer: bool
    is_Matrix: bool
    is_Mul: bool
    is_Not: bool
    is_Number: bool
    is_Pow: bool
    is_Rational: bool
    is_Relational: bool
    is_Symbol: bool
    is_finite: bool
    is_integer: bool
    is_negative: bool
    is_nonnegative: bool
    is_nonpositive: bool
    is_number: bool
    is_positive: bool
    is_real: bool
    is_symbol: bool
    is_zero: bool
    def args_as_sage(self): ...
    def args_as_sympy(self): ...
    def as_coefficients_dict(self): ...
    def as_numer_denom(self, *args, **kwargs): ...
    def as_powers_dict(self, *args, **kwargs): ...
    def as_real_imag(self, *args, **kwargs): ...
    def atoms(self) -> set[Symbol]: ...
    def coeff(self, x: Symbol, n: int = ...) -> float: ...
    def copy(self) -> Self: ...
    def diff(self, *args, **kwargs): ...
    def evalf(self, *args, **kwargs): ...
    def expand(self, *args, **kwargs): ...
    def has(self, *args, **kwargs): ...
    def msubs(self, *args, **kwargs): ...
    def n(self, *args, **kwargs): ...
    def replace(self, *args, **kwargs): ...
    def simplify(self, *args, **kwargs): ...
    def subs(self, *args, **kwargs): ...
    def subs_dict(self, *args, **kwargs): ...
    def subs_oldnew(self, *args, **kwargs): ...
    def xreplace(self, *args, **kwargs): ...
    def __abs__(self) -> Abs: ...
    def __add__(self, other: Basic | PyNumber) -> Add: ...
    def __complex__(self) -> Complex: ...
    def __divmod__(self, other: Basic | PyNumber) -> tuple[floor, Add]: ...
    @override
    def __eq__(self, other: object) -> bool: ...
    def __float__(self) -> float: ...
    def __floordiv__(self, other: Basic | PyNumber) -> floor: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    @override
    def __hash__(self) -> int: ...
    def __int__(self) -> int: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __mod__(self, other: Basic | PyNumber) -> Add: ...
    def __mul__(self, other: Basic | PyNumber) -> Mul: ...
    @override
    def __ne__(self, other: object) -> bool: ...
    def __neg__(self) -> Mul: ...
    def __pos__(self) -> Self: ...
    def __pow__(self, other: Basic | PyNumber) -> Pow: ...
    def __radd__(self, other: Basic | PyNumber) -> Add: ...
    def __rdivmod__(self, other: Basic | PyNumber) -> tuple[floor, Add]: ...
    @override
    def __reduce__(self): ...
    def __rfloordiv__(self, other: Basic) -> floor: ...
    def __rmod__(self, other: Basic | PyNumber) -> Add: ...
    def __rmul__(self, other: Basic | PyNumber) -> Mul: ...
    def __rpow__(self, other: Basic | PyNumber) -> Pow: ...
    def __rsub__(self, other: Basic | PyNumber) -> Add: ...
    def __rtruediv__(self, other: Basic | PyNumber) -> Mul: ...
    def __sub__(self, other: Basic | PyNumber) -> Add: ...
    def __truediv__(self, other: Basic | PyNumber) -> Mul: ...

class Complex(ComplexBase):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...

class ComplexBase(Number):
    imag: Incomplete
    real: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def imaginary_part(self, *args, **kwargs): ...
    def real_part(self, *args, **kwargs): ...

class Expr(Basic):
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...

class Function(Expr):
    def func(self, *args, **kwargs): ...
    @property
    @override
    def is_Function(self): ...  # pyright: ignore[reportIncompatibleVariableOverride]

class Mul(AssocOp):
    identity: ClassVar[int]
    def __init__(self, *args, **kwargs) -> None: ...
    @override
    def as_coefficients_dict(self, *args, **kwargs): ...
    @override
    def as_powers_dict(self, *args, **kwargs): ...
    @property
    def func(self): ...
    @property
    @override
    def is_Mul(self): ...  # pyright: ignore[reportIncompatibleVariableOverride]

class Number(Expr):
    imag: Expr
    is_Atom: bool
    is_Number: bool
    is_commutative: bool
    is_complex: bool
    is_negative: bool
    is_nonnegative: bool
    is_nonpositive: bool
    is_nonzero: bool
    is_number: bool
    is_positive: bool
    real: Expr

class OneArgFunction(Function):
    def get_arg(self): ...

class Pow(Expr):
    def __init__(self, *args, **kwargs) -> None: ...
    def as_base_exp(self, *args, **kwargs): ...
    @override
    def as_powers_dict(self, *args, **kwargs): ...
    @property
    def base(self): ...
    @property
    def exp(self): ...
    @property
    def func(self): ...
    @property
    @override
    def is_Pow(self): ...  # pyright: ignore[reportIncompatibleVariableOverride]
    @property
    def is_commutative(self): ...

class Symbol(Expr):
    func: type[Symbol]
    is_Atom: bool
    is_Symbol: bool
    is_commutative: bool
    is_symbol: bool
    name: str
    def __init__(self, name: str, *, store_pickle: bool = False) -> None: ...
    @override
    def __reduce__(self): ...

class floor(OneArgFunction):
    def __init__(self, *args, **kwargs) -> None: ...
