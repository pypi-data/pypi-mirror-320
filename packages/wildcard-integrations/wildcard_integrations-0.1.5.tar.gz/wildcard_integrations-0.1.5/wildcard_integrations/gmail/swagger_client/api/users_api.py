# coding: utf-8

"""
    Gmail API

    The Gmail API lets you view and manage Gmail mailbox data like threads, messages, and labels.  # noqa: E501

    OpenAPI spec version: v1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from ..api_client import ApiClient


class UsersApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def gmail_users_drafts_create(self, user_id, **kwargs):  # noqa: E501
        """Create a new email draft  # noqa: E501

        Create a new email draft in the user's Gmail account. This draft is labeled as 'DRAFT' and can be edited or sent later. It allows users to save a message they are composing without sending it immediately.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_drafts_create(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param Draft body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Draft
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_drafts_create_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_drafts_create_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_drafts_create_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Create a new email draft  # noqa: E501

        Create a new email draft in the user's Gmail account. This draft is labeled as 'DRAFT' and can be edited or sent later. It allows users to save a message they are composing without sending it immediately.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_drafts_create_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param Draft body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Draft
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_drafts_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_drafts_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['message/cpim', 'message/delivery-status', 'message/disposition-notification', 'message/external-body', 'message/feedback-report', 'message/global', 'message/global-delivery-status', 'message/global-disposition-notification', 'message/global-headers', 'message/http', 'message/imdn+xml', 'message/news', 'message/partial', 'message/rfc822', 'message/s-http', 'message/sip', 'message/sipfrag', 'message/tracking-status', 'message/vnd.si.simp', 'message/vnd.wfa.wsc'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/drafts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Draft',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_drafts_delete(self, user_id, id, **kwargs):  # noqa: E501
        """Delete a specific email draft  # noqa: E501

        Permanently delete a specific email draft from the user's Gmail account. This action cannot be undone and removes the draft entirely, rather than moving it to the trash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_drafts_delete(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the draft to delete. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_drafts_delete_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_drafts_delete_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_drafts_delete_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Delete a specific email draft  # noqa: E501

        Permanently delete a specific email draft from the user's Gmail account. This action cannot be undone and removes the draft entirely, rather than moving it to the trash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_drafts_delete_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the draft to delete. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_drafts_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_drafts_delete`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_drafts_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/drafts/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_drafts_get(self, user_id, id, **kwargs):  # noqa: E501
        """Get details of a draft  # noqa: E501

        Retrieve the details of a specific email draft by its ID. This allows you to view the content and metadata of the draft, such as subject and recipients.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_drafts_get(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the draft to retrieve. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param str format: The format to return the draft in.
        :return: Draft
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_drafts_get_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_drafts_get_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_drafts_get_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Get details of a draft  # noqa: E501

        Retrieve the details of a specific email draft by its ID. This allows you to view the content and metadata of the draft, such as subject and recipients.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_drafts_get_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the draft to retrieve. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param str format: The format to return the draft in.
        :return: Draft
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type', 'format']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_drafts_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_drafts_get`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_drafts_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/drafts/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Draft',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_drafts_list(self, user_id, **kwargs):  # noqa: E501
        """List user's email drafts  # noqa: E501

        Retrieve a list of all email drafts in the user's Gmail account. This endpoint allows you to access drafts that are saved but not yet sent, providing an overview of unsent messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_drafts_list(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param bool include_spam_trash: Include drafts from `SPAM` and `TRASH` in the results.
        :param int max_results: Maximum number of drafts to return. This field defaults to 100. The maximum allowed value for this field is 500.
        :param str page_token: Page token to retrieve a specific page of results in the list.
        :param str q: Only return draft messages matching the specified query. Supports the same query format as the Gmail search box. For example, `\"from:someuser@example.com rfc822msgid: is:unread\"`.
        :return: ListDraftsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_drafts_list_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_drafts_list_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_drafts_list_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List user's email drafts  # noqa: E501

        Retrieve a list of all email drafts in the user's Gmail account. This endpoint allows you to access drafts that are saved but not yet sent, providing an overview of unsent messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_drafts_list_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param bool include_spam_trash: Include drafts from `SPAM` and `TRASH` in the results.
        :param int max_results: Maximum number of drafts to return. This field defaults to 100. The maximum allowed value for this field is 500.
        :param str page_token: Page token to retrieve a specific page of results in the list.
        :param str q: Only return draft messages matching the specified query. Supports the same query format as the Gmail search box. For example, `\"from:someuser@example.com rfc822msgid: is:unread\"`.
        :return: ListDraftsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type', 'include_spam_trash', 'max_results', 'page_token', 'q']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_drafts_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_drafts_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501
        if 'include_spam_trash' in params:
            query_params.append(('includeSpamTrash', params['include_spam_trash']))  # noqa: E501
        if 'max_results' in params:
            query_params.append(('maxResults', params['max_results']))  # noqa: E501
        if 'page_token' in params:
            query_params.append(('pageToken', params['page_token']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/drafts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListDraftsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_drafts_send(self, user_id, **kwargs):  # noqa: E501
        """Send an existing draft email  # noqa: E501

        Send an existing draft email to the specified recipients. This endpoint finalizes the draft and delivers it to the email addresses listed in the 'To', 'Cc', and 'Bcc' fields.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_drafts_send(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param Draft body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: DraftMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_drafts_send_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_drafts_send_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_drafts_send_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Send an existing draft email  # noqa: E501

        Send an existing draft email to the specified recipients. This endpoint finalizes the draft and delivers it to the email addresses listed in the 'To', 'Cc', and 'Bcc' fields.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_drafts_send_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param Draft body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: DraftMessage
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_drafts_send" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_drafts_send`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['message/cpim', 'message/delivery-status', 'message/disposition-notification', 'message/external-body', 'message/feedback-report', 'message/global', 'message/global-delivery-status', 'message/global-disposition-notification', 'message/global-headers', 'message/http', 'message/imdn+xml', 'message/news', 'message/partial', 'message/rfc822', 'message/s-http', 'message/sip', 'message/sipfrag', 'message/tracking-status', 'message/vnd.si.simp', 'message/vnd.wfa.wsc'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/drafts/send', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DraftMessage',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_drafts_update(self, user_id, id, **kwargs):  # noqa: E501
        """Update an email draft  # noqa: E501

        Update the content of an existing email draft. This endpoint replaces the current draft content with new information, allowing for modifications before sending.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_drafts_update(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the draft to update. (required)
        :param Draft body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Draft
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_drafts_update_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_drafts_update_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_drafts_update_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Update an email draft  # noqa: E501

        Update the content of an existing email draft. This endpoint replaces the current draft content with new information, allowing for modifications before sending.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_drafts_update_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the draft to update. (required)
        :param Draft body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Draft
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_drafts_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_drafts_update`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_drafts_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['message/cpim', 'message/delivery-status', 'message/disposition-notification', 'message/external-body', 'message/feedback-report', 'message/global', 'message/global-delivery-status', 'message/global-disposition-notification', 'message/global-headers', 'message/http', 'message/imdn+xml', 'message/news', 'message/partial', 'message/rfc822', 'message/s-http', 'message/sip', 'message/sipfrag', 'message/tracking-status', 'message/vnd.si.simp', 'message/vnd.wfa.wsc'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/drafts/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Draft',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_get_profile(self, user_id, **kwargs):  # noqa: E501
        """Get user's Gmail profile  # noqa: E501

        Retrieve the Gmail profile information of the current user. This includes basic account details such as email address and message count.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_get_profile(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_get_profile_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_get_profile_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_get_profile_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get user's Gmail profile  # noqa: E501

        Retrieve the Gmail profile information of the current user. This includes basic account details such as email address and message count.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_get_profile_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Profile
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_get_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_get_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/profile', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Profile',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_history_list(self, user_id, start_history_id, **kwargs):  # noqa: E501
        """List mailbox change history  # noqa: E501

        Retrieve a chronological list of changes made to the user's Gmail account. This includes modifications to messages, labels, and other mailbox activities, providing a history of actions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_history_list(user_id, start_history_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str start_history_id: Required. Returns history records after the specified `startHistoryId`. The supplied `startHistoryId` should be obtained from the `historyId` of a message, thread, or previous `list` response. History IDs increase chronologically but are not contiguous with random gaps in between valid IDs. Supplying an invalid or out of date `startHistoryId` typically returns an `HTTP 404` error code. A `historyId` is typically valid for at least a week, but in some rare circumstances may be valid for only a few hours. If you receive an `HTTP 404` error response, your application should perform a full sync. If you receive no `nextPageToken` in the response, there are no updates to retrieve and you can store the returned `historyId` for a future request. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param list[str] history_types: History types to be returned by the function
        :param str label_id: Only return messages with a label matching the ID.
        :param int max_results: Maximum number of history records to return. This field defaults to 100. The maximum allowed value for this field is 500.
        :param str page_token: Page token to retrieve a specific page of results in the list.
        :return: ListHistoryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_history_list_with_http_info(user_id, start_history_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_history_list_with_http_info(user_id, start_history_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_history_list_with_http_info(self, user_id, start_history_id, **kwargs):  # noqa: E501
        """List mailbox change history  # noqa: E501

        Retrieve a chronological list of changes made to the user's Gmail account. This includes modifications to messages, labels, and other mailbox activities, providing a history of actions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_history_list_with_http_info(user_id, start_history_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str start_history_id: Required. Returns history records after the specified `startHistoryId`. The supplied `startHistoryId` should be obtained from the `historyId` of a message, thread, or previous `list` response. History IDs increase chronologically but are not contiguous with random gaps in between valid IDs. Supplying an invalid or out of date `startHistoryId` typically returns an `HTTP 404` error code. A `historyId` is typically valid for at least a week, but in some rare circumstances may be valid for only a few hours. If you receive an `HTTP 404` error response, your application should perform a full sync. If you receive no `nextPageToken` in the response, there are no updates to retrieve and you can store the returned `historyId` for a future request. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param list[str] history_types: History types to be returned by the function
        :param str label_id: Only return messages with a label matching the ID.
        :param int max_results: Maximum number of history records to return. This field defaults to 100. The maximum allowed value for this field is 500.
        :param str page_token: Page token to retrieve a specific page of results in the list.
        :return: ListHistoryResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'start_history_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type', 'history_types', 'label_id', 'max_results', 'page_token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_history_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_history_list`")  # noqa: E501
        # verify the required parameter 'start_history_id' is set
        if ('start_history_id' not in params or
                params['start_history_id'] is None):
            raise ValueError("Missing the required parameter `start_history_id` when calling `gmail_users_history_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501
        if 'history_types' in params:
            query_params.append(('historyTypes', params['history_types']))  # noqa: E501
            collection_formats['historyTypes'] = 'multi'  # noqa: E501
        if 'label_id' in params:
            query_params.append(('labelId', params['label_id']))  # noqa: E501
        if 'max_results' in params:
            query_params.append(('maxResults', params['max_results']))  # noqa: E501
        if 'page_token' in params:
            query_params.append(('pageToken', params['page_token']))  # noqa: E501
        if 'start_history_id' in params:
            query_params.append(('startHistoryId', params['start_history_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/history', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListHistoryResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_labels_create(self, user_id, **kwargs):  # noqa: E501
        """Create a new email label  # noqa: E501

        Create a new label in the user's Gmail account. Labels are used to categorize and organize emails, making it easier to manage and find messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_labels_create(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param Label body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_labels_create_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_labels_create_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_labels_create_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Create a new email label  # noqa: E501

        Create a new label in the user's Gmail account. Labels are used to categorize and organize emails, making it easier to manage and find messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_labels_create_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param Label body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_labels_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_labels_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/labels', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Label',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_labels_delete(self, user_id, id, **kwargs):  # noqa: E501
        """Delete a specific email label  # noqa: E501

        Permanently delete a specific label from the user's Gmail account. This action removes the label from all messages and threads it was applied to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_labels_delete(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the label to delete. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_labels_delete_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_labels_delete_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_labels_delete_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Delete a specific email label  # noqa: E501

        Permanently delete a specific label from the user's Gmail account. This action removes the label from all messages and threads it was applied to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_labels_delete_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the label to delete. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_labels_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_labels_delete`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_labels_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/labels/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_labels_get(self, user_id, id, **kwargs):  # noqa: E501
        """Get details of a label  # noqa: E501

        Retrieve the details of a specific label by its ID. This includes information such as the label's name and its associated settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_labels_get(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the label to retrieve. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_labels_get_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_labels_get_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_labels_get_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Get details of a label  # noqa: E501

        Retrieve the details of a specific label by its ID. This includes information such as the label's name and its associated settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_labels_get_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the label to retrieve. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_labels_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_labels_get`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_labels_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/labels/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Label',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_labels_list(self, user_id, **kwargs):  # noqa: E501
        """List all email labels  # noqa: E501

        Retrieve all labels associated with the user's Gmail account. Labels help organize emails and can be used to categorize messages for easier management.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_labels_list(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ListLabelsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_labels_list_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_labels_list_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_labels_list_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List all email labels  # noqa: E501

        Retrieve all labels associated with the user's Gmail account. Labels help organize emails and can be used to categorize messages for easier management.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_labels_list_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ListLabelsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_labels_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_labels_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/labels', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListLabelsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_labels_patch(self, user_id, id, **kwargs):  # noqa: E501
        """Partially update a label  # noqa: E501

        Partially update the settings of a specific label. This allows for modifications to certain properties of the label without replacing it entirely.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_labels_patch(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the label to update. (required)
        :param Label body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_labels_patch_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_labels_patch_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_labels_patch_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Partially update a label  # noqa: E501

        Partially update the settings of a specific label. This allows for modifications to certain properties of the label without replacing it entirely.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_labels_patch_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the label to update. (required)
        :param Label body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_labels_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_labels_patch`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_labels_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/labels/{id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Label',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_labels_update(self, user_id, id, **kwargs):  # noqa: E501
        """Update a specific label  # noqa: E501

        Update the settings of a specific label. This endpoint replaces the current label settings with new information, allowing for comprehensive modifications.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_labels_update(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the label to update. (required)
        :param Label body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_labels_update_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_labels_update_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_labels_update_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Update a specific label  # noqa: E501

        Update the settings of a specific label. This endpoint replaces the current label settings with new information, allowing for comprehensive modifications.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_labels_update_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the label to update. (required)
        :param Label body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Label
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_labels_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_labels_update`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_labels_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/labels/{id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Label',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_messages_attachments_get(self, user_id, message_id, id, **kwargs):  # noqa: E501
        """Get a message attachment  # noqa: E501

        Retrieve a specific attachment from an email message by its ID. This allows you to access and download attachments associated with a message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_attachments_get(user_id, message_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str message_id: The ID of the message containing the attachment. (required)
        :param str id: The ID of the attachment. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: MessagePartBody
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_messages_attachments_get_with_http_info(user_id, message_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_messages_attachments_get_with_http_info(user_id, message_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_messages_attachments_get_with_http_info(self, user_id, message_id, id, **kwargs):  # noqa: E501
        """Get a message attachment  # noqa: E501

        Retrieve a specific attachment from an email message by its ID. This allows you to access and download attachments associated with a message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_attachments_get_with_http_info(user_id, message_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str message_id: The ID of the message containing the attachment. (required)
        :param str id: The ID of the attachment. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: MessagePartBody
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'message_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_messages_attachments_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_messages_attachments_get`")  # noqa: E501
        # verify the required parameter 'message_id' is set
        if ('message_id' not in params or
                params['message_id'] is None):
            raise ValueError("Missing the required parameter `message_id` when calling `gmail_users_messages_attachments_get`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_messages_attachments_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'message_id' in params:
            path_params['messageId'] = params['message_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/messages/{messageId}/attachments/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='MessagePartBody',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_messages_batch_delete(self, user_id, **kwargs):  # noqa: E501
        """Batch delete email messages  # noqa: E501

        Delete multiple messages from the user's Gmail account using their message IDs. This operation does not confirm if the messages existed or were already deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_batch_delete(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param BatchDeleteMessagesRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_messages_batch_delete_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_messages_batch_delete_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_messages_batch_delete_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Batch delete email messages  # noqa: E501

        Delete multiple messages from the user's Gmail account using their message IDs. This operation does not confirm if the messages existed or were already deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_batch_delete_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param BatchDeleteMessagesRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_messages_batch_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_messages_batch_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/messages/batchDelete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_messages_batch_modify(self, user_id, **kwargs):  # noqa: E501
        """Batch modify message labels  # noqa: E501

        Modify the labels of multiple messages in the user's Gmail account. This allows for bulk updating of message categories and organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_batch_modify(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param BatchModifyMessagesRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_messages_batch_modify_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_messages_batch_modify_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_messages_batch_modify_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Batch modify message labels  # noqa: E501

        Modify the labels of multiple messages in the user's Gmail account. This allows for bulk updating of message categories and organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_batch_modify_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param BatchModifyMessagesRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_messages_batch_modify" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_messages_batch_modify`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/messages/batchModify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_messages_delete(self, user_id, id, **kwargs):  # noqa: E501
        """Delete a specific email message  # noqa: E501

        Permanently delete a specific email message from the user's Gmail account. This action cannot be undone and is different from moving a message to the trash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_delete(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the message to delete. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_messages_delete_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_messages_delete_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_messages_delete_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Delete a specific email message  # noqa: E501

        Permanently delete a specific email message from the user's Gmail account. This action cannot be undone and is different from moving a message to the trash.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_delete_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the message to delete. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_messages_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_messages_delete`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_messages_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/messages/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_messages_get(self, user_id, id, **kwargs):  # noqa: E501
        """Get details of a message  # noqa: E501

        Retrieve the details of a specific email message by its ID. This includes the message's content, headers, and metadata.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_get(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the message to retrieve. This ID is usually retrieved using `messages.list`. The ID is also contained in the result when a message is inserted (`messages.insert`) or imported (`messages.import`). (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param str format: The format to return the message in.
        :param list[str] metadata_headers: When given and format is `METADATA`, only include headers specified.
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_messages_get_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_messages_get_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_messages_get_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Get details of a message  # noqa: E501

        Retrieve the details of a specific email message by its ID. This includes the message's content, headers, and metadata.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_get_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the message to retrieve. This ID is usually retrieved using `messages.list`. The ID is also contained in the result when a message is inserted (`messages.insert`) or imported (`messages.import`). (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param str format: The format to return the message in.
        :param list[str] metadata_headers: When given and format is `METADATA`, only include headers specified.
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type', 'format', 'metadata_headers']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_messages_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_messages_get`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_messages_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'metadata_headers' in params:
            query_params.append(('metadataHeaders', params['metadata_headers']))  # noqa: E501
            collection_formats['metadataHeaders'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/messages/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Message',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_messages_import(self, user_id, **kwargs):  # noqa: E501
        """Import a message into mailbox  # noqa: E501

        Import a message into the user's Gmail account with standard email scanning and classification. This method simulates receiving an email via SMTP but does not send the message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_import(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param Message body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param bool deleted: Mark the email as permanently deleted (not TRASH) and only visible in Google Vault to a Vault administrator. Only used for Google Workspace accounts.
        :param str internal_date_source: Source for Gmail's internal date of the message.
        :param bool never_mark_spam: Ignore the Gmail spam classifier decision and never mark this email as SPAM in the mailbox.
        :param bool process_for_calendar: Process calendar invites in the email and add any extracted meetings to the Google Calendar for this user.
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_messages_import_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_messages_import_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_messages_import_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Import a message into mailbox  # noqa: E501

        Import a message into the user's Gmail account with standard email scanning and classification. This method simulates receiving an email via SMTP but does not send the message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_import_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param Message body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param bool deleted: Mark the email as permanently deleted (not TRASH) and only visible in Google Vault to a Vault administrator. Only used for Google Workspace accounts.
        :param str internal_date_source: Source for Gmail's internal date of the message.
        :param bool never_mark_spam: Ignore the Gmail spam classifier decision and never mark this email as SPAM in the mailbox.
        :param bool process_for_calendar: Process calendar invites in the email and add any extracted meetings to the Google Calendar for this user.
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type', 'deleted', 'internal_date_source', 'never_mark_spam', 'process_for_calendar']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_messages_import" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_messages_import`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501
        if 'deleted' in params:
            query_params.append(('deleted', params['deleted']))  # noqa: E501
        if 'internal_date_source' in params:
            query_params.append(('internalDateSource', params['internal_date_source']))  # noqa: E501
        if 'never_mark_spam' in params:
            query_params.append(('neverMarkSpam', params['never_mark_spam']))  # noqa: E501
        if 'process_for_calendar' in params:
            query_params.append(('processForCalendar', params['process_for_calendar']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['message/cpim', 'message/delivery-status', 'message/disposition-notification', 'message/external-body', 'message/feedback-report', 'message/global', 'message/global-delivery-status', 'message/global-disposition-notification', 'message/global-headers', 'message/http', 'message/imdn+xml', 'message/news', 'message/partial', 'message/rfc822', 'message/s-http', 'message/sip', 'message/sipfrag', 'message/tracking-status', 'message/vnd.si.simp', 'message/vnd.wfa.wsc'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/messages/import', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Message',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_messages_insert(self, user_id, **kwargs):  # noqa: E501
        """Insert a message into mailbox  # noqa: E501

        Insert a message directly into the user's Gmail account without sending it. This is similar to adding a message via IMAP APPEND and bypasses most scanning and classification processes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_insert(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param Message body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param bool deleted: Mark the email as permanently deleted (not TRASH) and only visible in Google Vault to a Vault administrator. Only used for Google Workspace accounts.
        :param str internal_date_source: Source for Gmail's internal date of the message.
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_messages_insert_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_messages_insert_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_messages_insert_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Insert a message into mailbox  # noqa: E501

        Insert a message directly into the user's Gmail account without sending it. This is similar to adding a message via IMAP APPEND and bypasses most scanning and classification processes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_insert_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param Message body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param bool deleted: Mark the email as permanently deleted (not TRASH) and only visible in Google Vault to a Vault administrator. Only used for Google Workspace accounts.
        :param str internal_date_source: Source for Gmail's internal date of the message.
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type', 'deleted', 'internal_date_source']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_messages_insert" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_messages_insert`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501
        if 'deleted' in params:
            query_params.append(('deleted', params['deleted']))  # noqa: E501
        if 'internal_date_source' in params:
            query_params.append(('internalDateSource', params['internal_date_source']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['message/cpim', 'message/delivery-status', 'message/disposition-notification', 'message/external-body', 'message/feedback-report', 'message/global', 'message/global-delivery-status', 'message/global-disposition-notification', 'message/global-headers', 'message/http', 'message/imdn+xml', 'message/news', 'message/partial', 'message/rfc822', 'message/s-http', 'message/sip', 'message/sipfrag', 'message/tracking-status', 'message/vnd.si.simp', 'message/vnd.wfa.wsc'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/messages', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Message',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_messages_list(self, user_id, **kwargs):  # noqa: E501
        """List user's email messages  # noqa: E501

        Retrieve a list of all messages in the user's Gmail account. This endpoint provides access to emails, allowing you to view and manage them.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_list(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param bool include_spam_trash: Include messages from `SPAM` and `TRASH` in the results.
        :param list[str] label_ids: Only return messages with labels that match all of the specified label IDs. Messages in a thread might have labels that other messages in the same thread don't have. To learn more, see [Manage labels on messages and threads](https://developers.google.com/gmail/api/guides/labels#manage_labels_on_messages_threads).
        :param int max_results: Maximum number of messages to return. This field defaults to 100. The maximum allowed value for this field is 500.
        :param str page_token: Page token to retrieve a specific page of results in the list.
        :param str q: Only return messages matching the specified query. Supports the same query format as the Gmail search box. For example, `\"from:someuser@example.com rfc822msgid: is:unread\"`. Parameter cannot be used when accessing the api using the gmail.metadata scope.
        :return: ListMessagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_messages_list_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_messages_list_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_messages_list_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List user's email messages  # noqa: E501

        Retrieve a list of all messages in the user's Gmail account. This endpoint provides access to emails, allowing you to view and manage them.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_list_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param bool include_spam_trash: Include messages from `SPAM` and `TRASH` in the results.
        :param list[str] label_ids: Only return messages with labels that match all of the specified label IDs. Messages in a thread might have labels that other messages in the same thread don't have. To learn more, see [Manage labels on messages and threads](https://developers.google.com/gmail/api/guides/labels#manage_labels_on_messages_threads).
        :param int max_results: Maximum number of messages to return. This field defaults to 100. The maximum allowed value for this field is 500.
        :param str page_token: Page token to retrieve a specific page of results in the list.
        :param str q: Only return messages matching the specified query. Supports the same query format as the Gmail search box. For example, `\"from:someuser@example.com rfc822msgid: is:unread\"`. Parameter cannot be used when accessing the api using the gmail.metadata scope.
        :return: ListMessagesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type', 'include_spam_trash', 'label_ids', 'max_results', 'page_token', 'q']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_messages_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_messages_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501
        if 'include_spam_trash' in params:
            query_params.append(('includeSpamTrash', params['include_spam_trash']))  # noqa: E501
        if 'label_ids' in params:
            query_params.append(('labelIds', params['label_ids']))  # noqa: E501
            collection_formats['labelIds'] = 'multi'  # noqa: E501
        if 'max_results' in params:
            query_params.append(('maxResults', params['max_results']))  # noqa: E501
        if 'page_token' in params:
            query_params.append(('pageToken', params['page_token']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/messages', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListMessagesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_messages_modify(self, user_id, id, **kwargs):  # noqa: E501
        """Modify labels of a message  # noqa: E501

        Modify the labels of a specific email message. This allows for updating the message's categorization and organization within the mailbox.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_modify(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the message to modify. (required)
        :param ModifyMessageRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_messages_modify_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_messages_modify_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_messages_modify_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Modify labels of a message  # noqa: E501

        Modify the labels of a specific email message. This allows for updating the message's categorization and organization within the mailbox.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_modify_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the message to modify. (required)
        :param ModifyMessageRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_messages_modify" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_messages_modify`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_messages_modify`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/messages/{id}/modify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Message',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_messages_send(self, user_id, **kwargs):  # noqa: E501
        """Send an email message  # noqa: E501

        Send a specified email message to the recipients listed in the 'To', 'Cc', and 'Bcc' fields. This endpoint finalizes and delivers the message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_send(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param Message body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_messages_send_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_messages_send_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_messages_send_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Send an email message  # noqa: E501

        Send a specified email message to the recipients listed in the 'To', 'Cc', and 'Bcc' fields. This endpoint finalizes and delivers the message.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_send_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param Message body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_messages_send" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_messages_send`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['message/cpim', 'message/delivery-status', 'message/disposition-notification', 'message/external-body', 'message/feedback-report', 'message/global', 'message/global-delivery-status', 'message/global-disposition-notification', 'message/global-headers', 'message/http', 'message/imdn+xml', 'message/news', 'message/partial', 'message/rfc822', 'message/s-http', 'message/sip', 'message/sipfrag', 'message/tracking-status', 'message/vnd.si.simp', 'message/vnd.wfa.wsc'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/messages/send', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Message',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_messages_trash(self, user_id, id, **kwargs):  # noqa: E501
        """Trash a specific email message  # noqa: E501

        Move a specific email message to the trash. This action is reversible, allowing the message to be restored if needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_trash(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the message to Trash. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_messages_trash_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_messages_trash_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_messages_trash_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Trash a specific email message  # noqa: E501

        Move a specific email message to the trash. This action is reversible, allowing the message to be restored if needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_trash_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the message to Trash. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_messages_trash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_messages_trash`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_messages_trash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/messages/{id}/trash', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Message',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_messages_untrash(self, user_id, id, **kwargs):  # noqa: E501
        """Untrash a specific email message  # noqa: E501

        Restore a specific email message from the trash back to the inbox or its original location. This action reverses the trash operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_untrash(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the message to remove from Trash. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_messages_untrash_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_messages_untrash_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_messages_untrash_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Untrash a specific email message  # noqa: E501

        Restore a specific email message from the trash back to the inbox or its original location. This action reverses the trash operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_messages_untrash_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the message to remove from Trash. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_messages_untrash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_messages_untrash`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_messages_untrash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/messages/{id}/untrash', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Message',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_cse_identities_create(self, user_id, **kwargs):  # noqa: E501
        """Create encrypted email identity  # noqa: E501

        Create and configure a client-side encryption identity for sending encrypted emails. The S/MIME certificate is published to a domain-wide directory for secure communication within a Google Workspace organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_identities_create(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param CseIdentity body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: CseIdentity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_cse_identities_create_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_cse_identities_create_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_cse_identities_create_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Create encrypted email identity  # noqa: E501

        Create and configure a client-side encryption identity for sending encrypted emails. The S/MIME certificate is published to a domain-wide directory for secure communication within a Google Workspace organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_identities_create_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param CseIdentity body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: CseIdentity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_cse_identities_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_cse_identities_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/cse/identities', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CseIdentity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_cse_identities_delete(self, user_id, cse_email_address, **kwargs):  # noqa: E501
        """Delete encryption identity  # noqa: E501

        This endpoint deletes a client-side encryption identity for the authenticated user. Once deleted, the identity cannot be used to send encrypted messages and cannot be restored. To create a new identity with the same configuration, use the CreateCseIdentity method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_identities_delete(user_id, cse_email_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str cse_email_address: The primary email address associated with the client-side encryption identity configuration that's removed. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_cse_identities_delete_with_http_info(user_id, cse_email_address, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_cse_identities_delete_with_http_info(user_id, cse_email_address, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_cse_identities_delete_with_http_info(self, user_id, cse_email_address, **kwargs):  # noqa: E501
        """Delete encryption identity  # noqa: E501

        This endpoint deletes a client-side encryption identity for the authenticated user. Once deleted, the identity cannot be used to send encrypted messages and cannot be restored. To create a new identity with the same configuration, use the CreateCseIdentity method.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_identities_delete_with_http_info(user_id, cse_email_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str cse_email_address: The primary email address associated with the client-side encryption identity configuration that's removed. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'cse_email_address', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_cse_identities_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_cse_identities_delete`")  # noqa: E501
        # verify the required parameter 'cse_email_address' is set
        if ('cse_email_address' not in params or
                params['cse_email_address'] is None):
            raise ValueError("Missing the required parameter `cse_email_address` when calling `gmail_users_settings_cse_identities_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'cse_email_address' in params:
            path_params['cseEmailAddress'] = params['cse_email_address']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/cse/identities/{cseEmailAddress}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_cse_identities_get(self, user_id, cse_email_address, **kwargs):  # noqa: E501
        """Get encryption identity configuration  # noqa: E501

        Retrieve the configuration details of a client-side encryption identity for the authenticated user. This allows you to view the settings associated with the encryption identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_identities_get(user_id, cse_email_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str cse_email_address: The primary email address associated with the client-side encryption identity configuration that's retrieved. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: CseIdentity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_cse_identities_get_with_http_info(user_id, cse_email_address, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_cse_identities_get_with_http_info(user_id, cse_email_address, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_cse_identities_get_with_http_info(self, user_id, cse_email_address, **kwargs):  # noqa: E501
        """Get encryption identity configuration  # noqa: E501

        Retrieve the configuration details of a client-side encryption identity for the authenticated user. This allows you to view the settings associated with the encryption identity.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_identities_get_with_http_info(user_id, cse_email_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str cse_email_address: The primary email address associated with the client-side encryption identity configuration that's retrieved. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: CseIdentity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'cse_email_address', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_cse_identities_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_cse_identities_get`")  # noqa: E501
        # verify the required parameter 'cse_email_address' is set
        if ('cse_email_address' not in params or
                params['cse_email_address'] is None):
            raise ValueError("Missing the required parameter `cse_email_address` when calling `gmail_users_settings_cse_identities_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'cse_email_address' in params:
            path_params['cseEmailAddress'] = params['cse_email_address']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/cse/identities/{cseEmailAddress}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CseIdentity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_cse_identities_list(self, user_id, **kwargs):  # noqa: E501
        """List encrypted email identities  # noqa: E501

        List all client-side encrypted identities for the authenticated user. These identities are used for sending encrypted emails within a Google Workspace organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_identities_list(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param int page_size: The number of identities to return. If not provided, the page size will default to 20 entries.
        :param str page_token: Pagination token indicating which page of identities to return. If the token is not supplied, then the API will return the first page of results.
        :return: ListCseIdentitiesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_cse_identities_list_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_cse_identities_list_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_cse_identities_list_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List encrypted email identities  # noqa: E501

        List all client-side encrypted identities for the authenticated user. These identities are used for sending encrypted emails within a Google Workspace organization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_identities_list_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param int page_size: The number of identities to return. If not provided, the page size will default to 20 entries.
        :param str page_token: Pagination token indicating which page of identities to return. If the token is not supplied, then the API will return the first page of results.
        :return: ListCseIdentitiesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type', 'page_size', 'page_token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_cse_identities_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_cse_identities_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'page_token' in params:
            query_params.append(('pageToken', params['page_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/cse/identities', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListCseIdentitiesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_cse_identities_patch(self, user_id, email_address, **kwargs):  # noqa: E501
        """Update encryption identity key pair  # noqa: E501

        Update an existing client-side encryption identity by associating it with a new key pair. The new key pair must comply with Google's S/MIME certificate profiles to ensure proper validation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_identities_patch(user_id, email_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str email_address: The email address of the client-side encryption identity to update. (required)
        :param CseIdentity body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: CseIdentity
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_cse_identities_patch_with_http_info(user_id, email_address, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_cse_identities_patch_with_http_info(user_id, email_address, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_cse_identities_patch_with_http_info(self, user_id, email_address, **kwargs):  # noqa: E501
        """Update encryption identity key pair  # noqa: E501

        Update an existing client-side encryption identity by associating it with a new key pair. The new key pair must comply with Google's S/MIME certificate profiles to ensure proper validation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_identities_patch_with_http_info(user_id, email_address, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str email_address: The email address of the client-side encryption identity to update. (required)
        :param CseIdentity body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: CseIdentity
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'email_address', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_cse_identities_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_cse_identities_patch`")  # noqa: E501
        # verify the required parameter 'email_address' is set
        if ('email_address' not in params or
                params['email_address'] is None):
            raise ValueError("Missing the required parameter `email_address` when calling `gmail_users_settings_cse_identities_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'email_address' in params:
            path_params['emailAddress'] = params['email_address']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/cse/identities/{emailAddress}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CseIdentity',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_cse_keypairs_create(self, user_id, **kwargs):  # noqa: E501
        """Create encryption key pair  # noqa: E501

        Create and upload a new client-side encryption S/MIME public key certificate chain and private key metadata for the authenticated user. This enables the user to send and receive encrypted emails.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_keypairs_create(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param CseKeyPair body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: CseKeyPair
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_cse_keypairs_create_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_cse_keypairs_create_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_cse_keypairs_create_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Create encryption key pair  # noqa: E501

        Create and upload a new client-side encryption S/MIME public key certificate chain and private key metadata for the authenticated user. This enables the user to send and receive encrypted emails.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_keypairs_create_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param CseKeyPair body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: CseKeyPair
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_cse_keypairs_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_cse_keypairs_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/cse/keypairs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CseKeyPair',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_cse_keypairs_disable(self, user_id, key_pair_id, **kwargs):  # noqa: E501
        """Disable encryption key pair  # noqa: E501

        Disable a client-side encryption key pair, preventing its use for decrypting incoming messages or signing outgoing emails. To reactivate the key pair, use the EnableCseKeyPair method. After 30 days of being disabled, the key pair can be permanently deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_keypairs_disable(user_id, key_pair_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str key_pair_id: The identifier of the key pair to turn off. (required)
        :param DisableCseKeyPairRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: CseKeyPair
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_cse_keypairs_disable_with_http_info(user_id, key_pair_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_cse_keypairs_disable_with_http_info(user_id, key_pair_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_cse_keypairs_disable_with_http_info(self, user_id, key_pair_id, **kwargs):  # noqa: E501
        """Disable encryption key pair  # noqa: E501

        Disable a client-side encryption key pair, preventing its use for decrypting incoming messages or signing outgoing emails. To reactivate the key pair, use the EnableCseKeyPair method. After 30 days of being disabled, the key pair can be permanently deleted.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_keypairs_disable_with_http_info(user_id, key_pair_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str key_pair_id: The identifier of the key pair to turn off. (required)
        :param DisableCseKeyPairRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: CseKeyPair
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'key_pair_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_cse_keypairs_disable" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_cse_keypairs_disable`")  # noqa: E501
        # verify the required parameter 'key_pair_id' is set
        if ('key_pair_id' not in params or
                params['key_pair_id'] is None):
            raise ValueError("Missing the required parameter `key_pair_id` when calling `gmail_users_settings_cse_keypairs_disable`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'key_pair_id' in params:
            path_params['keyPairId'] = params['key_pair_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/cse/keypairs/{keyPairId}:disable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CseKeyPair',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_cse_keypairs_enable(self, user_id, key_pair_id, **kwargs):  # noqa: E501
        """Enable encryption key pair  # noqa: E501

        Enable a previously disabled client-side encryption key pair, making it active again for use with associated encryption identities.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_keypairs_enable(user_id, key_pair_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str key_pair_id: The identifier of the key pair to turn on. (required)
        :param EnableCseKeyPairRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: CseKeyPair
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_cse_keypairs_enable_with_http_info(user_id, key_pair_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_cse_keypairs_enable_with_http_info(user_id, key_pair_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_cse_keypairs_enable_with_http_info(self, user_id, key_pair_id, **kwargs):  # noqa: E501
        """Enable encryption key pair  # noqa: E501

        Enable a previously disabled client-side encryption key pair, making it active again for use with associated encryption identities.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_keypairs_enable_with_http_info(user_id, key_pair_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str key_pair_id: The identifier of the key pair to turn on. (required)
        :param EnableCseKeyPairRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: CseKeyPair
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'key_pair_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_cse_keypairs_enable" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_cse_keypairs_enable`")  # noqa: E501
        # verify the required parameter 'key_pair_id' is set
        if ('key_pair_id' not in params or
                params['key_pair_id'] is None):
            raise ValueError("Missing the required parameter `key_pair_id` when calling `gmail_users_settings_cse_keypairs_enable`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'key_pair_id' in params:
            path_params['keyPairId'] = params['key_pair_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/cse/keypairs/{keyPairId}:enable', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CseKeyPair',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_cse_keypairs_get(self, user_id, key_pair_id, **kwargs):  # noqa: E501
        """Get encryption key pair details  # noqa: E501

        Retrieve details of a specific client-side encryption key pair for the authenticated user. This provides information about the key pair used for encryption and decryption.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_keypairs_get(user_id, key_pair_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str key_pair_id: The identifier of the key pair to retrieve. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: CseKeyPair
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_cse_keypairs_get_with_http_info(user_id, key_pair_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_cse_keypairs_get_with_http_info(user_id, key_pair_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_cse_keypairs_get_with_http_info(self, user_id, key_pair_id, **kwargs):  # noqa: E501
        """Get encryption key pair details  # noqa: E501

        Retrieve details of a specific client-side encryption key pair for the authenticated user. This provides information about the key pair used for encryption and decryption.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_keypairs_get_with_http_info(user_id, key_pair_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str key_pair_id: The identifier of the key pair to retrieve. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: CseKeyPair
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'key_pair_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_cse_keypairs_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_cse_keypairs_get`")  # noqa: E501
        # verify the required parameter 'key_pair_id' is set
        if ('key_pair_id' not in params or
                params['key_pair_id'] is None):
            raise ValueError("Missing the required parameter `key_pair_id` when calling `gmail_users_settings_cse_keypairs_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'key_pair_id' in params:
            path_params['keyPairId'] = params['key_pair_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/cse/keypairs/{keyPairId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CseKeyPair',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_cse_keypairs_list(self, user_id, **kwargs):  # noqa: E501
        """List encryption key pairs  # noqa: E501

        List all client-side encryption key pairs associated with the authenticated user. This allows users to view their existing key pairs used for encrypting and decrypting messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_keypairs_list(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param int page_size: The number of key pairs to return. If not provided, the page size will default to 20 entries.
        :param str page_token: Pagination token indicating which page of key pairs to return. If the token is not supplied, then the API will return the first page of results.
        :return: ListCseKeyPairsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_cse_keypairs_list_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_cse_keypairs_list_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_cse_keypairs_list_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List encryption key pairs  # noqa: E501

        List all client-side encryption key pairs associated with the authenticated user. This allows users to view their existing key pairs used for encrypting and decrypting messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_keypairs_list_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param int page_size: The number of key pairs to return. If not provided, the page size will default to 20 entries.
        :param str page_token: Pagination token indicating which page of key pairs to return. If the token is not supplied, then the API will return the first page of results.
        :return: ListCseKeyPairsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type', 'page_size', 'page_token']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_cse_keypairs_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_cse_keypairs_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'page_token' in params:
            query_params.append(('pageToken', params['page_token']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/cse/keypairs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListCseKeyPairsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_cse_keypairs_obliterate(self, user_id, key_pair_id, **kwargs):  # noqa: E501
        """Permanently delete encryption key pair  # noqa: E501

        Permanently delete a client-side encryption key pair that has been disabled for over 30 days. Once obliterated, Gmail cannot restore or decrypt any messages encrypted with this key, and access to these messages is lost.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_keypairs_obliterate(user_id, key_pair_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str key_pair_id: The identifier of the key pair to obliterate. (required)
        :param ObliterateCseKeyPairRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_cse_keypairs_obliterate_with_http_info(user_id, key_pair_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_cse_keypairs_obliterate_with_http_info(user_id, key_pair_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_cse_keypairs_obliterate_with_http_info(self, user_id, key_pair_id, **kwargs):  # noqa: E501
        """Permanently delete encryption key pair  # noqa: E501

        Permanently delete a client-side encryption key pair that has been disabled for over 30 days. Once obliterated, Gmail cannot restore or decrypt any messages encrypted with this key, and access to these messages is lost.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_cse_keypairs_obliterate_with_http_info(user_id, key_pair_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The requester's primary email address. To indicate the authenticated user, you can use the special value `me`. (required)
        :param str key_pair_id: The identifier of the key pair to obliterate. (required)
        :param ObliterateCseKeyPairRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'key_pair_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_cse_keypairs_obliterate" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_cse_keypairs_obliterate`")  # noqa: E501
        # verify the required parameter 'key_pair_id' is set
        if ('key_pair_id' not in params or
                params['key_pair_id'] is None):
            raise ValueError("Missing the required parameter `key_pair_id` when calling `gmail_users_settings_cse_keypairs_obliterate`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'key_pair_id' in params:
            path_params['keyPairId'] = params['key_pair_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/cse/keypairs/{keyPairId}:obliterate', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_delegates_create(self, user_id, **kwargs):  # noqa: E501
        """Add email delegate  # noqa: E501

        Add a new delegate to an account with the verification status set to 'accepted'. The delegate must belong to the same Google Workspace organization as the delegator. This method is available only to service account clients with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_delegates_create(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param Delegate body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Delegate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_delegates_create_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_delegates_create_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_delegates_create_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Add email delegate  # noqa: E501

        Add a new delegate to an account with the verification status set to 'accepted'. The delegate must belong to the same Google Workspace organization as the delegator. This method is available only to service account clients with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_delegates_create_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param Delegate body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Delegate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_delegates_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_delegates_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/delegates', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Delegate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_delegates_delete(self, user_id, delegate_email, **kwargs):  # noqa: E501
        """Remove email delegate  # noqa: E501

        Remove a specified delegate from an account, revoking any verification required for its use. This method is available only to service account clients with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_delegates_delete(user_id, delegate_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str delegate_email: The email address of the user to be removed as a delegate. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_delegates_delete_with_http_info(user_id, delegate_email, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_delegates_delete_with_http_info(user_id, delegate_email, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_delegates_delete_with_http_info(self, user_id, delegate_email, **kwargs):  # noqa: E501
        """Remove email delegate  # noqa: E501

        Remove a specified delegate from an account, revoking any verification required for its use. This method is available only to service account clients with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_delegates_delete_with_http_info(user_id, delegate_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str delegate_email: The email address of the user to be removed as a delegate. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'delegate_email', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_delegates_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_delegates_delete`")  # noqa: E501
        # verify the required parameter 'delegate_email' is set
        if ('delegate_email' not in params or
                params['delegate_email'] is None):
            raise ValueError("Missing the required parameter `delegate_email` when calling `gmail_users_settings_delegates_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'delegate_email' in params:
            path_params['delegateEmail'] = params['delegate_email']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/delegates/{delegateEmail}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_delegates_get(self, user_id, delegate_email, **kwargs):  # noqa: E501
        """Get email delegate details  # noqa: E501

        Retrieve details of a specified delegate for an account. This method is available only to service account clients with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_delegates_get(user_id, delegate_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str delegate_email: The email address of the user whose delegate relationship is to be retrieved. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Delegate
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_delegates_get_with_http_info(user_id, delegate_email, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_delegates_get_with_http_info(user_id, delegate_email, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_delegates_get_with_http_info(self, user_id, delegate_email, **kwargs):  # noqa: E501
        """Get email delegate details  # noqa: E501

        Retrieve details of a specified delegate for an account. This method is available only to service account clients with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_delegates_get_with_http_info(user_id, delegate_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str delegate_email: The email address of the user whose delegate relationship is to be retrieved. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Delegate
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'delegate_email', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_delegates_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_delegates_get`")  # noqa: E501
        # verify the required parameter 'delegate_email' is set
        if ('delegate_email' not in params or
                params['delegate_email'] is None):
            raise ValueError("Missing the required parameter `delegate_email` when calling `gmail_users_settings_delegates_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'delegate_email' in params:
            path_params['delegateEmail'] = params['delegate_email']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/delegates/{delegateEmail}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Delegate',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_delegates_list(self, user_id, **kwargs):  # noqa: E501
        """List email delegates  # noqa: E501

        List all delegates for the specified account. This feature is available only to service account clients with domain-wide authority, allowing them to manage email access permissions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_delegates_list(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ListDelegatesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_delegates_list_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_delegates_list_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_delegates_list_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List email delegates  # noqa: E501

        List all delegates for the specified account. This feature is available only to service account clients with domain-wide authority, allowing them to manage email access permissions.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_delegates_list_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ListDelegatesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_delegates_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_delegates_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/delegates', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListDelegatesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_filters_create(self, user_id, **kwargs):  # noqa: E501
        """Create email filter  # noqa: E501

        Create a new email filter for a Gmail user. Note that there is a limit of 1,000 filters per user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_filters_create(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param Filter body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Filter
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_filters_create_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_filters_create_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_filters_create_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Create email filter  # noqa: E501

        Create a new email filter for a Gmail user. Note that there is a limit of 1,000 filters per user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_filters_create_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param Filter body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Filter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_filters_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_filters_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/filters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Filter',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_filters_delete(self, user_id, id, **kwargs):  # noqa: E501
        """Delete email filter  # noqa: E501

        Permanently delete a specified email filter from a Gmail account. This action cannot be undone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_filters_delete(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str id: The ID of the filter to be deleted. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_filters_delete_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_filters_delete_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_filters_delete_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Delete email filter  # noqa: E501

        Permanently delete a specified email filter from a Gmail account. This action cannot be undone.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_filters_delete_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str id: The ID of the filter to be deleted. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_filters_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_filters_delete`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_settings_filters_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/filters/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_filters_get(self, user_id, id, **kwargs):  # noqa: E501
        """Get email filter details  # noqa: E501

        Retrieve details of a specific email filter set up by a Gmail user. This provides information about the criteria and actions of the filter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_filters_get(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str id: The ID of the filter to be fetched. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Filter
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_filters_get_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_filters_get_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_filters_get_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Get email filter details  # noqa: E501

        Retrieve details of a specific email filter set up by a Gmail user. This provides information about the criteria and actions of the filter.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_filters_get_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str id: The ID of the filter to be fetched. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Filter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_filters_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_filters_get`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_settings_filters_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/filters/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Filter',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_filters_list(self, user_id, **kwargs):  # noqa: E501
        """List email filters  # noqa: E501

        List all message filters set up by a Gmail user. Filters automatically manage incoming emails based on specified criteria.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_filters_list(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ListFiltersResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_filters_list_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_filters_list_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_filters_list_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List email filters  # noqa: E501

        List all message filters set up by a Gmail user. Filters automatically manage incoming emails based on specified criteria.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_filters_list_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ListFiltersResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_filters_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_filters_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/filters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListFiltersResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_forwarding_addresses_create(self, user_id, **kwargs):  # noqa: E501
        """Create forwarding address  # noqa: E501

        Create a new forwarding address for a Gmail account. If verification is required, a message will be sent to the recipient. This method is available only to service account clients with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_forwarding_addresses_create(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param ForwardingAddress body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ForwardingAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_forwarding_addresses_create_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_forwarding_addresses_create_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_forwarding_addresses_create_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Create forwarding address  # noqa: E501

        Create a new forwarding address for a Gmail account. If verification is required, a message will be sent to the recipient. This method is available only to service account clients with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_forwarding_addresses_create_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param ForwardingAddress body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ForwardingAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_forwarding_addresses_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_forwarding_addresses_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/forwardingAddresses', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ForwardingAddress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_forwarding_addresses_delete(self, user_id, forwarding_email, **kwargs):  # noqa: E501
        """Delete forwarding address  # noqa: E501

        Delete a specified forwarding address from a Gmail account, revoking any required verification. This method is available only to service account clients with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_forwarding_addresses_delete(user_id, forwarding_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str forwarding_email: The forwarding address to be deleted. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_forwarding_addresses_delete_with_http_info(user_id, forwarding_email, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_forwarding_addresses_delete_with_http_info(user_id, forwarding_email, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_forwarding_addresses_delete_with_http_info(self, user_id, forwarding_email, **kwargs):  # noqa: E501
        """Delete forwarding address  # noqa: E501

        Delete a specified forwarding address from a Gmail account, revoking any required verification. This method is available only to service account clients with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_forwarding_addresses_delete_with_http_info(user_id, forwarding_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str forwarding_email: The forwarding address to be deleted. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'forwarding_email', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_forwarding_addresses_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_forwarding_addresses_delete`")  # noqa: E501
        # verify the required parameter 'forwarding_email' is set
        if ('forwarding_email' not in params or
                params['forwarding_email'] is None):
            raise ValueError("Missing the required parameter `forwarding_email` when calling `gmail_users_settings_forwarding_addresses_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'forwarding_email' in params:
            path_params['forwardingEmail'] = params['forwarding_email']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/forwardingAddresses/{forwardingEmail}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_forwarding_addresses_get(self, user_id, forwarding_email, **kwargs):  # noqa: E501
        """Get forwarding address details  # noqa: E501

        Retrieve details of a specified forwarding address for a Gmail account. This provides information about the forwarding configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_forwarding_addresses_get(user_id, forwarding_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str forwarding_email: The forwarding address to be retrieved. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ForwardingAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_forwarding_addresses_get_with_http_info(user_id, forwarding_email, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_forwarding_addresses_get_with_http_info(user_id, forwarding_email, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_forwarding_addresses_get_with_http_info(self, user_id, forwarding_email, **kwargs):  # noqa: E501
        """Get forwarding address details  # noqa: E501

        Retrieve details of a specified forwarding address for a Gmail account. This provides information about the forwarding configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_forwarding_addresses_get_with_http_info(user_id, forwarding_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str forwarding_email: The forwarding address to be retrieved. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ForwardingAddress
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'forwarding_email', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_forwarding_addresses_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_forwarding_addresses_get`")  # noqa: E501
        # verify the required parameter 'forwarding_email' is set
        if ('forwarding_email' not in params or
                params['forwarding_email'] is None):
            raise ValueError("Missing the required parameter `forwarding_email` when calling `gmail_users_settings_forwarding_addresses_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'forwarding_email' in params:
            path_params['forwardingEmail'] = params['forwarding_email']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/forwardingAddresses/{forwardingEmail}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ForwardingAddress',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_forwarding_addresses_list(self, user_id, **kwargs):  # noqa: E501
        """List forwarding addresses  # noqa: E501

        List all forwarding addresses configured for the specified Gmail account. Forwarding addresses allow emails to be automatically sent to another email address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_forwarding_addresses_list(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ListForwardingAddressesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_forwarding_addresses_list_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_forwarding_addresses_list_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_forwarding_addresses_list_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List forwarding addresses  # noqa: E501

        List all forwarding addresses configured for the specified Gmail account. Forwarding addresses allow emails to be automatically sent to another email address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_forwarding_addresses_list_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ListForwardingAddressesResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_forwarding_addresses_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_forwarding_addresses_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/forwardingAddresses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListForwardingAddressesResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_get_auto_forwarding(self, user_id, **kwargs):  # noqa: E501
        """Get auto-forwarding settings  # noqa: E501

        Retrieve the auto-forwarding settings for the user's Gmail account. This includes information on whether auto-forwarding is enabled and the forwarding address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_get_auto_forwarding(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: AutoForwarding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_get_auto_forwarding_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_get_auto_forwarding_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_get_auto_forwarding_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get auto-forwarding settings  # noqa: E501

        Retrieve the auto-forwarding settings for the user's Gmail account. This includes information on whether auto-forwarding is enabled and the forwarding address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_get_auto_forwarding_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: AutoForwarding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_get_auto_forwarding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_get_auto_forwarding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/autoForwarding', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AutoForwarding',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_get_imap(self, user_id, **kwargs):  # noqa: E501
        """Get IMAP settings  # noqa: E501

        Retrieve the IMAP settings for a Gmail account. IMAP settings determine how email clients access the account's messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_get_imap(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ImapSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_get_imap_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_get_imap_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_get_imap_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get IMAP settings  # noqa: E501

        Retrieve the IMAP settings for a Gmail account. IMAP settings determine how email clients access the account's messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_get_imap_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ImapSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_get_imap" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_get_imap`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/imap', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImapSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_get_language(self, user_id, **kwargs):  # noqa: E501
        """Get language settings  # noqa: E501

        Retrieve the language settings for a Gmail account. This determines the language used for the Gmail interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_get_language(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: LanguageSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_get_language_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_get_language_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_get_language_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get language settings  # noqa: E501

        Retrieve the language settings for a Gmail account. This determines the language used for the Gmail interface.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_get_language_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: LanguageSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_get_language" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_get_language`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/language', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LanguageSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_get_pop(self, user_id, **kwargs):  # noqa: E501
        """Get POP settings  # noqa: E501

        Retrieve the POP settings for a Gmail account. POP settings determine how email clients download messages from the account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_get_pop(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: PopSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_get_pop_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_get_pop_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_get_pop_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get POP settings  # noqa: E501

        Retrieve the POP settings for a Gmail account. POP settings determine how email clients download messages from the account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_get_pop_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: PopSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_get_pop" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_get_pop`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/pop', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PopSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_get_vacation(self, user_id, **kwargs):  # noqa: E501
        """Get vacation responder settings  # noqa: E501

        Retrieve the current vacation responder settings for a Gmail account. The vacation responder automatically replies to incoming emails with a specified message when enabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_get_vacation(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: VacationSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_get_vacation_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_get_vacation_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_get_vacation_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get vacation responder settings  # noqa: E501

        Retrieve the current vacation responder settings for a Gmail account. The vacation responder automatically replies to incoming emails with a specified message when enabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_get_vacation_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: VacationSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_get_vacation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_get_vacation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/vacation', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VacationSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_send_as_create(self, user_id, **kwargs):  # noqa: E501
        """Create send-as alias  # noqa: E501

        Create a custom 'from' send-as alias for a Gmail account. If an SMTP MSA is specified, Gmail will validate the configuration. Verification may be required, and a message will be sent to the email address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_create(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param SendAs body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: SendAs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_send_as_create_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_send_as_create_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_send_as_create_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Create send-as alias  # noqa: E501

        Create a custom 'from' send-as alias for a Gmail account. If an SMTP MSA is specified, Gmail will validate the configuration. Verification may be required, and a message will be sent to the email address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_create_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param SendAs body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: SendAs
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_send_as_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_send_as_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/sendAs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SendAs',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_send_as_delete(self, user_id, send_as_email, **kwargs):  # noqa: E501
        """Delete send-as alias  # noqa: E501

        Delete a specified send-as alias from a Gmail account, revoking any required verification. This method is available only to service account clients with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_delete(user_id, send_as_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str send_as_email: The send-as alias to be deleted. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_send_as_delete_with_http_info(user_id, send_as_email, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_send_as_delete_with_http_info(user_id, send_as_email, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_send_as_delete_with_http_info(self, user_id, send_as_email, **kwargs):  # noqa: E501
        """Delete send-as alias  # noqa: E501

        Delete a specified send-as alias from a Gmail account, revoking any required verification. This method is available only to service account clients with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_delete_with_http_info(user_id, send_as_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str send_as_email: The send-as alias to be deleted. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'send_as_email', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_send_as_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_send_as_delete`")  # noqa: E501
        # verify the required parameter 'send_as_email' is set
        if ('send_as_email' not in params or
                params['send_as_email'] is None):
            raise ValueError("Missing the required parameter `send_as_email` when calling `gmail_users_settings_send_as_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'send_as_email' in params:
            path_params['sendAsEmail'] = params['send_as_email']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/sendAs/{sendAsEmail}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_send_as_get(self, user_id, send_as_email, **kwargs):  # noqa: E501
        """Get send-as alias details  # noqa: E501

        Retrieve details of a specific send-as alias for a Gmail account. This alias allows sending emails from an alternative email address linked to the user's account. If the alias does not exist, an HTTP 404 error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_get(user_id, send_as_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str send_as_email: The send-as alias to be retrieved. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: SendAs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_send_as_get_with_http_info(user_id, send_as_email, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_send_as_get_with_http_info(user_id, send_as_email, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_send_as_get_with_http_info(self, user_id, send_as_email, **kwargs):  # noqa: E501
        """Get send-as alias details  # noqa: E501

        Retrieve details of a specific send-as alias for a Gmail account. This alias allows sending emails from an alternative email address linked to the user's account. If the alias does not exist, an HTTP 404 error is returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_get_with_http_info(user_id, send_as_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str send_as_email: The send-as alias to be retrieved. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: SendAs
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'send_as_email', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_send_as_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_send_as_get`")  # noqa: E501
        # verify the required parameter 'send_as_email' is set
        if ('send_as_email' not in params or
                params['send_as_email'] is None):
            raise ValueError("Missing the required parameter `send_as_email` when calling `gmail_users_settings_send_as_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'send_as_email' in params:
            path_params['sendAsEmail'] = params['send_as_email']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/sendAs/{sendAsEmail}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SendAs',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_send_as_list(self, user_id, **kwargs):  # noqa: E501
        """List send-as aliases  # noqa: E501

        List all send-as aliases for the specified Gmail account, including the primary address and any custom 'from' aliases.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_list(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ListSendAsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_send_as_list_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_send_as_list_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_send_as_list_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List send-as aliases  # noqa: E501

        List all send-as aliases for the specified Gmail account, including the primary address and any custom 'from' aliases.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_list_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ListSendAsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_send_as_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_send_as_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/sendAs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListSendAsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_send_as_patch(self, user_id, send_as_email, **kwargs):  # noqa: E501
        """Update send-as alias settings  # noqa: E501

        Partially update the settings of a specified send-as alias for a Gmail account. This allows modifications to certain properties of the alias without replacing the entire configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_patch(user_id, send_as_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str send_as_email: The send-as alias to be updated. (required)
        :param SendAs body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: SendAs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_send_as_patch_with_http_info(user_id, send_as_email, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_send_as_patch_with_http_info(user_id, send_as_email, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_send_as_patch_with_http_info(self, user_id, send_as_email, **kwargs):  # noqa: E501
        """Update send-as alias settings  # noqa: E501

        Partially update the settings of a specified send-as alias for a Gmail account. This allows modifications to certain properties of the alias without replacing the entire configuration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_patch_with_http_info(user_id, send_as_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str send_as_email: The send-as alias to be updated. (required)
        :param SendAs body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: SendAs
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'send_as_email', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_send_as_patch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_send_as_patch`")  # noqa: E501
        # verify the required parameter 'send_as_email' is set
        if ('send_as_email' not in params or
                params['send_as_email'] is None):
            raise ValueError("Missing the required parameter `send_as_email` when calling `gmail_users_settings_send_as_patch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'send_as_email' in params:
            path_params['sendAsEmail'] = params['send_as_email']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/sendAs/{sendAsEmail}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SendAs',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_send_as_smime_info_delete(self, user_id, send_as_email, id, **kwargs):  # noqa: E501
        """Delete S/MIME configuration  # noqa: E501

        Remove a specific S/MIME configuration from a send-as alias. This action deletes the encryption and signing settings associated with the alias.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_smime_info_delete(user_id, send_as_email, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str send_as_email: The email address that appears in the \"From:\" header for mail sent using this alias. (required)
        :param str id: The immutable ID for the SmimeInfo. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_send_as_smime_info_delete_with_http_info(user_id, send_as_email, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_send_as_smime_info_delete_with_http_info(user_id, send_as_email, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_send_as_smime_info_delete_with_http_info(self, user_id, send_as_email, id, **kwargs):  # noqa: E501
        """Delete S/MIME configuration  # noqa: E501

        Remove a specific S/MIME configuration from a send-as alias. This action deletes the encryption and signing settings associated with the alias.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_smime_info_delete_with_http_info(user_id, send_as_email, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str send_as_email: The email address that appears in the \"From:\" header for mail sent using this alias. (required)
        :param str id: The immutable ID for the SmimeInfo. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'send_as_email', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_send_as_smime_info_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_send_as_smime_info_delete`")  # noqa: E501
        # verify the required parameter 'send_as_email' is set
        if ('send_as_email' not in params or
                params['send_as_email'] is None):
            raise ValueError("Missing the required parameter `send_as_email` when calling `gmail_users_settings_send_as_smime_info_delete`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_settings_send_as_smime_info_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'send_as_email' in params:
            path_params['sendAsEmail'] = params['send_as_email']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/sendAs/{sendAsEmail}/smimeInfo/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_send_as_smime_info_get(self, user_id, send_as_email, id, **kwargs):  # noqa: E501
        """Get S/MIME configuration details  # noqa: E501

        Retrieve details of a specific S/MIME configuration for a send-as alias. This includes information about the encryption and signing settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_smime_info_get(user_id, send_as_email, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str send_as_email: The email address that appears in the \"From:\" header for mail sent using this alias. (required)
        :param str id: The immutable ID for the SmimeInfo. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: SmimeInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_send_as_smime_info_get_with_http_info(user_id, send_as_email, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_send_as_smime_info_get_with_http_info(user_id, send_as_email, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_send_as_smime_info_get_with_http_info(self, user_id, send_as_email, id, **kwargs):  # noqa: E501
        """Get S/MIME configuration details  # noqa: E501

        Retrieve details of a specific S/MIME configuration for a send-as alias. This includes information about the encryption and signing settings.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_smime_info_get_with_http_info(user_id, send_as_email, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str send_as_email: The email address that appears in the \"From:\" header for mail sent using this alias. (required)
        :param str id: The immutable ID for the SmimeInfo. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: SmimeInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'send_as_email', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_send_as_smime_info_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_send_as_smime_info_get`")  # noqa: E501
        # verify the required parameter 'send_as_email' is set
        if ('send_as_email' not in params or
                params['send_as_email'] is None):
            raise ValueError("Missing the required parameter `send_as_email` when calling `gmail_users_settings_send_as_smime_info_get`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_settings_send_as_smime_info_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'send_as_email' in params:
            path_params['sendAsEmail'] = params['send_as_email']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/sendAs/{sendAsEmail}/smimeInfo/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SmimeInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_send_as_smime_info_insert(self, user_id, send_as_email, **kwargs):  # noqa: E501
        """Add S/MIME configuration  # noqa: E501

        Add a new S/MIME configuration to a specified send-as alias. The configuration must be in pkcs12 format, which is a binary format for storing cryptographic keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_smime_info_insert(user_id, send_as_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str send_as_email: The email address that appears in the \"From:\" header for mail sent using this alias. (required)
        :param SmimeInfo body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: SmimeInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_send_as_smime_info_insert_with_http_info(user_id, send_as_email, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_send_as_smime_info_insert_with_http_info(user_id, send_as_email, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_send_as_smime_info_insert_with_http_info(self, user_id, send_as_email, **kwargs):  # noqa: E501
        """Add S/MIME configuration  # noqa: E501

        Add a new S/MIME configuration to a specified send-as alias. The configuration must be in pkcs12 format, which is a binary format for storing cryptographic keys.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_smime_info_insert_with_http_info(user_id, send_as_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str send_as_email: The email address that appears in the \"From:\" header for mail sent using this alias. (required)
        :param SmimeInfo body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: SmimeInfo
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'send_as_email', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_send_as_smime_info_insert" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_send_as_smime_info_insert`")  # noqa: E501
        # verify the required parameter 'send_as_email' is set
        if ('send_as_email' not in params or
                params['send_as_email'] is None):
            raise ValueError("Missing the required parameter `send_as_email` when calling `gmail_users_settings_send_as_smime_info_insert`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'send_as_email' in params:
            path_params['sendAsEmail'] = params['send_as_email']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/sendAs/{sendAsEmail}/smimeInfo', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SmimeInfo',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_send_as_smime_info_list(self, user_id, send_as_email, **kwargs):  # noqa: E501
        """List S/MIME configurations  # noqa: E501

        Retrieve a list of S/MIME configurations for a specified send-as alias. S/MIME is a standard for public key encryption and signing of MIME data, used to enhance email security.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_smime_info_list(user_id, send_as_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str send_as_email: The email address that appears in the \"From:\" header for mail sent using this alias. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ListSmimeInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_send_as_smime_info_list_with_http_info(user_id, send_as_email, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_send_as_smime_info_list_with_http_info(user_id, send_as_email, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_send_as_smime_info_list_with_http_info(self, user_id, send_as_email, **kwargs):  # noqa: E501
        """List S/MIME configurations  # noqa: E501

        Retrieve a list of S/MIME configurations for a specified send-as alias. S/MIME is a standard for public key encryption and signing of MIME data, used to enhance email security.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_smime_info_list_with_http_info(user_id, send_as_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str send_as_email: The email address that appears in the \"From:\" header for mail sent using this alias. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ListSmimeInfoResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'send_as_email', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_send_as_smime_info_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_send_as_smime_info_list`")  # noqa: E501
        # verify the required parameter 'send_as_email' is set
        if ('send_as_email' not in params or
                params['send_as_email'] is None):
            raise ValueError("Missing the required parameter `send_as_email` when calling `gmail_users_settings_send_as_smime_info_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'send_as_email' in params:
            path_params['sendAsEmail'] = params['send_as_email']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/sendAs/{sendAsEmail}/smimeInfo', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListSmimeInfoResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_send_as_smime_info_set_default(self, user_id, send_as_email, id, **kwargs):  # noqa: E501
        """Set default S/MIME configuration  # noqa: E501

        Set a specific S/MIME configuration as the default for a send-as alias. This configuration will be used for encrypting and signing emails by default.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_smime_info_set_default(user_id, send_as_email, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str send_as_email: The email address that appears in the \"From:\" header for mail sent using this alias. (required)
        :param str id: The immutable ID for the SmimeInfo. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_send_as_smime_info_set_default_with_http_info(user_id, send_as_email, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_send_as_smime_info_set_default_with_http_info(user_id, send_as_email, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_send_as_smime_info_set_default_with_http_info(self, user_id, send_as_email, id, **kwargs):  # noqa: E501
        """Set default S/MIME configuration  # noqa: E501

        Set a specific S/MIME configuration as the default for a send-as alias. This configuration will be used for encrypting and signing emails by default.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_smime_info_set_default_with_http_info(user_id, send_as_email, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str send_as_email: The email address that appears in the \"From:\" header for mail sent using this alias. (required)
        :param str id: The immutable ID for the SmimeInfo. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'send_as_email', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_send_as_smime_info_set_default" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_send_as_smime_info_set_default`")  # noqa: E501
        # verify the required parameter 'send_as_email' is set
        if ('send_as_email' not in params or
                params['send_as_email'] is None):
            raise ValueError("Missing the required parameter `send_as_email` when calling `gmail_users_settings_send_as_smime_info_set_default`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_settings_send_as_smime_info_set_default`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'send_as_email' in params:
            path_params['sendAsEmail'] = params['send_as_email']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/sendAs/{sendAsEmail}/smimeInfo/{id}/setDefault', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_send_as_update(self, user_id, send_as_email, **kwargs):  # noqa: E501
        """Replace send-as alias configuration  # noqa: E501

        Fully update the configuration of a send-as alias for a Gmail account. This includes updating the email signature associated with the alias. Only service account clients with domain-wide authority can update non-primary addresses.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_update(user_id, send_as_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str send_as_email: The send-as alias to be updated. (required)
        :param SendAs body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: SendAs
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_send_as_update_with_http_info(user_id, send_as_email, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_send_as_update_with_http_info(user_id, send_as_email, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_send_as_update_with_http_info(self, user_id, send_as_email, **kwargs):  # noqa: E501
        """Replace send-as alias configuration  # noqa: E501

        Fully update the configuration of a send-as alias for a Gmail account. This includes updating the email signature associated with the alias. Only service account clients with domain-wide authority can update non-primary addresses.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_update_with_http_info(user_id, send_as_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str send_as_email: The send-as alias to be updated. (required)
        :param SendAs body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: SendAs
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'send_as_email', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_send_as_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_send_as_update`")  # noqa: E501
        # verify the required parameter 'send_as_email' is set
        if ('send_as_email' not in params or
                params['send_as_email'] is None):
            raise ValueError("Missing the required parameter `send_as_email` when calling `gmail_users_settings_send_as_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'send_as_email' in params:
            path_params['sendAsEmail'] = params['send_as_email']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/sendAs/{sendAsEmail}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SendAs',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_send_as_verify(self, user_id, send_as_email, **kwargs):  # noqa: E501
        """Verify send-as alias  # noqa: E501

        Send a verification email to confirm the specified send-as alias. This is necessary to ensure the alias is valid and owned by the user. Only available to service account clients with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_verify(user_id, send_as_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str send_as_email: The send-as alias to be verified. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_send_as_verify_with_http_info(user_id, send_as_email, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_send_as_verify_with_http_info(user_id, send_as_email, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_send_as_verify_with_http_info(self, user_id, send_as_email, **kwargs):  # noqa: E501
        """Verify send-as alias  # noqa: E501

        Send a verification email to confirm the specified send-as alias. This is necessary to ensure the alias is valid and owned by the user. Only available to service account clients with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_send_as_verify_with_http_info(user_id, send_as_email, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param str send_as_email: The send-as alias to be verified. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'send_as_email', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_send_as_verify" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_send_as_verify`")  # noqa: E501
        # verify the required parameter 'send_as_email' is set
        if ('send_as_email' not in params or
                params['send_as_email'] is None):
            raise ValueError("Missing the required parameter `send_as_email` when calling `gmail_users_settings_send_as_verify`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'send_as_email' in params:
            path_params['sendAsEmail'] = params['send_as_email']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/sendAs/{sendAsEmail}/verify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_update_auto_forwarding(self, user_id, **kwargs):  # noqa: E501
        """Update auto-forwarding settings  # noqa: E501

        Update the auto-forwarding settings for the user's Gmail account. A verified forwarding address is required to enable auto-forwarding, and this feature is available to service accounts with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_update_auto_forwarding(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param AutoForwarding body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: AutoForwarding
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_update_auto_forwarding_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_update_auto_forwarding_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_update_auto_forwarding_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Update auto-forwarding settings  # noqa: E501

        Update the auto-forwarding settings for the user's Gmail account. A verified forwarding address is required to enable auto-forwarding, and this feature is available to service accounts with domain-wide authority.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_update_auto_forwarding_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param AutoForwarding body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: AutoForwarding
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_update_auto_forwarding" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_update_auto_forwarding`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/autoForwarding', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AutoForwarding',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_update_imap(self, user_id, **kwargs):  # noqa: E501
        """Update IMAP settings  # noqa: E501

        Update the IMAP settings for a Gmail account. This allows users to configure how email clients access their messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_update_imap(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param ImapSettings body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ImapSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_update_imap_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_update_imap_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_update_imap_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Update IMAP settings  # noqa: E501

        Update the IMAP settings for a Gmail account. This allows users to configure how email clients access their messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_update_imap_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param ImapSettings body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: ImapSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_update_imap" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_update_imap`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/imap', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ImapSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_update_language(self, user_id, **kwargs):  # noqa: E501
        """Update language settings  # noqa: E501

        Update the language settings for a Gmail account. The saved language may differ from the requested one if Gmail supports a close variant instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_update_language(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param LanguageSettings body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: LanguageSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_update_language_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_update_language_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_update_language_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Update language settings  # noqa: E501

        Update the language settings for a Gmail account. The saved language may differ from the requested one if Gmail supports a close variant instead.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_update_language_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param LanguageSettings body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: LanguageSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_update_language" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_update_language`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/language', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LanguageSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_update_pop(self, user_id, **kwargs):  # noqa: E501
        """Update POP settings  # noqa: E501

        Update the POP settings for a Gmail account. This allows users to configure how email clients download their messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_update_pop(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param PopSettings body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: PopSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_update_pop_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_update_pop_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_update_pop_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Update POP settings  # noqa: E501

        Update the POP settings for a Gmail account. This allows users to configure how email clients download their messages.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_update_pop_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param PopSettings body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: PopSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_update_pop" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_update_pop`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/pop', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PopSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_settings_update_vacation(self, user_id, **kwargs):  # noqa: E501
        """Update vacation responder settings  # noqa: E501

        Update the vacation responder settings for a Gmail account. This includes setting the message, start and end dates, and whether the responder is active.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_update_vacation(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param VacationSettings body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: VacationSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_settings_update_vacation_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_settings_update_vacation_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_settings_update_vacation_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Update vacation responder settings  # noqa: E501

        Update the vacation responder settings for a Gmail account. This includes setting the message, start and end dates, and whether the responder is active.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_settings_update_vacation_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: User's email address. The special value \"me\" can be used to indicate the authenticated user. (required)
        :param VacationSettings body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: VacationSettings
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_settings_update_vacation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_settings_update_vacation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/settings/vacation', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VacationSettings',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_stop(self, user_id, **kwargs):  # noqa: E501
        """Stop push notifications  # noqa: E501

        Disable push notifications for the specified user's Gmail account. This stops the delivery of real-time updates about mailbox changes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_stop(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_stop_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_stop_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_stop_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Stop push notifications  # noqa: E501

        Disable push notifications for the specified user's Gmail account. This stops the delivery of real-time updates about mailbox changes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_stop_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_stop" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_stop`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/stop', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_threads_delete(self, user_id, id, **kwargs):  # noqa: E501
        """Permanently delete email thread  # noqa: E501

        Permanently delete a specific email thread and all associated messages from the user's Gmail account. This action cannot be undone, so use with caution.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_threads_delete(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: ID of the Thread to delete. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_threads_delete_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_threads_delete_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_threads_delete_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Permanently delete email thread  # noqa: E501

        Permanently delete a specific email thread and all associated messages from the user's Gmail account. This action cannot be undone, so use with caution.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_threads_delete_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: ID of the Thread to delete. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_threads_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_threads_delete`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_threads_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/threads/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_threads_get(self, user_id, id, **kwargs):  # noqa: E501
        """Get email thread details  # noqa: E501

        Retrieve details of a specific email thread, including all messages within the thread. This allows viewing the entire conversation history.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_threads_get(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the thread to retrieve. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param str format: The format to return the messages in.
        :param list[str] metadata_headers: When given and format is METADATA, only include headers specified.
        :return: Thread
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_threads_get_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_threads_get_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_threads_get_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Get email thread details  # noqa: E501

        Retrieve details of a specific email thread, including all messages within the thread. This allows viewing the entire conversation history.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_threads_get_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the thread to retrieve. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param str format: The format to return the messages in.
        :param list[str] metadata_headers: When given and format is METADATA, only include headers specified.
        :return: Thread
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type', 'format', 'metadata_headers']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_threads_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_threads_get`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_threads_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'metadata_headers' in params:
            query_params.append(('metadataHeaders', params['metadata_headers']))  # noqa: E501
            collection_formats['metadataHeaders'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/threads/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Thread',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_threads_list(self, user_id, **kwargs):  # noqa: E501
        """List email threads  # noqa: E501

        Retrieve a list of email threads from the user's Gmail account. An email thread is a collection of related messages grouped together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_threads_list(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param bool include_spam_trash: Include threads from `SPAM` and `TRASH` in the results.
        :param list[str] label_ids: Only return threads with labels that match all of the specified label IDs.
        :param int max_results: Maximum number of threads to return. This field defaults to 100. The maximum allowed value for this field is 500.
        :param str page_token: Page token to retrieve a specific page of results in the list.
        :param str q: Only return threads matching the specified query. Supports the same query format as the Gmail search box. For example, `\"from:someuser@example.com rfc822msgid: is:unread\"`. Parameter cannot be used when accessing the api using the gmail.metadata scope.
        :return: ListThreadsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_threads_list_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_threads_list_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_threads_list_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """List email threads  # noqa: E501

        Retrieve a list of email threads from the user's Gmail account. An email thread is a collection of related messages grouped together.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_threads_list_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :param bool include_spam_trash: Include threads from `SPAM` and `TRASH` in the results.
        :param list[str] label_ids: Only return threads with labels that match all of the specified label IDs.
        :param int max_results: Maximum number of threads to return. This field defaults to 100. The maximum allowed value for this field is 500.
        :param str page_token: Page token to retrieve a specific page of results in the list.
        :param str q: Only return threads matching the specified query. Supports the same query format as the Gmail search box. For example, `\"from:someuser@example.com rfc822msgid: is:unread\"`. Parameter cannot be used when accessing the api using the gmail.metadata scope.
        :return: ListThreadsResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type', 'include_spam_trash', 'label_ids', 'max_results', 'page_token', 'q']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_threads_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_threads_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501
        if 'include_spam_trash' in params:
            query_params.append(('includeSpamTrash', params['include_spam_trash']))  # noqa: E501
        if 'label_ids' in params:
            query_params.append(('labelIds', params['label_ids']))  # noqa: E501
            collection_formats['labelIds'] = 'multi'  # noqa: E501
        if 'max_results' in params:
            query_params.append(('maxResults', params['max_results']))  # noqa: E501
        if 'page_token' in params:
            query_params.append(('pageToken', params['page_token']))  # noqa: E501
        if 'q' in params:
            query_params.append(('q', params['q']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/threads', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ListThreadsResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_threads_modify(self, user_id, id, **kwargs):  # noqa: E501
        """Modify thread labels  # noqa: E501

        Change the labels applied to a specific email thread. This affects all messages within the thread, allowing for organized categorization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_threads_modify(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the thread to modify. (required)
        :param ModifyThreadRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Thread
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_threads_modify_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_threads_modify_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_threads_modify_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Modify thread labels  # noqa: E501

        Change the labels applied to a specific email thread. This affects all messages within the thread, allowing for organized categorization.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_threads_modify_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the thread to modify. (required)
        :param ModifyThreadRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Thread
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_threads_modify" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_threads_modify`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_threads_modify`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/threads/{id}/modify', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Thread',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_threads_trash(self, user_id, id, **kwargs):  # noqa: E501
        """Trash email thread  # noqa: E501

        Move a specific email thread to the trash. This action applies to all messages within the thread, making them easier to recover if needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_threads_trash(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the thread to Trash. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Thread
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_threads_trash_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_threads_trash_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_threads_trash_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Trash email thread  # noqa: E501

        Move a specific email thread to the trash. This action applies to all messages within the thread, making them easier to recover if needed.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_threads_trash_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the thread to Trash. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Thread
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_threads_trash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_threads_trash`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_threads_trash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/threads/{id}/trash', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Thread',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_threads_untrash(self, user_id, id, **kwargs):  # noqa: E501
        """Untrash email thread  # noqa: E501

        Restore a specific email thread from the trash. This action applies to all messages within the thread, returning them to their original state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_threads_untrash(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the thread to remove from Trash. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Thread
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_threads_untrash_with_http_info(user_id, id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_threads_untrash_with_http_info(user_id, id, **kwargs)  # noqa: E501
            return data

    def gmail_users_threads_untrash_with_http_info(self, user_id, id, **kwargs):  # noqa: E501
        """Untrash email thread  # noqa: E501

        Restore a specific email thread from the trash. This action applies to all messages within the thread, returning them to their original state.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_threads_untrash_with_http_info(user_id, id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param str id: The ID of the thread to remove from Trash. (required)
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: Thread
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'id', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_threads_untrash" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_threads_untrash`")  # noqa: E501
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `gmail_users_threads_untrash`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/threads/{id}/untrash', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Thread',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def gmail_users_watch(self, user_id, **kwargs):  # noqa: E501
        """Set up push notification watch  # noqa: E501

        Establish or update a push notification watch on a user's Gmail account. This enables real-time notifications about changes to the mailbox.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_watch(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param WatchRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: WatchResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.gmail_users_watch_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.gmail_users_watch_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def gmail_users_watch_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Set up push notification watch  # noqa: E501

        Establish or update a push notification watch on a user's Gmail account. This enables real-time notifications about changes to the mailbox.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.gmail_users_watch_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str user_id: The user's email address. The special value `me` can be used to indicate the authenticated user. (required)
        :param WatchRequest body:
        :param str xgafv: V1 error format.
        :param str access_token: OAuth access token.
        :param str alt: Data format for response.
        :param str param_callback: JSONP
        :param str fields: Selector specifying which fields to include in a partial response.
        :param str key: API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.
        :param str oauth_token: OAuth 2.0 token for the current user.
        :param bool pretty_print: Returns response with indentations and line breaks.
        :param str quota_user: Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.
        :param str upload_protocol: Upload protocol for media (e.g. \"raw\", \"multipart\").
        :param str upload_type: Legacy upload protocol for media (e.g. \"media\", \"multipart\").
        :return: WatchResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'xgafv', 'access_token', 'alt', 'param_callback', 'fields', 'key', 'oauth_token', 'pretty_print', 'quota_user', 'upload_protocol', 'upload_type']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method gmail_users_watch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `gmail_users_watch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []
        if 'xgafv' in params:
            query_params.append(('$.xgafv', params['xgafv']))  # noqa: E501
        if 'access_token' in params:
            query_params.append(('access_token', params['access_token']))  # noqa: E501
        if 'alt' in params:
            query_params.append(('alt', params['alt']))  # noqa: E501
        if 'param_callback' in params:
            query_params.append(('callback', params['param_callback']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'key' in params:
            query_params.append(('key', params['key']))  # noqa: E501
        if 'oauth_token' in params:
            query_params.append(('oauth_token', params['oauth_token']))  # noqa: E501
        if 'pretty_print' in params:
            query_params.append(('prettyPrint', params['pretty_print']))  # noqa: E501
        if 'quota_user' in params:
            query_params.append(('quotaUser', params['quota_user']))  # noqa: E501
        if 'upload_protocol' in params:
            query_params.append(('upload_protocol', params['upload_protocol']))  # noqa: E501
        if 'upload_type' in params:
            query_params.append(('uploadType', params['upload_type']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Oauth2', 'Oauth2c']  # noqa: E501

        return self.api_client.call_api(
            '/gmail/v1/users/{userId}/watch', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='WatchResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
