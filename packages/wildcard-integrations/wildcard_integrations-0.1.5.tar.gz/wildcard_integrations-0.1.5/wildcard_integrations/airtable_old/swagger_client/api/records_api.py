# coding: utf-8

"""
    Airtable API

    OpenAPI spec for Airtable's REST API  # noqa: E501

    OpenAPI spec version: 2024-12-27
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from ..api_client import ApiClient


class RecordsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def airtable_records_create(self, body, base_id, table_id_or_name, **kwargs):  # noqa: E501
        """Create records  # noqa: E501

        Creates multiple records. Note that table names and table ids can be used interchangeably. We recommend using table IDs so you don't need to modify your API request when your table name changes.  Your request body should include an array of up to 10 record objects. Each of these objects should have one key whose value is an inner object containing your record's cell values, keyed by either field name or field id.  Returns a unique array of the newly created record ids if the call succeeds.  You can also include a single record object at the top level.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_create(body, base_id, table_id_or_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param BaseIdTableIdOrNameBody1 body: (required)
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.airtable_records_create_with_http_info(body, base_id, table_id_or_name, **kwargs)  # noqa: E501
        else:
            (data) = self.airtable_records_create_with_http_info(body, base_id, table_id_or_name, **kwargs)  # noqa: E501
            return data

    def airtable_records_create_with_http_info(self, body, base_id, table_id_or_name, **kwargs):  # noqa: E501
        """Create records  # noqa: E501

        Creates multiple records. Note that table names and table ids can be used interchangeably. We recommend using table IDs so you don't need to modify your API request when your table name changes.  Your request body should include an array of up to 10 record objects. Each of these objects should have one key whose value is an inner object containing your record's cell values, keyed by either field name or field id.  Returns a unique array of the newly created record ids if the call succeeds.  You can also include a single record object at the top level.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_create_with_http_info(body, base_id, table_id_or_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param BaseIdTableIdOrNameBody1 body: (required)
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'base_id', 'table_id_or_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method airtable_records_create" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `airtable_records_create`")  # noqa: E501
        # verify the required parameter 'base_id' is set
        if ('base_id' not in params or
                params['base_id'] is None):
            raise ValueError("Missing the required parameter `base_id` when calling `airtable_records_create`")  # noqa: E501
        # verify the required parameter 'table_id_or_name' is set
        if ('table_id_or_name' not in params or
                params['table_id_or_name'] is None):
            raise ValueError("Missing the required parameter `table_id_or_name` when calling `airtable_records_create`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'base_id' in params:
            path_params['baseId'] = params['base_id']  # noqa: E501
        if 'table_id_or_name' in params:
            path_params['tableIdOrName'] = params['table_id_or_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/{baseId}/{tableIdOrName}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def airtable_records_delete(self, base_id, table_id_or_name, record_id, **kwargs):  # noqa: E501
        """Delete record  # noqa: E501

        Deletes a single record  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_delete(base_id, table_id_or_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :param str record_id: (required)
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.airtable_records_delete_with_http_info(base_id, table_id_or_name, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.airtable_records_delete_with_http_info(base_id, table_id_or_name, record_id, **kwargs)  # noqa: E501
            return data

    def airtable_records_delete_with_http_info(self, base_id, table_id_or_name, record_id, **kwargs):  # noqa: E501
        """Delete record  # noqa: E501

        Deletes a single record  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_delete_with_http_info(base_id, table_id_or_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :param str record_id: (required)
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['base_id', 'table_id_or_name', 'record_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method airtable_records_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'base_id' is set
        if ('base_id' not in params or
                params['base_id'] is None):
            raise ValueError("Missing the required parameter `base_id` when calling `airtable_records_delete`")  # noqa: E501
        # verify the required parameter 'table_id_or_name' is set
        if ('table_id_or_name' not in params or
                params['table_id_or_name'] is None):
            raise ValueError("Missing the required parameter `table_id_or_name` when calling `airtable_records_delete`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `airtable_records_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'base_id' in params:
            path_params['baseId'] = params['base_id']  # noqa: E501
        if 'table_id_or_name' in params:
            path_params['tableIdOrName'] = params['table_id_or_name']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/{baseId}/{tableIdOrName}/{recordId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def airtable_records_delete_multiple(self, base_id, table_id_or_name, **kwargs):  # noqa: E501
        """Delete multiple records  # noqa: E501

        Deletes records given an array of record ids  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_delete_multiple(base_id, table_id_or_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :param list[str] records: The recordIds of each record to be deleted. Up to 10 recordIds can be provided.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.airtable_records_delete_multiple_with_http_info(base_id, table_id_or_name, **kwargs)  # noqa: E501
        else:
            (data) = self.airtable_records_delete_multiple_with_http_info(base_id, table_id_or_name, **kwargs)  # noqa: E501
            return data

    def airtable_records_delete_multiple_with_http_info(self, base_id, table_id_or_name, **kwargs):  # noqa: E501
        """Delete multiple records  # noqa: E501

        Deletes records given an array of record ids  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_delete_multiple_with_http_info(base_id, table_id_or_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :param list[str] records: The recordIds of each record to be deleted. Up to 10 recordIds can be provided.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['base_id', 'table_id_or_name', 'records']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method airtable_records_delete_multiple" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'base_id' is set
        if ('base_id' not in params or
                params['base_id'] is None):
            raise ValueError("Missing the required parameter `base_id` when calling `airtable_records_delete_multiple`")  # noqa: E501
        # verify the required parameter 'table_id_or_name' is set
        if ('table_id_or_name' not in params or
                params['table_id_or_name'] is None):
            raise ValueError("Missing the required parameter `table_id_or_name` when calling `airtable_records_delete_multiple`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'base_id' in params:
            path_params['baseId'] = params['base_id']  # noqa: E501
        if 'table_id_or_name' in params:
            path_params['tableIdOrName'] = params['table_id_or_name']  # noqa: E501

        query_params = []
        if 'records' in params:
            query_params.append(('records', params['records']))  # noqa: E501
            collection_formats['records'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/{baseId}/{tableIdOrName}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def airtable_records_get(self, base_id, table_id_or_name, record_id, **kwargs):  # noqa: E501
        """Get record  # noqa: E501

        Retrieve a single record. Any \"empty\" fields (e.g. \"\", [], or false) in the record will not be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_get(base_id, table_id_or_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :param str record_id: (required)
        :param str cell_format: The format that should be used for cell values. Supported values are:  json: cells will be formatted as JSON, depending on the field type. string: cells will be formatted as user-facing strings, regardless of the field type. The timeZone and userLocale parameters are required when using string as the cellFormat. Note: You should not rely on the format of these strings, as it is subject to change.  The default is json. 
        :param bool return_fields_by_field_id: An optional boolean value that lets you return field objects where the key is the field id. This defaults to false, which returns field objects where the key is the field name.
        :return: RecordResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.airtable_records_get_with_http_info(base_id, table_id_or_name, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.airtable_records_get_with_http_info(base_id, table_id_or_name, record_id, **kwargs)  # noqa: E501
            return data

    def airtable_records_get_with_http_info(self, base_id, table_id_or_name, record_id, **kwargs):  # noqa: E501
        """Get record  # noqa: E501

        Retrieve a single record. Any \"empty\" fields (e.g. \"\", [], or false) in the record will not be returned.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_get_with_http_info(base_id, table_id_or_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :param str record_id: (required)
        :param str cell_format: The format that should be used for cell values. Supported values are:  json: cells will be formatted as JSON, depending on the field type. string: cells will be formatted as user-facing strings, regardless of the field type. The timeZone and userLocale parameters are required when using string as the cellFormat. Note: You should not rely on the format of these strings, as it is subject to change.  The default is json. 
        :param bool return_fields_by_field_id: An optional boolean value that lets you return field objects where the key is the field id. This defaults to false, which returns field objects where the key is the field name.
        :return: RecordResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['base_id', 'table_id_or_name', 'record_id', 'cell_format', 'return_fields_by_field_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method airtable_records_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'base_id' is set
        if ('base_id' not in params or
                params['base_id'] is None):
            raise ValueError("Missing the required parameter `base_id` when calling `airtable_records_get`")  # noqa: E501
        # verify the required parameter 'table_id_or_name' is set
        if ('table_id_or_name' not in params or
                params['table_id_or_name'] is None):
            raise ValueError("Missing the required parameter `table_id_or_name` when calling `airtable_records_get`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `airtable_records_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'base_id' in params:
            path_params['baseId'] = params['base_id']  # noqa: E501
        if 'table_id_or_name' in params:
            path_params['tableIdOrName'] = params['table_id_or_name']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []
        if 'cell_format' in params:
            query_params.append(('cellFormat', params['cell_format']))  # noqa: E501
        if 'return_fields_by_field_id' in params:
            query_params.append(('returnFieldsByFieldId', params['return_fields_by_field_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/{baseId}/{tableIdOrName}/{recordId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RecordResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def airtable_records_list(self, base_id, table_id_or_name, **kwargs):  # noqa: E501
        """List records  # noqa: E501

        List records in a table. Table names and IDs can be used interchangeably, though using IDs is recommended to avoid issues if table names change. The API returns records with a default `pageSize` of 100. To fetch subsequent pages use the `offset` parameter. Pagination ends when reaching the table end or maxRecords limit if specified. Empty field values (\"\", [], false) are omitted from returned records. Results can be filtered, sorted and formatted using URL-encoded query parameters. The API URL length is limited to 16,000 characters. For longer requests with encoded formulas, use POST to /v0/{baseId}/{tableIdOrName}/listRecords with parameters in the request body instead of query parameters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_list(base_id, table_id_or_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :param str time_zone: The time zone that should be used to format dates when using string as the cellFormat. This parameter is required when using string as the cellFormat.
        :param str user_locale: The user locale that should be used to format dates when using string as the cellFormat. This parameter is required when using string as the cellFormat.
        :param int page_size: The number of records returned in each request. Must be less than or equal to 100. Default is 100.
        :param int max_records: The maximum total number of records that will be returned in your requests. If this value is larger than pageSize (which is 100 by default), you may have to load multiple pages to reach this total.
        :param str offset: To fetch the next page of records, include offset from the previous request in the next request's parameters.
        :param str view: The name or ID of a view in the table. If set, only the records in that view will be returned. The records will be sorted according to the order of the view unless the sort parameter is included, which overrides that order. Fields hidden in this view will be returned in the results. To only return a subset of fields, use the fields parameter.
        :param list[Sort] sort: A list of sort objects that specifies how the records will be ordered. Each sort object must have a field key specifying the name of the field to sort on, and an optional direction key that is either \"asc\" or \"desc\". The default direction is \"asc\".  The sort parameter overrides the sorting of the view specified in the view parameter. If neither the sort nor the view parameter is included, the order of records is arbitrary. 
        :param str filter_by_formula: A formula used to filter records. The formula will be evaluated for each record, and if the result is not 0, false, \"\", NaN, [], or #Error! the record will be included in the response. We recommend testing your formula in the Formula field UI before using it in your API request. If combined with the view parameter, only records in that view which satisfy the formula will be returned. The formula must be encoded first before passing it as a value. You can use this tool to not only encode the formula but also create the entire url you need. Formulas can use field names, or field id's inside of the formula. Note Airtable's API only accepts request with a URL shorter than 16,000 characters. Encoded formulas may cause your requests to exceed this limit. To fix this issue you can instead make a POST request to /v0/{baseId}/{tableIdOrName}/listRecords while passing the parameters within the body of the request instead of the query parameters. 
        :param str cell_format: The format that should be used for cell values. Supported values are:  json: cells will be formatted as JSON, depending on the field type. string: cells will be formatted as user-facing strings, regardless of the field type. The timeZone and userLocale parameters are required when using string as the cellFormat.  Note: You should not rely on the format of these strings, as it is subject to change.  The default is json. 
        :param list[str] fields: Only data for fields whose names or IDs are in this list will be included in the result. If you don't need every field, you can use this parameter to reduce the amount of data transferred.  Note Airtable's API only accepts request with a URL shorter than 16,000 characters. Encoded formulas may cause your requests to exceed this limit. To fix this issue you can instead make a POST request to /v0/{baseId}/{tableIdOrName}/listRecords while passing the parameters within the body of the request instead of the query parameters. 
        :param bool return_fields_by_field_id: An optional boolean value that lets you return field objects where the key is the field id. This defaults to false, which returns field objects where the key is the field name.
        :param list[str] record_metadata: An optional field that, if specified, includes commentCount on each record returned.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.airtable_records_list_with_http_info(base_id, table_id_or_name, **kwargs)  # noqa: E501
        else:
            (data) = self.airtable_records_list_with_http_info(base_id, table_id_or_name, **kwargs)  # noqa: E501
            return data

    def airtable_records_list_with_http_info(self, base_id, table_id_or_name, **kwargs):  # noqa: E501
        """List records  # noqa: E501

        List records in a table. Table names and IDs can be used interchangeably, though using IDs is recommended to avoid issues if table names change. The API returns records with a default `pageSize` of 100. To fetch subsequent pages use the `offset` parameter. Pagination ends when reaching the table end or maxRecords limit if specified. Empty field values (\"\", [], false) are omitted from returned records. Results can be filtered, sorted and formatted using URL-encoded query parameters. The API URL length is limited to 16,000 characters. For longer requests with encoded formulas, use POST to /v0/{baseId}/{tableIdOrName}/listRecords with parameters in the request body instead of query parameters.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_list_with_http_info(base_id, table_id_or_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :param str time_zone: The time zone that should be used to format dates when using string as the cellFormat. This parameter is required when using string as the cellFormat.
        :param str user_locale: The user locale that should be used to format dates when using string as the cellFormat. This parameter is required when using string as the cellFormat.
        :param int page_size: The number of records returned in each request. Must be less than or equal to 100. Default is 100.
        :param int max_records: The maximum total number of records that will be returned in your requests. If this value is larger than pageSize (which is 100 by default), you may have to load multiple pages to reach this total.
        :param str offset: To fetch the next page of records, include offset from the previous request in the next request's parameters.
        :param str view: The name or ID of a view in the table. If set, only the records in that view will be returned. The records will be sorted according to the order of the view unless the sort parameter is included, which overrides that order. Fields hidden in this view will be returned in the results. To only return a subset of fields, use the fields parameter.
        :param list[Sort] sort: A list of sort objects that specifies how the records will be ordered. Each sort object must have a field key specifying the name of the field to sort on, and an optional direction key that is either \"asc\" or \"desc\". The default direction is \"asc\".  The sort parameter overrides the sorting of the view specified in the view parameter. If neither the sort nor the view parameter is included, the order of records is arbitrary. 
        :param str filter_by_formula: A formula used to filter records. The formula will be evaluated for each record, and if the result is not 0, false, \"\", NaN, [], or #Error! the record will be included in the response. We recommend testing your formula in the Formula field UI before using it in your API request. If combined with the view parameter, only records in that view which satisfy the formula will be returned. The formula must be encoded first before passing it as a value. You can use this tool to not only encode the formula but also create the entire url you need. Formulas can use field names, or field id's inside of the formula. Note Airtable's API only accepts request with a URL shorter than 16,000 characters. Encoded formulas may cause your requests to exceed this limit. To fix this issue you can instead make a POST request to /v0/{baseId}/{tableIdOrName}/listRecords while passing the parameters within the body of the request instead of the query parameters. 
        :param str cell_format: The format that should be used for cell values. Supported values are:  json: cells will be formatted as JSON, depending on the field type. string: cells will be formatted as user-facing strings, regardless of the field type. The timeZone and userLocale parameters are required when using string as the cellFormat.  Note: You should not rely on the format of these strings, as it is subject to change.  The default is json. 
        :param list[str] fields: Only data for fields whose names or IDs are in this list will be included in the result. If you don't need every field, you can use this parameter to reduce the amount of data transferred.  Note Airtable's API only accepts request with a URL shorter than 16,000 characters. Encoded formulas may cause your requests to exceed this limit. To fix this issue you can instead make a POST request to /v0/{baseId}/{tableIdOrName}/listRecords while passing the parameters within the body of the request instead of the query parameters. 
        :param bool return_fields_by_field_id: An optional boolean value that lets you return field objects where the key is the field id. This defaults to false, which returns field objects where the key is the field name.
        :param list[str] record_metadata: An optional field that, if specified, includes commentCount on each record returned.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['base_id', 'table_id_or_name', 'time_zone', 'user_locale', 'page_size', 'max_records', 'offset', 'view', 'sort', 'filter_by_formula', 'cell_format', 'fields', 'return_fields_by_field_id', 'record_metadata']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method airtable_records_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'base_id' is set
        if ('base_id' not in params or
                params['base_id'] is None):
            raise ValueError("Missing the required parameter `base_id` when calling `airtable_records_list`")  # noqa: E501
        # verify the required parameter 'table_id_or_name' is set
        if ('table_id_or_name' not in params or
                params['table_id_or_name'] is None):
            raise ValueError("Missing the required parameter `table_id_or_name` when calling `airtable_records_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'base_id' in params:
            path_params['baseId'] = params['base_id']  # noqa: E501
        if 'table_id_or_name' in params:
            path_params['tableIdOrName'] = params['table_id_or_name']  # noqa: E501

        query_params = []
        if 'time_zone' in params:
            query_params.append(('timeZone', params['time_zone']))  # noqa: E501
        if 'user_locale' in params:
            query_params.append(('userLocale', params['user_locale']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'max_records' in params:
            query_params.append(('maxRecords', params['max_records']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
            collection_formats['sort'] = 'multi'  # noqa: E501
        if 'filter_by_formula' in params:
            query_params.append(('filterByFormula', params['filter_by_formula']))  # noqa: E501
        if 'cell_format' in params:
            query_params.append(('cellFormat', params['cell_format']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
            collection_formats['fields'] = 'multi'  # noqa: E501
        if 'return_fields_by_field_id' in params:
            query_params.append(('returnFieldsByFieldId', params['return_fields_by_field_id']))  # noqa: E501
        if 'record_metadata' in params:
            query_params.append(('recordMetadata', params['record_metadata']))  # noqa: E501
            collection_formats['recordMetadata'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/{baseId}/{tableIdOrName}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def airtable_records_replace(self, body, base_id, table_id_or_name, record_id, **kwargs):  # noqa: E501
        """Replace record  # noqa: E501

        Updates a single record. Table names and table ids can be used interchangeably. We recommend using table IDs so you don't need to modify your API request when your table name changes. A PUT request will perform a destructive update and clear all unspecified cell values. A PATCH request will only update the fields you specify, leaving the rest as they were.  Your request body should include a fields property whose value is an object containing your record's cell values, keyed by either field name or field id.  Automatic data conversion for update actions can be enabled via typecast parameter. The Airtable API will perform best-effort automatic data conversion from string values if the typecast parameter is passed in. Automatic conversion is disabled by default to ensure data integrity, but it may be helpful for integrating with 3rd party data sources.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_replace(body, base_id, table_id_or_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param TableIdOrNameRecordIdBody body: (required)
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :param str record_id: (required)
        :return: RecordResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.airtable_records_replace_with_http_info(body, base_id, table_id_or_name, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.airtable_records_replace_with_http_info(body, base_id, table_id_or_name, record_id, **kwargs)  # noqa: E501
            return data

    def airtable_records_replace_with_http_info(self, body, base_id, table_id_or_name, record_id, **kwargs):  # noqa: E501
        """Replace record  # noqa: E501

        Updates a single record. Table names and table ids can be used interchangeably. We recommend using table IDs so you don't need to modify your API request when your table name changes. A PUT request will perform a destructive update and clear all unspecified cell values. A PATCH request will only update the fields you specify, leaving the rest as they were.  Your request body should include a fields property whose value is an object containing your record's cell values, keyed by either field name or field id.  Automatic data conversion for update actions can be enabled via typecast parameter. The Airtable API will perform best-effort automatic data conversion from string values if the typecast parameter is passed in. Automatic conversion is disabled by default to ensure data integrity, but it may be helpful for integrating with 3rd party data sources.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_replace_with_http_info(body, base_id, table_id_or_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param TableIdOrNameRecordIdBody body: (required)
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :param str record_id: (required)
        :return: RecordResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'base_id', 'table_id_or_name', 'record_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method airtable_records_replace" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `airtable_records_replace`")  # noqa: E501
        # verify the required parameter 'base_id' is set
        if ('base_id' not in params or
                params['base_id'] is None):
            raise ValueError("Missing the required parameter `base_id` when calling `airtable_records_replace`")  # noqa: E501
        # verify the required parameter 'table_id_or_name' is set
        if ('table_id_or_name' not in params or
                params['table_id_or_name'] is None):
            raise ValueError("Missing the required parameter `table_id_or_name` when calling `airtable_records_replace`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `airtable_records_replace`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'base_id' in params:
            path_params['baseId'] = params['base_id']  # noqa: E501
        if 'table_id_or_name' in params:
            path_params['tableIdOrName'] = params['table_id_or_name']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/{baseId}/{tableIdOrName}/{recordId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RecordResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def airtable_records_replace_multiple(self, body, base_id, table_id_or_name, **kwargs):  # noqa: E501
        """Replace multiple records  # noqa: E501

        Updates up to 10 records. Use table IDs instead of names for stability.  This PUT methods CLEARS all unspecified values. If this is not what you want, use PATCH instead.  Upserts (enabled via performUpsert): - Makes record id optional - Uses fieldsToMergeOn fields as external ID to match records - Creates new record if no match found - Updates record if one match found - Fails if multiple matches found - Records with id ignore fieldsToMergeOn and follow normal update behavior - Response includes updatedRecords and createdRecords arrays - May be throttled differently than standard requests  Typecasting (enabled via typecast parameter): - Attempts to convert string values to appropriate cell types - Best-effort conversion only - Disabled by default to protect data integrity - Useful for third-party integrations   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_replace_multiple(body, base_id, table_id_or_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param BaseIdTableIdOrNameBody body: (required)
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.airtable_records_replace_multiple_with_http_info(body, base_id, table_id_or_name, **kwargs)  # noqa: E501
        else:
            (data) = self.airtable_records_replace_multiple_with_http_info(body, base_id, table_id_or_name, **kwargs)  # noqa: E501
            return data

    def airtable_records_replace_multiple_with_http_info(self, body, base_id, table_id_or_name, **kwargs):  # noqa: E501
        """Replace multiple records  # noqa: E501

        Updates up to 10 records. Use table IDs instead of names for stability.  This PUT methods CLEARS all unspecified values. If this is not what you want, use PATCH instead.  Upserts (enabled via performUpsert): - Makes record id optional - Uses fieldsToMergeOn fields as external ID to match records - Creates new record if no match found - Updates record if one match found - Fails if multiple matches found - Records with id ignore fieldsToMergeOn and follow normal update behavior - Response includes updatedRecords and createdRecords arrays - May be throttled differently than standard requests  Typecasting (enabled via typecast parameter): - Attempts to convert string values to appropriate cell types - Best-effort conversion only - Disabled by default to protect data integrity - Useful for third-party integrations   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_replace_multiple_with_http_info(body, base_id, table_id_or_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param BaseIdTableIdOrNameBody body: (required)
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'base_id', 'table_id_or_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method airtable_records_replace_multiple" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `airtable_records_replace_multiple`")  # noqa: E501
        # verify the required parameter 'base_id' is set
        if ('base_id' not in params or
                params['base_id'] is None):
            raise ValueError("Missing the required parameter `base_id` when calling `airtable_records_replace_multiple`")  # noqa: E501
        # verify the required parameter 'table_id_or_name' is set
        if ('table_id_or_name' not in params or
                params['table_id_or_name'] is None):
            raise ValueError("Missing the required parameter `table_id_or_name` when calling `airtable_records_replace_multiple`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'base_id' in params:
            path_params['baseId'] = params['base_id']  # noqa: E501
        if 'table_id_or_name' in params:
            path_params['tableIdOrName'] = params['table_id_or_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/{baseId}/{tableIdOrName}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def airtable_records_sync_csv(self, body, base_id, table_id_or_name, api_endpoint_sync_id, **kwargs):  # noqa: E501
        """Sync CSV data  # noqa: E501

        Syncs raw CSV data into a Sync API table. You must first set up a sync from a base (instructions in this support article). The apiEndpointSyncId in the path parameters can be found in the setup flow when creating a new Sync API table, or from the synced table settings.  The CSV data can contain up to 10k rows, 500 columns, and the HTTP request's size is limited to 2 MB.  There is a rate limit of 20 requests, per 5 minutes, per base for this endpoint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_sync_csv(body, base_id, table_id_or_name, api_endpoint_sync_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str body: (required)
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :param str api_endpoint_sync_id: (required)
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.airtable_records_sync_csv_with_http_info(body, base_id, table_id_or_name, api_endpoint_sync_id, **kwargs)  # noqa: E501
        else:
            (data) = self.airtable_records_sync_csv_with_http_info(body, base_id, table_id_or_name, api_endpoint_sync_id, **kwargs)  # noqa: E501
            return data

    def airtable_records_sync_csv_with_http_info(self, body, base_id, table_id_or_name, api_endpoint_sync_id, **kwargs):  # noqa: E501
        """Sync CSV data  # noqa: E501

        Syncs raw CSV data into a Sync API table. You must first set up a sync from a base (instructions in this support article). The apiEndpointSyncId in the path parameters can be found in the setup flow when creating a new Sync API table, or from the synced table settings.  The CSV data can contain up to 10k rows, 500 columns, and the HTTP request's size is limited to 2 MB.  There is a rate limit of 20 requests, per 5 minutes, per base for this endpoint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_sync_csv_with_http_info(body, base_id, table_id_or_name, api_endpoint_sync_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param str body: (required)
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :param str api_endpoint_sync_id: (required)
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'base_id', 'table_id_or_name', 'api_endpoint_sync_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method airtable_records_sync_csv" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `airtable_records_sync_csv`")  # noqa: E501
        # verify the required parameter 'base_id' is set
        if ('base_id' not in params or
                params['base_id'] is None):
            raise ValueError("Missing the required parameter `base_id` when calling `airtable_records_sync_csv`")  # noqa: E501
        # verify the required parameter 'table_id_or_name' is set
        if ('table_id_or_name' not in params or
                params['table_id_or_name'] is None):
            raise ValueError("Missing the required parameter `table_id_or_name` when calling `airtable_records_sync_csv`")  # noqa: E501
        # verify the required parameter 'api_endpoint_sync_id' is set
        if ('api_endpoint_sync_id' not in params or
                params['api_endpoint_sync_id'] is None):
            raise ValueError("Missing the required parameter `api_endpoint_sync_id` when calling `airtable_records_sync_csv`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'base_id' in params:
            path_params['baseId'] = params['base_id']  # noqa: E501
        if 'table_id_or_name' in params:
            path_params['tableIdOrName'] = params['table_id_or_name']  # noqa: E501
        if 'api_endpoint_sync_id' in params:
            path_params['apiEndpointSyncId'] = params['api_endpoint_sync_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['text/csv'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/{baseId}/{tableIdOrName}/sync/{apiEndpointSyncId}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def airtable_records_update(self, body, base_id, table_id_or_name, record_id, **kwargs):  # noqa: E501
        """Update record  # noqa: E501

        Updates a single record. Table names and table ids can be used interchangeably. We recommend using table IDs so you don't need to modify your API request when your table name changes. A PATCH request will only update the fields you specify, leaving the rest as they were. A PUT request will perform a destructive update and clear all unspecified cell values.  Your request body should include a fields property whose value is an object containing your record's cell values, keyed by either field name or field id.  Automatic data conversion for update actions can be enabled via typecast parameter. The Airtable API will perform best-effort automatic data conversion from string values if the typecast parameter is passed in. Automatic conversion is disabled by default to ensure data integrity, but it may be helpful for integrating with 3rd party data sources.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_update(body, base_id, table_id_or_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param TableIdOrNameRecordIdBody1 body: (required)
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :param str record_id: (required)
        :return: RecordResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.airtable_records_update_with_http_info(body, base_id, table_id_or_name, record_id, **kwargs)  # noqa: E501
        else:
            (data) = self.airtable_records_update_with_http_info(body, base_id, table_id_or_name, record_id, **kwargs)  # noqa: E501
            return data

    def airtable_records_update_with_http_info(self, body, base_id, table_id_or_name, record_id, **kwargs):  # noqa: E501
        """Update record  # noqa: E501

        Updates a single record. Table names and table ids can be used interchangeably. We recommend using table IDs so you don't need to modify your API request when your table name changes. A PATCH request will only update the fields you specify, leaving the rest as they were. A PUT request will perform a destructive update and clear all unspecified cell values.  Your request body should include a fields property whose value is an object containing your record's cell values, keyed by either field name or field id.  Automatic data conversion for update actions can be enabled via typecast parameter. The Airtable API will perform best-effort automatic data conversion from string values if the typecast parameter is passed in. Automatic conversion is disabled by default to ensure data integrity, but it may be helpful for integrating with 3rd party data sources.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_update_with_http_info(body, base_id, table_id_or_name, record_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param TableIdOrNameRecordIdBody1 body: (required)
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :param str record_id: (required)
        :return: RecordResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'base_id', 'table_id_or_name', 'record_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method airtable_records_update" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `airtable_records_update`")  # noqa: E501
        # verify the required parameter 'base_id' is set
        if ('base_id' not in params or
                params['base_id'] is None):
            raise ValueError("Missing the required parameter `base_id` when calling `airtable_records_update`")  # noqa: E501
        # verify the required parameter 'table_id_or_name' is set
        if ('table_id_or_name' not in params or
                params['table_id_or_name'] is None):
            raise ValueError("Missing the required parameter `table_id_or_name` when calling `airtable_records_update`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `airtable_records_update`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'base_id' in params:
            path_params['baseId'] = params['base_id']  # noqa: E501
        if 'table_id_or_name' in params:
            path_params['tableIdOrName'] = params['table_id_or_name']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/{baseId}/{tableIdOrName}/{recordId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RecordResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def airtable_records_update_multiple(self, body, base_id, table_id_or_name, **kwargs):  # noqa: E501
        """Update multiple records  # noqa: E501

        Updates up to 10 records or upserts them when `performUpsert` is set. The URL path accepts both table names and table IDs. - **PATCH Request:** Updates only the fields included in the request; other fields remain unchanged.  **Upserts:** - Enable Upserts by setting `performUpsert` to `true`. - When upserting, the `id` property is optional. Records without `id` use `fieldsToMergeOn` to match existing records.   - **0 matches:** Creates a new record.   - **1 match:** Updates the existing record.   - **Multiple matches:** Request fails. - Records with `id` ignore `fieldsToMergeOn` and follow normal update behavior. If the `id` doesn't exist, the request fails without creating a new record. - The response includes `updatedRecords` and `createdRecords` arrays to indicate the status of each record. - Upsert requests may be throttled differently from standard rate limits.  **Typecasting:** - Enable by setting `typecast` to `true`. - Attempts to convert string values to appropriate cell types on a best-effort basis. - Disabled by default. - Useful for third-party integrations   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_update_multiple(body, base_id, table_id_or_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param BaseIdTableIdOrNameBody2 body: (required)
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.airtable_records_update_multiple_with_http_info(body, base_id, table_id_or_name, **kwargs)  # noqa: E501
        else:
            (data) = self.airtable_records_update_multiple_with_http_info(body, base_id, table_id_or_name, **kwargs)  # noqa: E501
            return data

    def airtable_records_update_multiple_with_http_info(self, body, base_id, table_id_or_name, **kwargs):  # noqa: E501
        """Update multiple records  # noqa: E501

        Updates up to 10 records or upserts them when `performUpsert` is set. The URL path accepts both table names and table IDs. - **PATCH Request:** Updates only the fields included in the request; other fields remain unchanged.  **Upserts:** - Enable Upserts by setting `performUpsert` to `true`. - When upserting, the `id` property is optional. Records without `id` use `fieldsToMergeOn` to match existing records.   - **0 matches:** Creates a new record.   - **1 match:** Updates the existing record.   - **Multiple matches:** Request fails. - Records with `id` ignore `fieldsToMergeOn` and follow normal update behavior. If the `id` doesn't exist, the request fails without creating a new record. - The response includes `updatedRecords` and `createdRecords` arrays to indicate the status of each record. - Upsert requests may be throttled differently from standard rate limits.  **Typecasting:** - Enable by setting `typecast` to `true`. - Attempts to convert string values to appropriate cell types on a best-effort basis. - Disabled by default. - Useful for third-party integrations   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_update_multiple_with_http_info(body, base_id, table_id_or_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param BaseIdTableIdOrNameBody2 body: (required)
        :param str base_id: (required)
        :param str table_id_or_name: (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'base_id', 'table_id_or_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method airtable_records_update_multiple" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `airtable_records_update_multiple`")  # noqa: E501
        # verify the required parameter 'base_id' is set
        if ('base_id' not in params or
                params['base_id'] is None):
            raise ValueError("Missing the required parameter `base_id` when calling `airtable_records_update_multiple`")  # noqa: E501
        # verify the required parameter 'table_id_or_name' is set
        if ('table_id_or_name' not in params or
                params['table_id_or_name'] is None):
            raise ValueError("Missing the required parameter `table_id_or_name` when calling `airtable_records_update_multiple`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'base_id' in params:
            path_params['baseId'] = params['base_id']  # noqa: E501
        if 'table_id_or_name' in params:
            path_params['tableIdOrName'] = params['table_id_or_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/{baseId}/{tableIdOrName}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def airtable_records_upload_attachment(self, body, base_id, record_id, attachment_field_id_or_name, **kwargs):  # noqa: E501
        """Upload attachment  # noqa: E501

        Upload an attachment up to 5 MB to an attachment cell via the file bytes directly.  To upload attachments above this size that are accessible by a public URL, they can be added using  https://airtable.com/developers/web/api/field-model#multipleattachment   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_upload_attachment(body, base_id, record_id, attachment_field_id_or_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param AttachmentFieldIdOrNameUploadAttachmentBody body: (required)
        :param str base_id: (required)
        :param str record_id: (required)
        :param str attachment_field_id_or_name: (required)
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.airtable_records_upload_attachment_with_http_info(body, base_id, record_id, attachment_field_id_or_name, **kwargs)  # noqa: E501
        else:
            (data) = self.airtable_records_upload_attachment_with_http_info(body, base_id, record_id, attachment_field_id_or_name, **kwargs)  # noqa: E501
            return data

    def airtable_records_upload_attachment_with_http_info(self, body, base_id, record_id, attachment_field_id_or_name, **kwargs):  # noqa: E501
        """Upload attachment  # noqa: E501

        Upload an attachment up to 5 MB to an attachment cell via the file bytes directly.  To upload attachments above this size that are accessible by a public URL, they can be added using  https://airtable.com/developers/web/api/field-model#multipleattachment   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.airtable_records_upload_attachment_with_http_info(body, base_id, record_id, attachment_field_id_or_name, async_req=True)
        >>> result = thread.get()

        :param async_req bool:
        :param AttachmentFieldIdOrNameUploadAttachmentBody body: (required)
        :param str base_id: (required)
        :param str record_id: (required)
        :param str attachment_field_id_or_name: (required)
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'base_id', 'record_id', 'attachment_field_id_or_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method airtable_records_upload_attachment" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `airtable_records_upload_attachment`")  # noqa: E501
        # verify the required parameter 'base_id' is set
        if ('base_id' not in params or
                params['base_id'] is None):
            raise ValueError("Missing the required parameter `base_id` when calling `airtable_records_upload_attachment`")  # noqa: E501
        # verify the required parameter 'record_id' is set
        if ('record_id' not in params or
                params['record_id'] is None):
            raise ValueError("Missing the required parameter `record_id` when calling `airtable_records_upload_attachment`")  # noqa: E501
        # verify the required parameter 'attachment_field_id_or_name' is set
        if ('attachment_field_id_or_name' not in params or
                params['attachment_field_id_or_name'] is None):
            raise ValueError("Missing the required parameter `attachment_field_id_or_name` when calling `airtable_records_upload_attachment`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'base_id' in params:
            path_params['baseId'] = params['base_id']  # noqa: E501
        if 'record_id' in params:
            path_params['recordId'] = params['record_id']  # noqa: E501
        if 'attachment_field_id_or_name' in params:
            path_params['attachmentFieldIdOrName'] = params['attachment_field_id_or_name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth', 'Oauth2']  # noqa: E501

        return self.api_client.call_api(
            '/content.airtable.com/v0/{baseId}/{recordId}/{attachmentFieldIdOrName}/uploadAttachment', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
