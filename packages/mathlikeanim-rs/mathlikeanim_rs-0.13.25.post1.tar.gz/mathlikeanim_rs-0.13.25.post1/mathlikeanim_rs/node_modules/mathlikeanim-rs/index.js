let wasm;

const cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };

let cachedUint8ArrayMemory0 = null;

function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}

function addToExternrefTable0(obj) {
    const idx = wasm.__externref_table_alloc();
    wasm.__wbindgen_export_2.set(idx, obj);
    return idx;
}

function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        const idx = addToExternrefTable0(e);
        wasm.__wbindgen_exn_store(idx);
    }
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

const CLOSURE_DTORS = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(state => {
    wasm.__wbindgen_export_3.get(state.dtor)(state.a, state.b)
});

function makeClosure(arg0, arg1, dtor, f) {
    const state = { a: arg0, b: arg1, cnt: 1, dtor };
    const real = (...args) => {
        // First up with a closure we increment the internal reference
        // count. This ensures that the Rust closure environment won't
        // be deallocated while we're invoking it.
        state.cnt++;
        try {
            return f(state.a, state.b, ...args);
        } finally {
            if (--state.cnt === 0) {
                wasm.__wbindgen_export_3.get(state.dtor)(state.a, state.b);
                state.a = 0;
                CLOSURE_DTORS.unregister(state);
            }
        }
    };
    real.original = state;
    CLOSURE_DTORS.register(real, state, state);
    return real;
}

function makeMutClosure(arg0, arg1, dtor, f) {
    const state = { a: arg0, b: arg1, cnt: 1, dtor };
    const real = (...args) => {
        // First up with a closure we increment the internal reference
        // count. This ensures that the Rust closure environment won't
        // be deallocated while we're invoking it.
        state.cnt++;
        const a = state.a;
        state.a = 0;
        try {
            return f(a, state.b, ...args);
        } finally {
            if (--state.cnt === 0) {
                wasm.__wbindgen_export_3.get(state.dtor)(a, state.b);
                CLOSURE_DTORS.unregister(state);
            } else {
                state.a = a;
            }
        }
    };
    real.original = state;
    CLOSURE_DTORS.register(real, state, state);
    return real;
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches && builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

let WASM_VECTOR_LEN = 0;

const cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length, 1) >>> 0;
        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;

    const mem = getUint8ArrayMemory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

let cachedDataViewMemory0 = null;

function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {
        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
    }
    return cachedDataViewMemory0;
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
}

function passArrayJsValueToWasm0(array, malloc) {
    const ptr = malloc(array.length * 4, 4) >>> 0;
    const mem = getDataViewMemory0();
    for (let i = 0; i < array.length; i++) {
        mem.setUint32(ptr + 4 * i, addToExternrefTable0(array[i]), true);
    }
    WASM_VECTOR_LEN = array.length;
    return ptr;
}

function getArrayJsValueFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    const mem = getDataViewMemory0();
    const result = [];
    for (let i = ptr; i < ptr + 4 * len; i += 4) {
        result.push(wasm.__wbindgen_export_2.get(mem.getUint32(i, true)));
    }
    wasm.__externref_drop_slice(ptr, len);
    return result;
}

let cachedFloat64ArrayMemory0 = null;

function getFloat64ArrayMemory0() {
    if (cachedFloat64ArrayMemory0 === null || cachedFloat64ArrayMemory0.byteLength === 0) {
        cachedFloat64ArrayMemory0 = new Float64Array(wasm.memory.buffer);
    }
    return cachedFloat64ArrayMemory0;
}

function getArrayF64FromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return getFloat64ArrayMemory0().subarray(ptr / 8, ptr / 8 + len);
}
/**
 * @param {WasmVectorObject} shape
 * @param {number | undefined} [num_dashes]
 * @param {number | undefined} [dashed_ratio]
 * @param {number | undefined} [dash_offset]
 * @param {boolean | undefined} [equal_lengths]
 * @returns {WasmVectorObject}
 */
export function dashedObject(shape, num_dashes, dashed_ratio, dash_offset, equal_lengths) {
    _assertClass(shape, WasmVectorObject);
    const ret = wasm.dashedObject(shape.__wbg_ptr, isLikeNone(num_dashes) ? 0x100000001 : (num_dashes) >>> 0, !isLikeNone(dashed_ratio), isLikeNone(dashed_ratio) ? 0 : dashed_ratio, !isLikeNone(dash_offset), isLikeNone(dash_offset) ? 0 : dash_offset, isLikeNone(equal_lengths) ? 0xFFFFFF : equal_lengths ? 1 : 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} shape
 * @param {number} tip_side_length
 * @param {WasmColor} tip_color
 * @returns {WasmVectorObject}
 */
export function addFinalTip(shape, tip_side_length, tip_color) {
    _assertClass(shape, WasmVectorObject);
    var ptr0 = shape.__destroy_into_raw();
    _assertClass(tip_color, WasmColor);
    var ptr1 = tip_color.__destroy_into_raw();
    const ret = wasm.addFinalTip(ptr0, tip_side_length, ptr1);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} shape
 * @param {number} tip_side_length
 * @param {WasmColor} tip_color
 * @returns {WasmVectorObject}
 */
export function addInitialTip(shape, tip_side_length, tip_color) {
    _assertClass(shape, WasmVectorObject);
    var ptr0 = shape.__destroy_into_raw();
    _assertClass(tip_color, WasmColor);
    var ptr1 = tip_color.__destroy_into_raw();
    const ret = wasm.addInitialTip(ptr0, tip_side_length, ptr1);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} shape
 * @param {number} tip_side_length
 * @param {WasmColor} tip_color
 * @returns {WasmVectorObject}
 */
export function addBothSidesTips(shape, tip_side_length, tip_color) {
    _assertClass(shape, WasmVectorObject);
    var ptr0 = shape.__destroy_into_raw();
    _assertClass(tip_color, WasmColor);
    var ptr1 = tip_color.__destroy_into_raw();
    const ret = wasm.addBothSidesTips(ptr0, tip_side_length, ptr1);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Array<any>} center
 * @param {number} radius
 * @param {number} start_angle
 * @param {number} end_angle
 * @param {number | undefined} [num_points]
 * @param {WasmColor | undefined} [stroke_color]
 * @param {WasmColor | undefined} [fill_color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {WasmVectorObject}
 */
export function arc(center, radius, start_angle, end_angle, num_points, stroke_color, fill_color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(stroke_color)) {
        _assertClass(stroke_color, WasmColor);
        ptr0 = stroke_color.__destroy_into_raw();
    }
    let ptr1 = 0;
    if (!isLikeNone(fill_color)) {
        _assertClass(fill_color, WasmColor);
        ptr1 = fill_color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.arc(center, radius, start_angle, end_angle, isLikeNone(num_points) ? 0x100000001 : (num_points) >>> 0, ptr0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Array<any>} center
 * @param {number} radius
 * @param {number | undefined} [num_points]
 * @param {WasmColor | undefined} [stroke_color]
 * @param {WasmColor | undefined} [fill_color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {WasmVectorObject}
 */
export function circle(center, radius, num_points, stroke_color, fill_color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(stroke_color)) {
        _assertClass(stroke_color, WasmColor);
        ptr0 = stroke_color.__destroy_into_raw();
    }
    let ptr1 = 0;
    if (!isLikeNone(fill_color)) {
        _assertClass(fill_color, WasmColor);
        ptr1 = fill_color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.circle(center, radius, isLikeNone(num_points) ? 0x100000001 : (num_points) >>> 0, ptr0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Array<any>} center
 * @param {number} x_radius
 * @param {number} y_radius
 * @param {number} start_angle
 * @param {number} end_angle
 * @param {number | undefined} [num_points]
 * @param {WasmColor | undefined} [stroke_color]
 * @param {WasmColor | undefined} [fill_color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {WasmVectorObject}
 */
export function ellipticalArc(center, x_radius, y_radius, start_angle, end_angle, num_points, stroke_color, fill_color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(stroke_color)) {
        _assertClass(stroke_color, WasmColor);
        ptr0 = stroke_color.__destroy_into_raw();
    }
    let ptr1 = 0;
    if (!isLikeNone(fill_color)) {
        _assertClass(fill_color, WasmColor);
        ptr1 = fill_color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.ellipticalArc(center, x_radius, y_radius, start_angle, end_angle, isLikeNone(num_points) ? 0x100000001 : (num_points) >>> 0, ptr0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Array<any>} center
 * @param {number} x_radius
 * @param {number} y_radius
 * @param {number | undefined} [num_points]
 * @param {WasmColor | undefined} [stroke_color]
 * @param {WasmColor | undefined} [fill_color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {WasmVectorObject}
 */
export function ellipse(center, x_radius, y_radius, num_points, stroke_color, fill_color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(stroke_color)) {
        _assertClass(stroke_color, WasmColor);
        ptr0 = stroke_color.__destroy_into_raw();
    }
    let ptr1 = 0;
    if (!isLikeNone(fill_color)) {
        _assertClass(fill_color, WasmColor);
        ptr1 = fill_color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.ellipse(center, x_radius, y_radius, isLikeNone(num_points) ? 0x100000001 : (num_points) >>> 0, ptr0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Array<any>} center
 * @param {number} inner_radius
 * @param {number} outer_radius
 * @param {number} start_angle
 * @param {number} end_angle
 * @param {number | undefined} [num_points]
 * @param {WasmColor | undefined} [stroke_color]
 * @param {WasmColor | undefined} [fill_color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {WasmVectorObject}
 */
export function annularSector(center, inner_radius, outer_radius, start_angle, end_angle, num_points, stroke_color, fill_color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(stroke_color)) {
        _assertClass(stroke_color, WasmColor);
        ptr0 = stroke_color.__destroy_into_raw();
    }
    let ptr1 = 0;
    if (!isLikeNone(fill_color)) {
        _assertClass(fill_color, WasmColor);
        ptr1 = fill_color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.annularSector(center, inner_radius, outer_radius, start_angle, end_angle, isLikeNone(num_points) ? 0x100000001 : (num_points) >>> 0, ptr0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Array<any>} start_point
 * @param {Array<any>} end_point
 * @param {WasmColor | undefined} [stroke_color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {WasmVectorObject}
 */
export function line(start_point, end_point, stroke_color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(stroke_color)) {
        _assertClass(stroke_color, WasmColor);
        ptr0 = stroke_color.__destroy_into_raw();
    }
    var ptr1 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ptr2 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    const ret = wasm.line(start_point, end_point, ptr0, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr1, len1, ptr2, len2, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Array<any>} points
 * @param {WasmColor | undefined} [stroke_color]
 * @param {WasmColor | undefined} [fill_color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {WasmVectorObject}
 */
export function polygon(points, stroke_color, fill_color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(stroke_color)) {
        _assertClass(stroke_color, WasmColor);
        ptr0 = stroke_color.__destroy_into_raw();
    }
    let ptr1 = 0;
    if (!isLikeNone(fill_color)) {
        _assertClass(fill_color, WasmColor);
        ptr1 = fill_color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.polygon(points, ptr0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Array<any>} center
 * @param {number} side_length
 * @param {number} num_sides
 * @param {WasmColor | undefined} [stroke_color]
 * @param {WasmColor | undefined} [fill_color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {WasmVectorObject}
 */
export function regularPolygon(center, side_length, num_sides, stroke_color, fill_color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(stroke_color)) {
        _assertClass(stroke_color, WasmColor);
        ptr0 = stroke_color.__destroy_into_raw();
    }
    let ptr1 = 0;
    if (!isLikeNone(fill_color)) {
        _assertClass(fill_color, WasmColor);
        ptr1 = fill_color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.regularPolygon(center, side_length, num_sides, ptr0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Array<any>} center
 * @param {number} side_length
 * @param {WasmColor | undefined} [stroke_color]
 * @param {WasmColor | undefined} [fill_color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {WasmVectorObject}
 */
export function square(center, side_length, stroke_color, fill_color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(stroke_color)) {
        _assertClass(stroke_color, WasmColor);
        ptr0 = stroke_color.__destroy_into_raw();
    }
    let ptr1 = 0;
    if (!isLikeNone(fill_color)) {
        _assertClass(fill_color, WasmColor);
        ptr1 = fill_color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.square(center, side_length, ptr0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Array<any>} center
 * @param {number} width
 * @param {number} height
 * @param {WasmColor | undefined} [stroke_color]
 * @param {WasmColor | undefined} [fill_color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {WasmVectorObject}
 */
export function rectangle(center, width, height, stroke_color, fill_color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(stroke_color)) {
        _assertClass(stroke_color, WasmColor);
        ptr0 = stroke_color.__destroy_into_raw();
    }
    let ptr1 = 0;
    if (!isLikeNone(fill_color)) {
        _assertClass(fill_color, WasmColor);
        ptr1 = fill_color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.rectangle(center, width, height, ptr0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Array<any>} center
 * @param {number} side_length
 * @param {WasmColor | undefined} [stroke_color]
 * @param {WasmColor | undefined} [fill_color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {WasmVectorObject}
 */
export function equilateralTriangle(center, side_length, stroke_color, fill_color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(stroke_color)) {
        _assertClass(stroke_color, WasmColor);
        ptr0 = stroke_color.__destroy_into_raw();
    }
    let ptr1 = 0;
    if (!isLikeNone(fill_color)) {
        _assertClass(fill_color, WasmColor);
        ptr1 = fill_color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.equilateralTriangle(center, side_length, ptr0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Array<any>} point1
 * @param {Array<any>} point2
 * @param {Array<any>} point3
 * @param {WasmColor | undefined} [stroke_color]
 * @param {WasmColor | undefined} [fill_color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {WasmVectorObject}
 */
export function triangle(point1, point2, point3, stroke_color, fill_color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(stroke_color)) {
        _assertClass(stroke_color, WasmColor);
        ptr0 = stroke_color.__destroy_into_raw();
    }
    let ptr1 = 0;
    if (!isLikeNone(fill_color)) {
        _assertClass(fill_color, WasmColor);
        ptr1 = fill_color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.triangle(point1, point2, point3, ptr0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Array<any>} point1
 * @param {Array<any>} point2
 * @param {WasmColor | undefined} [stroke_color]
 * @param {WasmColor | undefined} [fill_color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {WasmVectorObject}
 */
export function rightTriangle(point1, point2, stroke_color, fill_color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(stroke_color)) {
        _assertClass(stroke_color, WasmColor);
        ptr0 = stroke_color.__destroy_into_raw();
    }
    let ptr1 = 0;
    if (!isLikeNone(fill_color)) {
        _assertClass(fill_color, WasmColor);
        ptr1 = fill_color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.rightTriangle(point1, point2, ptr0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} x_step
 * @param {number} y_min
 * @param {number} y_max
 * @param {number} y_step
 * @param {Array<any>} center
 * @param {number | undefined} [x_length]
 * @param {number | undefined} [y_length]
 * @param {WasmColor | undefined} [color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @param {boolean | undefined} [add_x_ticks]
 * @param {boolean | undefined} [add_y_ticks]
 * @param {number | undefined} [x_tick_size]
 * @param {number | undefined} [y_tick_size]
 * @param {boolean | undefined} [add_x_tip]
 * @param {boolean | undefined} [add_y_tip]
 * @returns {WasmVectorObject}
 */
export function axes(x_min, x_max, x_step, y_min, y_max, y_step, center, x_length, y_length, color, stroke_width, line_cap, line_join, index, add_x_ticks, add_y_ticks, x_tick_size, y_tick_size, add_x_tip, add_y_tip) {
    let ptr0 = 0;
    if (!isLikeNone(color)) {
        _assertClass(color, WasmColor);
        ptr0 = color.__destroy_into_raw();
    }
    var ptr1 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ptr2 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    const ret = wasm.axes(x_min, x_max, x_step, y_min, y_max, y_step, center, !isLikeNone(x_length), isLikeNone(x_length) ? 0 : x_length, !isLikeNone(y_length), isLikeNone(y_length) ? 0 : y_length, ptr0, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr1, len1, ptr2, len2, isLikeNone(index) ? 0x100000001 : (index) >>> 0, isLikeNone(add_x_ticks) ? 0xFFFFFF : add_x_ticks ? 1 : 0, isLikeNone(add_y_ticks) ? 0xFFFFFF : add_y_ticks ? 1 : 0, !isLikeNone(x_tick_size), isLikeNone(x_tick_size) ? 0 : x_tick_size, !isLikeNone(y_tick_size), isLikeNone(y_tick_size) ? 0 : y_tick_size, isLikeNone(add_x_tip) ? 0xFFFFFF : add_x_tip ? 1 : 0, isLikeNone(add_y_tip) ? 0xFFFFFF : add_y_tip ? 1 : 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} axes
 * @param {number} x
 * @param {number} y
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} y_min
 * @param {number} y_max
 * @returns {Array<any>}
 */
export function coordsToPoint(axes, x, y, x_min, x_max, y_min, y_max) {
    _assertClass(axes, WasmVectorObject);
    const ret = wasm.coordsToPoint(axes.__wbg_ptr, x, y, x_min, x_max, y_min, y_max);
    return ret;
}

/**
 * @param {WasmVectorObject} axes
 * @param {Array<any>} point
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} y_min
 * @param {number} y_max
 * @returns {Array<any>}
 */
export function pointToCoords(axes, point, x_min, x_max, y_min, y_max) {
    _assertClass(axes, WasmVectorObject);
    const ret = wasm.pointToCoords(axes.__wbg_ptr, point, x_min, x_max, y_min, y_max);
    return ret;
}

/**
 * @param {Function} f
 * @param {number} t_min
 * @param {number} t_max
 * @param {number} t_step
 * @param {WasmVectorObject} axes
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} y_min
 * @param {number} y_max
 * @param {WasmColor | undefined} [color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {Promise<WasmVectorObject>}
 */
export function parametricPlotInAxes(f, t_min, t_max, t_step, axes, x_min, x_max, y_min, y_max, color, stroke_width, line_cap, line_join, index) {
    _assertClass(axes, WasmVectorObject);
    let ptr0 = 0;
    if (!isLikeNone(color)) {
        _assertClass(color, WasmColor);
        ptr0 = color.__destroy_into_raw();
    }
    var ptr1 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ptr2 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    const ret = wasm.parametricPlotInAxes(f, t_min, t_max, t_step, axes.__wbg_ptr, x_min, x_max, y_min, y_max, ptr0, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr1, len1, ptr2, len2, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return ret;
}

/**
 * @param {Function} f
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} y_min
 * @param {number} y_max
 * @param {number} x1
 * @param {number} x2
 * @param {number} x_step
 * @param {WasmVectorObject} axes
 * @param {WasmColor | undefined} [color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {Promise<WasmVectorObject>}
 */
export function plotInAxes(f, x_min, x_max, y_min, y_max, x1, x2, x_step, axes, color, stroke_width, line_cap, line_join, index) {
    _assertClass(axes, WasmVectorObject);
    let ptr0 = 0;
    if (!isLikeNone(color)) {
        _assertClass(color, WasmColor);
        ptr0 = color.__destroy_into_raw();
    }
    var ptr1 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ptr2 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    const ret = wasm.plotInAxes(f, x_min, x_max, y_min, y_max, x1, x2, x_step, axes.__wbg_ptr, ptr0, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr1, len1, ptr2, len2, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return ret;
}

function passArrayF64ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 8, 8) >>> 0;
    getFloat64ArrayMemory0().set(arg, ptr / 8);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
/**
 * @param {Function} f
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} y_min
 * @param {number} y_max
 * @param {number} x_1
 * @param {number} x_2
 * @param {number} x_step
 * @param {number} y_1
 * @param {number} y_2
 * @param {number} y_step
 * @param {WasmVectorObject} axes
 * @param {Float64Array} intervals
 * @param {WasmColor | undefined} [color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {Promise<WasmVectorObject>}
 */
export function contourPlotInAxes(f, x_min, x_max, y_min, y_max, x_1, x_2, x_step, y_1, y_2, y_step, axes, intervals, color, stroke_width, line_cap, line_join, index) {
    _assertClass(axes, WasmVectorObject);
    const ptr0 = passArrayF64ToWasm0(intervals, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    let ptr1 = 0;
    if (!isLikeNone(color)) {
        _assertClass(color, WasmColor);
        ptr1 = color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.contourPlotInAxes(f, x_min, x_max, y_min, y_max, x_1, x_2, x_step, y_1, y_2, y_step, axes.__wbg_ptr, ptr0, len0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return ret;
}

/**
 * @param {WasmVectorObject} axes
 * @param {WasmVectorObject} plot
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} y_min
 * @param {number} y_max
 * @param {number} x1
 * @param {number} x2
 * @param {WasmColor | undefined} [color]
 * @param {number | undefined} [index]
 * @returns {WasmVectorObject}
 */
export function areaUnderCurve(axes, plot, x_min, x_max, y_min, y_max, x1, x2, color, index) {
    _assertClass(axes, WasmVectorObject);
    _assertClass(plot, WasmVectorObject);
    let ptr0 = 0;
    if (!isLikeNone(color)) {
        _assertClass(color, WasmColor);
        ptr0 = color.__destroy_into_raw();
    }
    const ret = wasm.areaUnderCurve(axes.__wbg_ptr, plot.__wbg_ptr, x_min, x_max, y_min, y_max, x1, x2, ptr0, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Function} f
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} y_min
 * @param {number} y_max
 * @param {number} direction
 * @param {number} x_1
 * @param {number} x_2
 * @param {number} n_rects
 * @param {WasmVectorObject} axes
 * @param {WasmColor | undefined} [stroke_color]
 * @param {WasmColor | undefined} [fill_color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {Promise<WasmVectorObject>}
 */
export function riemannRectanglesForPlot(f, x_min, x_max, y_min, y_max, direction, x_1, x_2, n_rects, axes, stroke_color, fill_color, stroke_width, line_cap, line_join, index) {
    _assertClass(axes, WasmVectorObject);
    let ptr0 = 0;
    if (!isLikeNone(stroke_color)) {
        _assertClass(stroke_color, WasmColor);
        ptr0 = stroke_color.__destroy_into_raw();
    }
    let ptr1 = 0;
    if (!isLikeNone(fill_color)) {
        _assertClass(fill_color, WasmColor);
        ptr1 = fill_color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.riemannRectanglesForPlot(f, x_min, x_max, y_min, y_max, direction, x_1, x_2, n_rects, axes.__wbg_ptr, ptr0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return ret;
}

/**
 * @param {Function} f
 * @param {number} x_1
 * @param {number} x_2
 * @param {number} length
 * @param {WasmVectorObject} axes
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} y_min
 * @param {number} y_max
 * @param {WasmColor | undefined} [color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {Promise<WasmVectorObject>}
 */
export function secantLineForPlot(f, x_1, x_2, length, axes, x_min, x_max, y_min, y_max, color, stroke_width, line_cap, line_join, index) {
    _assertClass(axes, WasmVectorObject);
    let ptr0 = 0;
    if (!isLikeNone(color)) {
        _assertClass(color, WasmColor);
        ptr0 = color.__destroy_into_raw();
    }
    var ptr1 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ptr2 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    const ret = wasm.secantLineForPlot(f, x_1, x_2, length, axes.__wbg_ptr, x_min, x_max, y_min, y_max, ptr0, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr1, len1, ptr2, len2, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return ret;
}

/**
 * @param {Function} f
 * @param {number} t_min
 * @param {number} t_max
 * @param {number} t_step
 * @param {WasmColor | undefined} [color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {Promise<WasmVectorObject>}
 */
export function parametricFunction(f, t_min, t_max, t_step, color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(color)) {
        _assertClass(color, WasmColor);
        ptr0 = color.__destroy_into_raw();
    }
    var ptr1 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ptr2 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    const ret = wasm.parametricFunction(f, t_min, t_max, t_step, ptr0, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr1, len1, ptr2, len2, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return ret;
}

/**
 * @param {Function} f
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} y_min
 * @param {number} y_max
 * @param {number} x_step
 * @param {number} y_step
 * @param {Float64Array} intervals
 * @param {WasmColor | undefined} [color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {Promise<WasmVectorObject>}
 */
export function contourPlot(f, x_min, x_max, y_min, y_max, x_step, y_step, intervals, color, stroke_width, line_cap, line_join, index) {
    const ptr0 = passArrayF64ToWasm0(intervals, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    let ptr1 = 0;
    if (!isLikeNone(color)) {
        _assertClass(color, WasmColor);
        ptr1 = color.__destroy_into_raw();
    }
    var ptr2 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.contourPlot(f, x_min, x_max, y_min, y_max, x_step, y_step, ptr0, len0, ptr1, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr2, len2, ptr3, len3, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return ret;
}

/**
 * @param {Function} f
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} x_step
 * @param {WasmColor | undefined} [color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @returns {Promise<WasmVectorObject>}
 */
export function realFunction(f, x_min, x_max, x_step, color, stroke_width, line_cap, line_join, index) {
    let ptr0 = 0;
    if (!isLikeNone(color)) {
        _assertClass(color, WasmColor);
        ptr0 = color.__destroy_into_raw();
    }
    var ptr1 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ptr2 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    const ret = wasm.realFunction(f, x_min, x_max, x_step, ptr0, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr1, len1, ptr2, len2, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return ret;
}

/**
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} x_step
 * @param {Array<any>} center
 * @param {WasmColor | undefined} [color]
 * @param {number | undefined} [stroke_width]
 * @param {string | undefined} [line_cap]
 * @param {string | undefined} [line_join]
 * @param {number | undefined} [index]
 * @param {number | undefined} [length]
 * @param {boolean | undefined} [add_tip]
 * @param {boolean | undefined} [add_ticks]
 * @param {number | undefined} [tick_size]
 * @param {number | undefined} [angle]
 * @returns {WasmVectorObject}
 */
export function numberLine(x_min, x_max, x_step, center, color, stroke_width, line_cap, line_join, index, length, add_tip, add_ticks, tick_size, angle) {
    let ptr0 = 0;
    if (!isLikeNone(color)) {
        _assertClass(color, WasmColor);
        ptr0 = color.__destroy_into_raw();
    }
    var ptr1 = isLikeNone(line_cap) ? 0 : passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ptr2 = isLikeNone(line_join) ? 0 : passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    const ret = wasm.numberLine(x_min, x_max, x_step, center, ptr0, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, ptr1, len1, ptr2, len2, isLikeNone(index) ? 0x100000001 : (index) >>> 0, !isLikeNone(length), isLikeNone(length) ? 0 : length, isLikeNone(add_tip) ? 0xFFFFFF : add_tip ? 1 : 0, isLikeNone(add_ticks) ? 0xFFFFFF : add_ticks ? 1 : 0, !isLikeNone(tick_size), isLikeNone(tick_size) ? 0 : tick_size, !isLikeNone(angle), isLikeNone(angle) ? 0 : angle);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} number_line
 * @param {number} number
 * @param {number} x_min
 * @param {number} x_max
 * @returns {Array<any>}
 */
export function numberToPoint(number_line, number, x_min, x_max) {
    _assertClass(number_line, WasmVectorObject);
    const ret = wasm.numberToPoint(number_line.__wbg_ptr, number, x_min, x_max);
    return ret;
}

/**
 * @param {WasmVectorObject} number_line
 * @param {Array<any>} point
 * @param {number} x_min
 * @param {number} x_max
 * @returns {number}
 */
export function pointToNumber(number_line, point, x_min, x_max) {
    _assertClass(number_line, WasmVectorObject);
    const ret = wasm.pointToNumber(number_line.__wbg_ptr, point, x_min, x_max);
    return ret;
}

/**
 * @param {WasmVectorObject} number_line
 * @param {Array<any>} numbers
 * @param {Function} number_to_vector
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} height
 * @param {Array<any> | undefined} [direction]
 * @param {number | undefined} [buff]
 * @param {number | undefined} [index]
 * @returns {Promise<WasmVectorObject>}
 */
export function getNumbersTex(number_line, numbers, number_to_vector, x_min, x_max, height, direction, buff, index) {
    _assertClass(number_line, WasmVectorObject);
    var ptr0 = number_line.__destroy_into_raw();
    const ret = wasm.getNumbersTex(ptr0, numbers, number_to_vector, x_min, x_max, height, isLikeNone(direction) ? 0 : addToExternrefTable0(direction), !isLikeNone(buff), isLikeNone(buff) ? 0 : buff, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return ret;
}

/**
 * @param {string} svg
 * @param {Map<any, any> | undefined} [font_urls_map]
 * @returns {Promise<WasmVectorObject>}
 */
export function svgToVector(svg, font_urls_map) {
    const ptr0 = passStringToWasm0(svg, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.svgToVector(ptr0, len0, isLikeNone(font_urls_map) ? 0 : addToExternrefTable0(font_urls_map));
    return ret;
}

/**
 * @param {number} angle
 * @param {number} axis
 * @returns {Array<any>}
 */
export function rotMatrix(angle, axis) {
    const ret = wasm.rotMatrix(angle, axis);
    return ret;
}

/**
 * @param {Array<any>} a
 * @param {Array<any>} b
 * @returns {Array<any>}
 */
export function matrixProduct(a, b) {
    const ret = wasm.matrixProduct(a, b);
    return ret;
}

/**
 * @param {number} phi
 * @param {number} theta
 * @param {number} gamma
 * @returns {Array<any>}
 */
export function rotMatrixEuler(phi, theta, gamma) {
    const ret = wasm.rotMatrixEuler(phi, theta, gamma);
    return ret;
}

/**
 * @param {Array<any>} a
 * @returns {Array<any>}
 */
export function transposeMatrix(a) {
    const ret = wasm.transposeMatrix(a);
    return ret;
}

/**
 * @param {Array<any>} matrix
 * @param {Array<any>} points
 * @returns {Array<any>}
 */
export function applyMatrix(matrix, points) {
    const ret = wasm.applyMatrix(matrix, points);
    return ret;
}

/**
 * @param {Array<any>} points
 * @param {Array<any>} shift
 * @returns {Array<any>}
 */
export function shiftPoints3D(points, shift) {
    const ret = wasm.shiftPoints3D(points, shift);
    return ret;
}

/**
 * @param {WasmGradientImageOrColor} color
 * @returns {WasmGradientImageOrColor}
 */
export function ensureValidThreeDColor(color) {
    _assertClass(color, WasmGradientImageOrColor);
    var ptr0 = color.__destroy_into_raw();
    const ret = wasm.ensureValidThreeDColor(ptr0);
    return WasmGradientImageOrColor.__wrap(ret);
}

/**
 * @param {WasmColor} color
 * @param {Array<any>} point
 * @param {Array<any>} unit_normal
 * @param {WasmLightSource} light_source
 * @returns {WasmColor}
 */
export function getShadedRgb(color, point, unit_normal, light_source) {
    _assertClass(color, WasmColor);
    var ptr0 = color.__destroy_into_raw();
    _assertClass(light_source, WasmLightSource);
    const ret = wasm.getShadedRgb(ptr0, point, unit_normal, light_source.__wbg_ptr);
    return WasmColor.__wrap(ret);
}

/**
 * @param {Array<any>} points
 * @returns {Array<any>}
 */
export function getStartCorner(points) {
    const ret = wasm.getStartCorner(points);
    return ret;
}

/**
 * @param {Array<any>} points
 * @returns {Array<any>}
 */
export function getEndCorner(points) {
    const ret = wasm.getEndCorner(points);
    return ret;
}

/**
 * @param {Array<any>} a
 * @param {Array<any>} b
 * @returns {Array<any>}
 */
export function crossProduct(a, b) {
    const ret = wasm.crossProduct(a, b);
    return ret;
}

/**
 * @param {Array<any>} v1
 * @param {Array<any>} v2
 * @returns {Array<any>}
 */
export function getUnitNormal(v1, v2) {
    const ret = wasm.getUnitNormal(v1, v2);
    return ret;
}

/**
 * @param {Array<any>} points
 * @returns {Array<any>}
 */
export function getStartAnchors(points) {
    const ret = wasm.getStartAnchors(points);
    return ret;
}

/**
 * @param {Array<any>} points
 * @returns {Array<any>}
 */
export function getEndAnchors(points) {
    const ret = wasm.getEndAnchors(points);
    return ret;
}

/**
 * @param {Array<any>} points
 * @returns {Array<any>}
 */
export function getAnchors(points) {
    const ret = wasm.getAnchors(points);
    return ret;
}

/**
 * @param {Array<any>} points
 * @param {number} index
 * @returns {Array<any>}
 */
export function getCornerUnitNormal(points, index) {
    const ret = wasm.getCornerUnitNormal(points, index);
    return ret;
}

/**
 * @param {Array<any>} points
 * @returns {Array<any>}
 */
export function getStartCornerUnitNormal(points) {
    const ret = wasm.getStartCornerUnitNormal(points);
    return ret;
}

/**
 * @param {Array<any>} points
 * @returns {Array<any>}
 */
export function getEndCornerUnitNormal(points) {
    const ret = wasm.getEndCornerUnitNormal(points);
    return ret;
}

/**
 * @param {WasmGradientImageOrColor} color
 * @param {Array<any>} points
 * @param {WasmLightSource} light_source
 * @param {WasmCamera} camera
 * @returns {WasmGradientImageOrColor}
 */
export function getShadedColor(color, points, light_source, camera) {
    _assertClass(color, WasmGradientImageOrColor);
    _assertClass(light_source, WasmLightSource);
    _assertClass(camera, WasmCamera);
    const ret = wasm.getShadedColor(color.__wbg_ptr, points, light_source.__wbg_ptr, camera.__wbg_ptr);
    return WasmGradientImageOrColor.__wrap(ret);
}

/**
 * @param {Array<any>} points
 * @param {WasmCamera} camera
 * @returns {Array<any>}
 */
export function projectPoints(points, camera) {
    _assertClass(camera, WasmCamera);
    const ret = wasm.projectPoints(points, camera.__wbg_ptr);
    return ret;
}

/**
 * @param {Array<any>} point1
 * @param {Array<any>} point2
 * @returns {Array<any>}
 */
export function lineAsCubicBezier3D(point1, point2) {
    const ret = wasm.lineAsCubicBezier3D(point1, point2);
    return ret;
}

/**
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} x_step
 * @param {number} y_min
 * @param {number} y_max
 * @param {number} y_step
 * @param {number} z_min
 * @param {number} z_max
 * @param {number} z_step
 * @param {Array<any>} center
 * @param {number | undefined} [x_length]
 * @param {number | undefined} [y_length]
 * @param {number | undefined} [z_length]
 * @param {WasmColor | undefined} [color]
 * @param {number | undefined} [stroke_width]
 * @param {boolean | undefined} [add_x_ticks]
 * @param {boolean | undefined} [add_y_ticks]
 * @param {boolean | undefined} [add_z_ticks]
 * @param {number | undefined} [x_tick_size]
 * @param {number | undefined} [y_tick_size]
 * @param {number | undefined} [z_tick_size]
 * @param {boolean | undefined} [add_x_tip]
 * @param {boolean | undefined} [add_y_tip]
 * @param {boolean | undefined} [add_z_tip]
 * @param {number | undefined} [n_pieces]
 * @param {number | undefined} [index]
 * @returns {WasmThreeDObject}
 */
export function threeDAxes(x_min, x_max, x_step, y_min, y_max, y_step, z_min, z_max, z_step, center, x_length, y_length, z_length, color, stroke_width, add_x_ticks, add_y_ticks, add_z_ticks, x_tick_size, y_tick_size, z_tick_size, add_x_tip, add_y_tip, add_z_tip, n_pieces, index) {
    let ptr0 = 0;
    if (!isLikeNone(color)) {
        _assertClass(color, WasmColor);
        ptr0 = color.__destroy_into_raw();
    }
    const ret = wasm.threeDAxes(x_min, x_max, x_step, y_min, y_max, y_step, z_min, z_max, z_step, center, !isLikeNone(x_length), isLikeNone(x_length) ? 0 : x_length, !isLikeNone(y_length), isLikeNone(y_length) ? 0 : y_length, !isLikeNone(z_length), isLikeNone(z_length) ? 0 : z_length, ptr0, !isLikeNone(stroke_width), isLikeNone(stroke_width) ? 0 : stroke_width, isLikeNone(add_x_ticks) ? 0xFFFFFF : add_x_ticks ? 1 : 0, isLikeNone(add_y_ticks) ? 0xFFFFFF : add_y_ticks ? 1 : 0, isLikeNone(add_z_ticks) ? 0xFFFFFF : add_z_ticks ? 1 : 0, !isLikeNone(x_tick_size), isLikeNone(x_tick_size) ? 0 : x_tick_size, !isLikeNone(y_tick_size), isLikeNone(y_tick_size) ? 0 : y_tick_size, !isLikeNone(z_tick_size), isLikeNone(z_tick_size) ? 0 : z_tick_size, isLikeNone(add_x_tip) ? 0xFFFFFF : add_x_tip ? 1 : 0, isLikeNone(add_y_tip) ? 0xFFFFFF : add_y_tip ? 1 : 0, isLikeNone(add_z_tip) ? 0xFFFFFF : add_z_tip ? 1 : 0, isLikeNone(n_pieces) ? 0x100000001 : (n_pieces) >>> 0, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} axes
 * @param {Array<any>} coords
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} y_min
 * @param {number} y_max
 * @param {number} z_min
 * @param {number} z_max
 * @returns {Array<any>}
 */
export function coordsToPoint3D(axes, coords, x_min, x_max, y_min, y_max, z_min, z_max) {
    _assertClass(axes, WasmThreeDObject);
    const ret = wasm.coordsToPoint3D(axes.__wbg_ptr, coords, x_min, x_max, y_min, y_max, z_min, z_max);
    return ret;
}

/**
 * @param {WasmThreeDObject} axes
 * @param {Array<any>} point
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} y_min
 * @param {number} y_max
 * @param {number} z_min
 * @param {number} z_max
 * @returns {Array<any>}
 */
export function pointToCoords3D(axes, point, x_min, x_max, y_min, y_max, z_min, z_max) {
    _assertClass(axes, WasmThreeDObject);
    const ret = wasm.pointToCoords3D(axes.__wbg_ptr, point, x_min, x_max, y_min, y_max, z_min, z_max);
    return ret;
}

/**
 * @param {WasmThreeDObject} axes
 * @param {Function} f
 * @param {number} u_min
 * @param {number} u_max
 * @param {number} v_min
 * @param {number} v_max
 * @param {number} u_segments
 * @param {number} v_segments
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} y_min
 * @param {number} y_max
 * @param {number} z_min
 * @param {number} z_max
 * @param {(WasmColor)[]} fills
 * @param {(WasmColor)[]} strokes
 * @param {number} stroke_width
 * @param {number | undefined} [index]
 * @returns {Promise<WasmThreeDObject>}
 */
export function parametricPlotInAxes3D(axes, f, u_min, u_max, v_min, v_max, u_segments, v_segments, x_min, x_max, y_min, y_max, z_min, z_max, fills, strokes, stroke_width, index) {
    _assertClass(axes, WasmThreeDObject);
    var ptr0 = axes.__destroy_into_raw();
    const ptr1 = passArrayJsValueToWasm0(fills, wasm.__wbindgen_malloc);
    const len1 = WASM_VECTOR_LEN;
    const ptr2 = passArrayJsValueToWasm0(strokes, wasm.__wbindgen_malloc);
    const len2 = WASM_VECTOR_LEN;
    const ret = wasm.parametricPlotInAxes3D(ptr0, f, u_min, u_max, v_min, v_max, u_segments, v_segments, x_min, x_max, y_min, y_max, z_min, z_max, ptr1, len1, ptr2, len2, stroke_width, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return ret;
}

/**
 * @param {WasmThreeDObject} axes
 * @param {Function} f
 * @param {number} u_min
 * @param {number} u_max
 * @param {number} v_min
 * @param {number} v_max
 * @param {number} u_segments
 * @param {number} v_segments
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} y_min
 * @param {number} y_max
 * @param {number} z_min
 * @param {number} z_max
 * @param {(WasmColor)[]} fills
 * @param {(WasmColor)[]} strokes
 * @param {number} stroke_width
 * @param {number | undefined} [index]
 * @returns {Promise<WasmThreeDObject>}
 */
export function plotInAxes3D(axes, f, u_min, u_max, v_min, v_max, u_segments, v_segments, x_min, x_max, y_min, y_max, z_min, z_max, fills, strokes, stroke_width, index) {
    _assertClass(axes, WasmThreeDObject);
    var ptr0 = axes.__destroy_into_raw();
    const ptr1 = passArrayJsValueToWasm0(fills, wasm.__wbindgen_malloc);
    const len1 = WASM_VECTOR_LEN;
    const ptr2 = passArrayJsValueToWasm0(strokes, wasm.__wbindgen_malloc);
    const len2 = WASM_VECTOR_LEN;
    const ret = wasm.plotInAxes3D(ptr0, f, u_min, u_max, v_min, v_max, u_segments, v_segments, x_min, x_max, y_min, y_max, z_min, z_max, ptr1, len1, ptr2, len2, stroke_width, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return ret;
}

/**
 * @param {WasmThreeDObject} axes
 * @param {Function} f
 * @param {number} u_min
 * @param {number} u_max
 * @param {number} u_segments
 * @param {number} x_min
 * @param {number} x_max
 * @param {number} y_min
 * @param {number} y_max
 * @param {number} z_min
 * @param {number} z_max
 * @param {WasmColor} color
 * @param {number} stroke_width
 * @param {number | undefined} [index]
 * @returns {Promise<WasmThreeDObject>}
 */
export function parametricLinePlotInAxes3D(axes, f, u_min, u_max, u_segments, x_min, x_max, y_min, y_max, z_min, z_max, color, stroke_width, index) {
    _assertClass(axes, WasmThreeDObject);
    var ptr0 = axes.__destroy_into_raw();
    _assertClass(color, WasmColor);
    var ptr1 = color.__destroy_into_raw();
    const ret = wasm.parametricLinePlotInAxes3D(ptr0, f, u_min, u_max, u_segments, x_min, x_max, y_min, y_max, z_min, z_max, ptr1, stroke_width, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return ret;
}

/**
 * @param {Array<any>} center
 * @param {number} radius
 * @param {number} u_segments
 * @param {number} v_segments
 * @param {(WasmColor)[]} fill_colors
 * @param {(WasmColor)[]} stroke_colors
 * @param {number} stroke_width
 * @param {number | undefined} [index]
 * @returns {Promise<WasmThreeDObject>}
 */
export function sphere(center, radius, u_segments, v_segments, fill_colors, stroke_colors, stroke_width, index) {
    const ptr0 = passArrayJsValueToWasm0(fill_colors, wasm.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passArrayJsValueToWasm0(stroke_colors, wasm.__wbindgen_malloc);
    const len1 = WASM_VECTOR_LEN;
    const ret = wasm.sphere(center, radius, u_segments, v_segments, ptr0, len0, ptr1, len1, stroke_width, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
    return ret;
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function create(vec_obj, t) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.create(ptr0, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} vec_obj
 * @param {number} t
 * @returns {WasmThreeDObject}
 */
export function create3D(vec_obj, t) {
    _assertClass(vec_obj, WasmThreeDObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.create3D(ptr0, t);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} axes
 * @param {number} t
 * @param {number | undefined} [default_stroke_width]
 * @returns {WasmThreeDObject}
 */
export function createAxes3D(axes, t, default_stroke_width) {
    _assertClass(axes, WasmThreeDObject);
    var ptr0 = axes.__destroy_into_raw();
    const ret = wasm.createAxes3D(ptr0, t, !isLikeNone(default_stroke_width), isLikeNone(default_stroke_width) ? 0 : default_stroke_width);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {number} t
 * @param {number | undefined} [default_stroke_width]
 * @returns {WasmVectorObject}
 */
export function drawStrokeThenFill(vec_obj, t, default_stroke_width) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.drawStrokeThenFill(ptr0, t, !isLikeNone(default_stroke_width), isLikeNone(default_stroke_width) ? 0 : default_stroke_width);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} obj_3d
 * @param {number} t
 * @param {number | undefined} [default_stroke_width]
 * @returns {WasmThreeDObject}
 */
export function drawStrokeThenFill3D(obj_3d, t, default_stroke_width) {
    _assertClass(obj_3d, WasmThreeDObject);
    var ptr0 = obj_3d.__destroy_into_raw();
    const ret = wasm.drawStrokeThenFill3D(ptr0, t, !isLikeNone(default_stroke_width), isLikeNone(default_stroke_width) ? 0 : default_stroke_width);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {number} scale_factor
 * @param {Array<any>} shift
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function fadeIn(vec_obj, scale_factor, shift, t) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.fadeIn(ptr0, scale_factor, shift, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} obj_3d
 * @param {number} scale_factor
 * @param {Array<any>} shift
 * @param {number} t
 * @returns {WasmThreeDObject}
 */
export function fadeIn3D(obj_3d, scale_factor, shift, t) {
    _assertClass(obj_3d, WasmThreeDObject);
    var ptr0 = obj_3d.__destroy_into_raw();
    const ret = wasm.fadeIn3D(ptr0, scale_factor, shift, t);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {number} scale_factor
 * @param {Array<any>} shift
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function fadeOut(vec_obj, scale_factor, shift, t) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.fadeOut(ptr0, scale_factor, shift, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} obj_3d
 * @param {number} scale_factor
 * @param {Array<any>} shift
 * @param {number} t
 * @returns {WasmThreeDObject}
 */
export function fadeOut3D(obj_3d, scale_factor, shift, t) {
    _assertClass(obj_3d, WasmThreeDObject);
    var ptr0 = obj_3d.__destroy_into_raw();
    const ret = wasm.fadeOut3D(ptr0, scale_factor, shift, t);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function growArrowWithFinalTip(vec_obj, t) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.growArrowWithFinalTip(ptr0, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} original
 * @param {WasmThreeDObject} target
 * @param {number} t
 * @returns {WasmThreeDObject}
 */
export function morphShape3D(original, target, t) {
    _assertClass(original, WasmThreeDObject);
    var ptr0 = original.__destroy_into_raw();
    _assertClass(target, WasmThreeDObject);
    var ptr1 = target.__destroy_into_raw();
    const ret = wasm.morphShape3D(ptr0, ptr1, t);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} obj_3d
 * @param {number} angle
 * @param {number} t
 * @returns {WasmThreeDObject}
 */
export function rotateXAnimation3D(obj_3d, angle, t) {
    _assertClass(obj_3d, WasmThreeDObject);
    var ptr0 = obj_3d.__destroy_into_raw();
    const ret = wasm.rotateXAnimation3D(ptr0, angle, t);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} obj_3d
 * @param {number} angle
 * @param {number} t
 * @returns {WasmThreeDObject}
 */
export function rotateYAnimation3D(obj_3d, angle, t) {
    _assertClass(obj_3d, WasmThreeDObject);
    var ptr0 = obj_3d.__destroy_into_raw();
    const ret = wasm.rotateYAnimation3D(ptr0, angle, t);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} obj_3d
 * @param {number} angle
 * @param {number} t
 * @returns {WasmThreeDObject}
 */
export function rotateZAnimation3D(obj_3d, angle, t) {
    _assertClass(obj_3d, WasmThreeDObject);
    var ptr0 = obj_3d.__destroy_into_raw();
    const ret = wasm.rotateZAnimation3D(ptr0, angle, t);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function growArrowWithInitialTip(vec_obj, t) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.growArrowWithInitialTip(ptr0, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function growArrowWithTipsAtBothEnds(vec_obj, t) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.growArrowWithTipsAtBothEnds(ptr0, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function growFromCenter(vec_obj, t) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.growFromCenter(ptr0, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} obj_3d
 * @param {number} t
 * @returns {WasmThreeDObject}
 */
export function growFromCenter3D(obj_3d, t) {
    _assertClass(obj_3d, WasmThreeDObject);
    var ptr0 = obj_3d.__destroy_into_raw();
    const ret = wasm.growFromCenter3D(ptr0, t);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} original
 * @param {WasmVectorObject} target
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function morphShape(original, target, t) {
    _assertClass(original, WasmVectorObject);
    var ptr0 = original.__destroy_into_raw();
    _assertClass(target, WasmVectorObject);
    var ptr1 = target.__destroy_into_raw();
    const ret = wasm.morphShape(ptr0, ptr1, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {Array<any>} top_left_corner
 * @param {Array<any>} bottom_right_corner
 * @param {SVGScene} scene
 * @param {number} t
 */
export function moveCameraSVG(top_left_corner, bottom_right_corner, scene, t) {
    _assertClass(scene, SVGScene);
    wasm.moveCameraSVG(top_left_corner, bottom_right_corner, scene.__wbg_ptr, t);
}

/**
 * @param {Array<any>} top_left_corner
 * @param {Array<any>} bottom_right_corner
 * @param {Scene} scene
 * @param {number} t
 */
export function moveCamera(top_left_corner, bottom_right_corner, scene, t) {
    _assertClass(scene, Scene);
    wasm.moveCamera(top_left_corner, bottom_right_corner, scene.__wbg_ptr, t);
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {number} angle
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function rotateAnimation(vec_obj, angle, t) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.rotateAnimation(ptr0, angle, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {number} scale_factor
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function scaleInPlace(vec_obj, scale_factor, t) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.scaleInPlace(ptr0, scale_factor, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} obj_3d
 * @param {number} scale_factor
 * @param {number} t
 * @returns {WasmThreeDObject}
 */
export function scaleInPlace3D(obj_3d, scale_factor, t) {
    _assertClass(obj_3d, WasmThreeDObject);
    var ptr0 = obj_3d.__destroy_into_raw();
    const ret = wasm.scaleInPlace3D(ptr0, scale_factor, t);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {WasmColor} target_fill
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function setFillAnimation(vec_obj, target_fill, t) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    _assertClass(target_fill, WasmColor);
    var ptr1 = target_fill.__destroy_into_raw();
    const ret = wasm.setFillAnimation(ptr0, ptr1, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} obj_3d
 * @param {WasmColor} target_fill
 * @param {number} t
 * @returns {WasmThreeDObject}
 */
export function setFillAnimation3D(obj_3d, target_fill, t) {
    _assertClass(obj_3d, WasmThreeDObject);
    var ptr0 = obj_3d.__destroy_into_raw();
    _assertClass(target_fill, WasmColor);
    var ptr1 = target_fill.__destroy_into_raw();
    const ret = wasm.setFillAnimation3D(ptr0, ptr1, t);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {WasmColor} target_stroke
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function setStrokeAnimation(vec_obj, target_stroke, t) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    _assertClass(target_stroke, WasmColor);
    var ptr1 = target_stroke.__destroy_into_raw();
    const ret = wasm.setStrokeAnimation(ptr0, ptr1, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} obj_3d
 * @param {WasmColor} target_stroke
 * @param {number} t
 * @returns {WasmThreeDObject}
 */
export function setStrokeAnimation3D(obj_3d, target_stroke, t) {
    _assertClass(obj_3d, WasmThreeDObject);
    var ptr0 = obj_3d.__destroy_into_raw();
    _assertClass(target_stroke, WasmColor);
    var ptr1 = target_stroke.__destroy_into_raw();
    const ret = wasm.setStrokeAnimation3D(ptr0, ptr1, t);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {Array<any>} shift
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function shiftAnimation(vec_obj, shift, t) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.shiftAnimation(ptr0, shift, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} obj_3d
 * @param {Array<any>} shift
 * @param {number} t
 * @returns {WasmThreeDObject}
 */
export function shiftAnimation3D(obj_3d, shift, t) {
    _assertClass(obj_3d, WasmThreeDObject);
    var ptr0 = obj_3d.__destroy_into_raw();
    const ret = wasm.shiftAnimation3D(ptr0, shift, t);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function showTemporaily(vec_obj, t) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.showTemporaily(ptr0, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {number} angle
 * @param {number} t
 * @returns {WasmVectorObject}
 */
export function spinningGrow(vec_obj, angle, t) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.spinningGrow(ptr0, angle, t);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {number} ux
 * @param {number} uy
 * @param {number} vx
 * @param {number} vy
 * @returns {number}
 */
export function radian(ux, uy, vx, vy) {
    const ret = wasm.radian(ux, uy, vx, vy);
    return ret;
}

/**
 * @param {Array<any>} points
 * @param {number} t
 * @returns {Array<any>}
 */
export function bezier3D(points, t) {
    const ret = wasm.bezier3D(points, t);
    return ret;
}

/**
 * @param {number} x
 * @param {Array<any>} xp
 * @param {Array<any>} fp
 * @returns {number}
 */
export function interp(x, xp, fp) {
    const ret = wasm.interp(x, xp, fp);
    return ret;
}

/**
 * @param {number} ms
 * @returns {Promise<void>}
 */
export function sleep(ms) {
    const ret = wasm.sleep(ms);
    return ret;
}

/**
 * @param {Array<any>} last_move
 * @param {number} rx
 * @param {number} ry
 * @param {number} rotation
 * @param {boolean} large_arc
 * @param {boolean} sweep
 * @param {number} x
 * @param {number} y
 * @returns {Array<any>}
 */
export function ellipticalArcPath(last_move, rx, ry, rotation, large_arc, sweep, x, y) {
    const ret = wasm.ellipticalArcPath(last_move, rx, ry, rotation, large_arc, sweep, x, y);
    return ret;
}

/**
 * @param {Array<any>} points
 * @returns {Array<any>}
 */
export function getBbox(points) {
    const ret = wasm.getBbox(points);
    return ret;
}

/**
 * @param {Array<any>} points
 * @param {Array<any>} center_if_no_points
 * @returns {Array<any>}
 */
export function center(points, center_if_no_points) {
    const ret = wasm.center(points, center_if_no_points);
    return ret;
}

/**
 * @param {Array<any>} points
 * @param {Array<any>} center_if_no_points
 * @returns {Array<any>}
 */
export function center3D(points, center_if_no_points) {
    const ret = wasm.center3D(points, center_if_no_points);
    return ret;
}

/**
 * @param {bigint} n
 * @returns {bigint}
 */
export function factorial(n) {
    const ret = wasm.factorial(n);
    return BigInt.asUintN(64, ret);
}

/**
 * @param {string} hex
 * @param {number} a
 * @returns {WasmColor}
 */
export function hexToColor(hex, a) {
    const ptr0 = passStringToWasm0(hex, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.hexToColor(ptr0, len0, a);
    return WasmColor.__wrap(ret);
}

/**
 * @param {Array<any>} points
 * @param {number} t
 * @returns {Array<any>}
 */
export function bezier(points, t) {
    const ret = wasm.bezier(points, t);
    return ret;
}

/**
 * @param {Array<any>} numbers
 * @param {number} t
 * @returns {number}
 */
export function bezierNumber(numbers, t) {
    const ret = wasm.bezierNumber(numbers, t);
    return ret;
}

/**
 * @param {bigint} n
 * @param {bigint} r
 * @returns {bigint}
 */
export function permutation(n, r) {
    const ret = wasm.permutation(n, r);
    return BigInt.asUintN(64, ret);
}

/**
 * @param {bigint} n
 * @param {bigint} r
 * @returns {bigint}
 */
export function choose(n, r) {
    const ret = wasm.choose(n, r);
    return BigInt.asUintN(64, ret);
}

/**
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @returns {number}
 */
export function distanceSquared(x1, y1, x2, y2) {
    const ret = wasm.distanceSquared(x1, y1, x2, y2);
    return ret;
}

/**
 * @param {number} x1
 * @param {number} y1
 * @param {number} z1
 * @param {number} x2
 * @param {number} y2
 * @param {number} z2
 * @returns {number}
 */
export function distanceSquared3D(x1, y1, z1, x2, y2, z2) {
    const ret = wasm.distanceSquared3D(x1, y1, z1, x2, y2, z2);
    return ret;
}

/**
 * @param {number} x
 * @param {number} y
 * @param {number} t
 * @returns {number}
 */
export function interpolate(x, y, t) {
    const ret = wasm.interpolate(x, y, t);
    return ret;
}

/**
 * @param {Array<any>} x
 * @param {Array<any>} y
 * @param {number} t
 * @returns {Array<any>}
 */
export function interpolateTuple(x, y, t) {
    const ret = wasm.interpolateTuple(x, y, t);
    return ret;
}

/**
 * @param {Array<any>} x
 * @param {Array<any>} y
 * @param {number} t
 * @returns {Array<any>}
 */
export function interpolateTuple3D(x, y, t) {
    const ret = wasm.interpolateTuple3D(x, y, t);
    return ret;
}

/**
 * @param {WasmColor} x
 * @param {WasmColor} y
 * @param {number} t
 * @returns {WasmColor}
 */
export function interpolateColor(x, y, t) {
    _assertClass(x, WasmColor);
    var ptr0 = x.__destroy_into_raw();
    _assertClass(y, WasmColor);
    var ptr1 = y.__destroy_into_raw();
    const ret = wasm.interpolateColor(ptr0, ptr1, t);
    return WasmColor.__wrap(ret);
}

/**
 * @param {Array<any>} anchors1
 * @param {Array<any>} handles1
 * @param {Array<any>} handles2
 * @param {Array<any>} anchors2
 * @returns {Array<any>}
 */
export function pointsFromAnchorsAndHandles(anchors1, handles1, handles2, anchors2) {
    const ret = wasm.pointsFromAnchorsAndHandles(anchors1, handles1, handles2, anchors2);
    return ret;
}

/**
 * @param {Array<any>} points
 * @param {Array<any>} point
 * @returns {Array<any>}
 */
export function startNewPath(points, point) {
    const ret = wasm.startNewPath(points, point);
    return ret;
}

/**
 * @param {Array<any>} points
 * @param {Array<any>} point
 * @returns {Array<any>}
 */
export function startNewPath3D(points, point) {
    const ret = wasm.startNewPath3D(points, point);
    return ret;
}

/**
 * @param {Array<any>} points
 * @returns {boolean}
 */
export function hasNewPathBegun(points) {
    const ret = wasm.hasNewPathBegun(points);
    return ret !== 0;
}

/**
 * @param {Array<any>} points
 * @returns {boolean}
 */
export function hasNewPathBegun3D(points) {
    const ret = wasm.hasNewPathBegun3D(points);
    return ret !== 0;
}

/**
 * @param {number} x1
 * @param {number} y1
 * @param {number} z1
 * @param {number} x2
 * @param {number} y2
 * @param {number} z2
 * @returns {boolean}
 */
export function considerPointsEquals3D(x1, y1, z1, x2, y2, z2) {
    const ret = wasm.considerPointsEquals3D(x1, y1, z1, x2, y2, z2);
    return ret !== 0;
}

/**
 * @param {Array<any>} points
 * @param {number} n
 * @returns {Array<any>}
 */
export function getNthSubpath(points, n) {
    const ret = wasm.getNthSubpath(points, n);
    return ret;
}

/**
 * @param {Array<any>} points
 * @param {number} n
 * @returns {Array<any>}
 */
export function getNthSubpath3D(points, n) {
    const ret = wasm.getNthSubpath3D(points, n);
    return ret;
}

/**
 * @param {number} n
 * @param {Array<any>} points
 * @returns {Array<any>}
 */
export function insertNCurvesToPointList3D(n, points) {
    const ret = wasm.insertNCurvesToPointList3D(n, points);
    return ret;
}

/**
 * @param {Array<any>} points1
 * @param {Array<any>} points2
 * @param {Array<any>} center_if_no_points
 * @returns {Array<any>}
 */
export function alignPoints3D(points1, points2, center_if_no_points) {
    const ret = wasm.alignPoints3D(points1, points2, center_if_no_points);
    return ret;
}

/**
 * @param {number} n
 * @param {Array<any>} points
 * @returns {Array<any>}
 */
export function insertNCurvesToPointList(n, points) {
    const ret = wasm.insertNCurvesToPointList(n, points);
    return ret;
}

/**
 * @param {WasmThreeDObject} obj1
 * @param {WasmThreeDObject} obj2
 * @returns {Array<any>}
 */
export function nullPointAlign3D(obj1, obj2) {
    _assertClass(obj1, WasmThreeDObject);
    var ptr0 = obj1.__destroy_into_raw();
    _assertClass(obj2, WasmThreeDObject);
    var ptr1 = obj2.__destroy_into_raw();
    const ret = wasm.nullPointAlign3D(ptr0, ptr1);
    return ret;
}

/**
 * @param {WasmVectorObject} vec_obj1
 * @param {WasmVectorObject} vec_obj2
 * @returns {Array<any>}
 */
export function nullPointAlign(vec_obj1, vec_obj2) {
    _assertClass(vec_obj1, WasmVectorObject);
    var ptr0 = vec_obj1.__destroy_into_raw();
    _assertClass(vec_obj2, WasmVectorObject);
    var ptr1 = vec_obj2.__destroy_into_raw();
    const ret = wasm.nullPointAlign(ptr0, ptr1);
    return ret;
}

/**
 * @param {Array<any>} points1
 * @param {Array<any>} points2
 * @param {Array<any>} center_if_no_points
 * @returns {Array<any>}
 */
export function alignPoints(points1, points2, center_if_no_points) {
    const ret = wasm.alignPoints(points1, points2, center_if_no_points);
    return ret;
}

/**
 * @param {WasmVectorObject} vec_obj
 * @param {number} n
 * @param {Array<any>} center_if_no_points
 * @returns {WasmVectorObject}
 */
export function addNMoreSubobjects(vec_obj, n, center_if_no_points) {
    _assertClass(vec_obj, WasmVectorObject);
    var ptr0 = vec_obj.__destroy_into_raw();
    const ret = wasm.addNMoreSubobjects(ptr0, n, center_if_no_points);
    return WasmVectorObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} obj_3d
 * @param {number} n
 * @param {Array<any>} center_if_no_points
 * @returns {WasmThreeDObject}
 */
export function addNMoreSubobjects3D(obj_3d, n, center_if_no_points) {
    _assertClass(obj_3d, WasmThreeDObject);
    var ptr0 = obj_3d.__destroy_into_raw();
    const ret = wasm.addNMoreSubobjects3D(ptr0, n, center_if_no_points);
    return WasmThreeDObject.__wrap(ret);
}

/**
 * @param {WasmThreeDObject} obj_3d1
 * @param {WasmThreeDObject} obj_3d2
 * @param {Array<any>} center_if_no_points
 * @returns {Array<any>}
 */
export function alignSubobjects3D(obj_3d1, obj_3d2, center_if_no_points) {
    _assertClass(obj_3d1, WasmThreeDObject);
    var ptr0 = obj_3d1.__destroy_into_raw();
    _assertClass(obj_3d2, WasmThreeDObject);
    var ptr1 = obj_3d2.__destroy_into_raw();
    const ret = wasm.alignSubobjects3D(ptr0, ptr1, center_if_no_points);
    return ret;
}

/**
 * @param {WasmThreeDObject} obj_3d1
 * @param {WasmThreeDObject} obj_3d2
 * @param {boolean} skip_point_align
 * @param {Array<any>} center_if_no_points
 * @returns {Array<any>}
 */
export function alignData3D(obj_3d1, obj_3d2, skip_point_align, center_if_no_points) {
    _assertClass(obj_3d1, WasmThreeDObject);
    var ptr0 = obj_3d1.__destroy_into_raw();
    _assertClass(obj_3d2, WasmThreeDObject);
    var ptr1 = obj_3d2.__destroy_into_raw();
    const ret = wasm.alignData3D(ptr0, ptr1, skip_point_align, center_if_no_points);
    return ret;
}

/**
 * @param {WasmVectorObject} vec_obj1
 * @param {WasmVectorObject} vec_obj2
 * @param {Array<any>} center_if_no_points
 * @returns {(WasmVectorObject)[]}
 */
export function alignSubobjects(vec_obj1, vec_obj2, center_if_no_points) {
    _assertClass(vec_obj1, WasmVectorObject);
    var ptr0 = vec_obj1.__destroy_into_raw();
    _assertClass(vec_obj2, WasmVectorObject);
    var ptr1 = vec_obj2.__destroy_into_raw();
    const ret = wasm.alignSubobjects(ptr0, ptr1, center_if_no_points);
    var v3 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
    wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
    return v3;
}

/**
 * @param {WasmVectorObject} vec_obj1
 * @param {WasmVectorObject} vec_obj2
 * @param {boolean} skip_point_align
 * @param {Array<any>} center_if_no_points
 * @returns {Array<any>}
 */
export function alignData(vec_obj1, vec_obj2, skip_point_align, center_if_no_points) {
    _assertClass(vec_obj1, WasmVectorObject);
    var ptr0 = vec_obj1.__destroy_into_raw();
    _assertClass(vec_obj2, WasmVectorObject);
    var ptr1 = vec_obj2.__destroy_into_raw();
    const ret = wasm.alignData(ptr0, ptr1, skip_point_align, center_if_no_points);
    return ret;
}

/**
 * @param {number} x
 * @param {number} y
 * @param {number} t
 * @returns {Array<any>}
 */
export function integerInterpolate(x, y, t) {
    const ret = wasm.integerInterpolate(x, y, t);
    return ret;
}

/**
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @returns {Array<any>}
 */
export function lineAsCubicBezier(x1, y1, x2, y2) {
    const ret = wasm.lineAsCubicBezier(x1, y1, x2, y2);
    return ret;
}

/**
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} x3
 * @param {number} y3
 * @returns {Array<any>}
 */
export function quadraticBezierAsCubicBezier(x1, y1, x2, y2, x3, y3) {
    const ret = wasm.quadraticBezierAsCubicBezier(x1, y1, x2, y2, x3, y3);
    return ret;
}

/**
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @returns {boolean}
 */
export function considerPointsEquals(x1, y1, x2, y2) {
    const ret = wasm.considerPointsEquals(x1, y1, x2, y2);
    return ret !== 0;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function sigmoid(t) {
    const ret = wasm.sigmoid(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function linear(t) {
    const ret = wasm.linear(t);
    return ret;
}

/**
 * @param {number} t
 * @param {number} inflection
 * @returns {number}
 */
export function smooth(t, inflection) {
    const ret = wasm.smooth(t, inflection);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function smoothstep(t) {
    const ret = wasm.smoothstep(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function smootherstep(t) {
    const ret = wasm.smootherstep(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function smoothererstep(t) {
    const ret = wasm.smoothererstep(t);
    return ret;
}

/**
 * @param {number} t
 * @param {number} inflection
 * @returns {number}
 */
export function rushInto(t, inflection) {
    const ret = wasm.rushInto(t, inflection);
    return ret;
}

/**
 * @param {number} t
 * @param {number} inflection
 * @returns {number}
 */
export function rushFrom(t, inflection) {
    const ret = wasm.rushFrom(t, inflection);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function slowInto(t) {
    const ret = wasm.easeOutCirc(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function doubleSmooth(t) {
    const ret = wasm.doubleSmooth(t);
    return ret;
}

/**
 * @param {number} t
 * @param {number} inflection
 * @returns {number}
 */
export function thereAndBack(t, inflection) {
    const ret = wasm.thereAndBack(t, inflection);
    return ret;
}

/**
 * @param {number} t
 * @param {number} pause_ratio
 * @returns {number}
 */
export function thereAndBackWithPause(t, pause_ratio) {
    const ret = wasm.thereAndBackWithPause(t, pause_ratio);
    return ret;
}

/**
 * @param {number} t
 * @param {number} pull_factor
 * @returns {number}
 */
export function runningStart(t, pull_factor) {
    const ret = wasm.runningStart(t, pull_factor);
    return ret;
}

/**
 * @param {Function} func
 * @param {number} t
 * @param {number} proportion
 * @returns {number}
 */
export function notQuiteThere(func, t, proportion) {
    const ret = wasm.notQuiteThere(func, t, proportion);
    return ret;
}

/**
 * @param {number} t
 * @param {number} wiggles
 * @returns {number}
 */
export function wiggle(t, wiggles) {
    const ret = wasm.wiggle(t, wiggles);
    return ret;
}

/**
 * @param {Function} func
 * @param {number} t
 * @param {number} a
 * @param {number} b
 * @returns {number}
 */
export function squishRateFunc(func, t, a, b) {
    const ret = wasm.squishRateFunc(func, t, a, b);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function lingering(t) {
    const ret = wasm.lingering(t);
    return ret;
}

/**
 * @param {number} t
 * @param {number} half_life
 * @returns {number}
 */
export function exponentialDecay(t, half_life) {
    const ret = wasm.exponentialDecay(t, half_life);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInSine(t) {
    const ret = wasm.easeInSine(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeOutSine(t) {
    const ret = wasm.easeOutSine(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInOutSine(t) {
    const ret = wasm.easeInOutSine(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInQuad(t) {
    const ret = wasm.easeInQuad(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeOutQuad(t) {
    const ret = wasm.easeOutQuad(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInOutQuad(t) {
    const ret = wasm.easeInOutQuad(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInCubic(t) {
    const ret = wasm.easeInCubic(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeOutCubic(t) {
    const ret = wasm.easeOutCubic(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInOutCubic(t) {
    const ret = wasm.easeInOutCubic(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInQuart(t) {
    const ret = wasm.easeInQuart(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeOutQuart(t) {
    const ret = wasm.easeOutQuart(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInOutQuart(t) {
    const ret = wasm.easeInOutQuart(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInQuint(t) {
    const ret = wasm.easeInQuint(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeOutQuint(t) {
    const ret = wasm.easeOutQuint(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInOutQuint(t) {
    const ret = wasm.easeInOutQuint(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInExpo(t) {
    const ret = wasm.easeInExpo(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeOutExpo(t) {
    const ret = wasm.easeOutExpo(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInOutExpo(t) {
    const ret = wasm.easeInOutExpo(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInCirc(t) {
    const ret = wasm.easeInCirc(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeOutCirc(t) {
    const ret = wasm.easeOutCirc(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInOutCirc(t) {
    const ret = wasm.easeInOutCirc(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInBack(t) {
    const ret = wasm.easeInBack(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeOutBack(t) {
    const ret = wasm.easeInBack(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInOutBack(t) {
    const ret = wasm.easeInOutBack(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInElastic(t) {
    const ret = wasm.easeInElastic(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeOutElastic(t) {
    const ret = wasm.easeOutElastic(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInOutElastic(t) {
    const ret = wasm.easeInOutElastic(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeOutBounce(t) {
    const ret = wasm.easeInBounce(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInBounce(t) {
    const ret = wasm.easeInBounce(t);
    return ret;
}

/**
 * @param {number} t
 * @returns {number}
 */
export function easeInOutBounce(t) {
    const ret = wasm.easeInOutBounce(t);
    return ret;
}

/**
 * @param {string} text
 * @param {Map<any, any>} font_array_buffers
 * @param {string | undefined} [font_family]
 * @param {string | undefined} [font_weight]
 * @param {string | undefined} [font_style]
 * @param {number | undefined} [x]
 * @param {number | undefined} [y]
 * @param {number | undefined} [font_size]
 * @returns {Promise<WasmVectorObject>}
 */
export function textToVector(text, font_array_buffers, font_family, font_weight, font_style, x, y, font_size) {
    const ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    var ptr1 = isLikeNone(font_family) ? 0 : passStringToWasm0(font_family, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    var ptr2 = isLikeNone(font_weight) ? 0 : passStringToWasm0(font_weight, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len2 = WASM_VECTOR_LEN;
    var ptr3 = isLikeNone(font_style) ? 0 : passStringToWasm0(font_style, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len3 = WASM_VECTOR_LEN;
    const ret = wasm.textToVector(ptr0, len0, font_array_buffers, ptr1, len1, ptr2, len2, ptr3, len3, !isLikeNone(x), isLikeNone(x) ? 0 : x, !isLikeNone(y), isLikeNone(y) ? 0 : y, !isLikeNone(font_size), isLikeNone(font_size) ? 0 : font_size);
    return ret;
}

let cachedUint32ArrayMemory0 = null;

function getUint32ArrayMemory0() {
    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {
        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);
    }
    return cachedUint32ArrayMemory0;
}

function passArray32ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 4, 4) >>> 0;
    getUint32ArrayMemory0().set(arg, ptr / 4);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
/**
 * @param {string} expression
 * @param {Map<any, any> | undefined} [font_array_buffers]
 * @returns {Promise<WasmVectorObject>}
 */
export function mathjax(expression, font_array_buffers) {
    const ptr0 = passStringToWasm0(expression, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm.mathjax(ptr0, len0, isLikeNone(font_array_buffers) ? 0 : addToExternrefTable0(font_array_buffers));
    return ret;
}

function __wbg_adapter_34(arg0, arg1, arg2, arg3, arg4) {
    const ret = wasm.closure267_externref_shim(arg0, arg1, arg2, arg3, arg4);
    return ret;
}

function __wbg_adapter_37(arg0, arg1) {
    const ret = wasm.closure271_externref_shim(arg0, arg1);
    return ret;
}

function __wbg_adapter_40(arg0, arg1, arg2, arg3) {
    const ret = wasm.closure274_externref_shim(arg0, arg1, arg2, arg3);
    return ret;
}

function __wbg_adapter_43(arg0, arg1) {
    wasm._dyn_core__ops__function__Fn_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hf36964feddba7109(arg0, arg1);
}

function __wbg_adapter_46(arg0, arg1, arg2) {
    const ret = wasm.closure280_externref_shim(arg0, arg1, arg2);
    return ret;
}

function __wbg_adapter_49(arg0, arg1, arg2) {
    wasm.closure310_externref_shim(arg0, arg1, arg2);
}

function __wbg_adapter_614(arg0, arg1, arg2, arg3) {
    wasm.closure357_externref_shim(arg0, arg1, arg2, arg3);
}

const __wbindgen_enum_CanvasWindingRule = ["nonzero", "evenodd"];

const SVGSceneFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_svgscene_free(ptr >>> 0, 1));

export class SVGScene {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SVGSceneFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_svgscene_free(ptr, 0);
    }
    /**
     * @param {number} width
     * @param {number} height
     * @param {number} fps
     */
    constructor(width, height, fps) {
        const ret = wasm.svgscene_new_js(width, height, fps);
        this.__wbg_ptr = ret >>> 0;
        SVGSceneFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {number}
     */
    getFps() {
        const ret = wasm.svgscene_getFps(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {number}
     */
    getHeight() {
        const ret = wasm.svgscene_getHeight(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {number}
     */
    getWidth() {
        const ret = wasm.svgscene_getWidth(this.__wbg_ptr);
        return ret >>> 0;
    }
    clear() {
        wasm.svgscene_clear(this.__wbg_ptr);
    }
    /**
     * @param {number} index
     * @param {Function} updater
     */
    setUpdater(index, updater) {
        wasm.svgscene_setUpdater(this.__wbg_ptr, index, updater);
    }
    /**
     * @returns {Promise<any>}
     */
    renderFrame() {
        const ret = wasm.svgscene_renderFrame(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} index
     * @returns {Promise<void>}
     */
    update(index) {
        const ret = wasm.svgscene_update(this.__wbg_ptr, index);
        return ret;
    }
    /**
     * @param {number} index
     */
    removeUpdater(index) {
        wasm.svgscene_removeUpdater(this.__wbg_ptr, index);
    }
    /**
     * @param {number} n
     */
    restore(n) {
        wasm.svgscene_restore(this.__wbg_ptr, n);
    }
    /**
     * @param {number} n
     */
    saveState(n) {
        wasm.svgscene_saveState(this.__wbg_ptr, n);
    }
    /**
     * @param {number} x
     * @param {number} y
     */
    setTopLeftCorner(x, y) {
        wasm.svgscene_setTopLeftCorner(this.__wbg_ptr, x, y);
    }
    /**
     * @param {number} x
     * @param {number} y
     */
    setBottomRightCorner(x, y) {
        wasm.svgscene_setBottomRightCorner(this.__wbg_ptr, x, y);
    }
    /**
     * @returns {Array<any>}
     */
    getTopLeftCorner() {
        const ret = wasm.svgscene_getTopLeftCorner(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Array<any>}
     */
    getBottomRightCorner() {
        const ret = wasm.svgscene_getBottomRightCorner(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {WasmGradientImageOrColor} background
     */
    setBackground(background) {
        _assertClass(background, WasmGradientImageOrColor);
        var ptr0 = background.__destroy_into_raw();
        wasm.svgscene_setBackground(this.__wbg_ptr, ptr0);
    }
    /**
     * @param {WasmVectorObject} vec_obj
     */
    add(vec_obj) {
        _assertClass(vec_obj, WasmVectorObject);
        var ptr0 = vec_obj.__destroy_into_raw();
        wasm.svgscene_add(this.__wbg_ptr, ptr0);
    }
    /**
     * @param {number} index
     * @param {WasmVectorObject} vec_obj
     */
    insert(index, vec_obj) {
        _assertClass(vec_obj, WasmVectorObject);
        var ptr0 = vec_obj.__destroy_into_raw();
        wasm.svgscene_insert(this.__wbg_ptr, index, ptr0);
    }
    /**
     * @param {number} index
     */
    remove(index) {
        wasm.svgscene_remove(this.__wbg_ptr, index);
    }
    /**
     * @param {Array<any>} object_indices
     * @returns {Map<any, any>}
     */
    getObjectsFromIndices(object_indices) {
        const ret = wasm.svgscene_getObjectsFromIndices(this.__wbg_ptr, object_indices);
        return ret;
    }
    /**
     * @param {HTMLDivElement} div_container
     */
    setDivContainer(div_container) {
        wasm.svgscene_setDivContainer(this.__wbg_ptr, div_container);
    }
    /**
     * @param {number} duration_in_ms
     * @returns {Promise<void>}
     */
    sleep(duration_in_ms) {
        const ret = wasm.svgscene_sleep(this.__wbg_ptr, duration_in_ms);
        return ret;
    }
    /**
     * @param {Function} animation_func
     * @param {Uint32Array} object_indices
     * @param {number} duration_in_frames
     * @param {Function} rate_func
     * @returns {Promise<void>}
     */
    play(animation_func, object_indices, duration_in_frames, rate_func) {
        const ptr0 = passArray32ToWasm0(object_indices, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.svgscene_play(this.__wbg_ptr, animation_func, ptr0, len0, duration_in_frames, rate_func);
        return ret;
    }
    /**
     * @param {Function} animation_func
     * @param {Array<any>} objects
     * @param {number} t
     * @returns {Promise<void>}
     */
    makeFrame(animation_func, objects, t) {
        const ret = wasm.svgscene_makeFrame(this.__wbg_ptr, animation_func, objects, t);
        return ret;
    }
    /**
     * @param {Array<any>} objects
     */
    setObjects(objects) {
        wasm.svgscene_setObjects(this.__wbg_ptr, objects);
    }
    /**
     * @returns {Array<any>}
     */
    getObjects() {
        const ret = wasm.svgscene_getObjects(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} duration_in_frames
     * @param {Uint32Array} object_indices
     * @returns {Promise<void>}
     */
    wait(duration_in_frames, object_indices) {
        const ptr0 = passArray32ToWasm0(object_indices, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.svgscene_wait(this.__wbg_ptr, duration_in_frames, ptr0, len0);
        return ret;
    }
    /**
     * @param {Function} callback
     */
    setOnRendered(callback) {
        wasm.svgscene_setOnRendered(this.__wbg_ptr, callback);
    }
    /**
     * @returns {Promise<void>}
     */
    onRendered() {
        const ret = wasm.svgscene_onRendered(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} index
     * @param {string} id
     */
    setClass(index, id) {
        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.svgscene_setClass(this.__wbg_ptr, index, ptr0, len0);
    }
    /**
     * @param {Function} condition
     * @param {Uint32Array} object_indices
     * @returns {Promise<void>}
     */
    waitUntil(condition, object_indices) {
        const ptr0 = passArray32ToWasm0(object_indices, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.svgscene_waitUntil(this.__wbg_ptr, condition, ptr0, len0);
        return ret;
    }
    /**
     * @param {number} index
     */
    removeClass(index) {
        wasm.svgscene_removeClass(this.__wbg_ptr, index);
    }
    /**
     * @param {number} index
     * @returns {string | undefined}
     */
    getClass(index) {
        const ret = wasm.svgscene_getClass(this.__wbg_ptr, index);
        let v1;
        if (ret[0] !== 0) {
            v1 = getStringFromWasm0(ret[0], ret[1]).slice();
            wasm.__wbindgen_free(ret[0], ret[1] * 1, 1);
        }
        return v1;
    }
    /**
     * @returns {HTMLDivElement}
     */
    getDivContainer() {
        const ret = wasm.svgscene_getDivContainer(this.__wbg_ptr);
        return ret;
    }
}

const SceneFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_scene_free(ptr >>> 0, 1));

export class Scene {

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        SceneFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_scene_free(ptr, 0);
    }
    /**
     * @param {number} width
     * @param {number} height
     * @param {number} fps
     */
    constructor(width, height, fps) {
        const ret = wasm.scene_new_js(width, height, fps);
        this.__wbg_ptr = ret >>> 0;
        SceneFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {number}
     */
    getFps() {
        const ret = wasm.scene_getFps(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {number}
     */
    getHeight() {
        const ret = wasm.scene_getHeight(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {number}
     */
    getWidth() {
        const ret = wasm.scene_getWidth(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @param {Function} updater
     */
    setUpdater(index, updater) {
        wasm.scene_setUpdater(this.__wbg_ptr, index, updater);
    }
    /**
     * @param {number} index
     * @returns {Promise<void>}
     */
    update(index) {
        const ret = wasm.scene_update(this.__wbg_ptr, index);
        return ret;
    }
    /**
     * @param {number} index
     */
    removeUpdater(index) {
        wasm.scene_removeUpdater(this.__wbg_ptr, index);
    }
    /**
     * @returns {Promise<any>}
     */
    renderFrame() {
        const ret = wasm.scene_renderFrame(this.__wbg_ptr);
        return ret;
    }
    clear() {
        wasm.scene_clear(this.__wbg_ptr);
    }
    /**
     * @param {number} n
     */
    restore(n) {
        wasm.scene_restore(this.__wbg_ptr, n);
    }
    /**
     * @param {number} n
     */
    saveState(n) {
        wasm.scene_saveState(this.__wbg_ptr, n);
    }
    /**
     * @param {number} x
     * @param {number} y
     */
    setTopLeftCorner(x, y) {
        wasm.scene_setTopLeftCorner(this.__wbg_ptr, x, y);
    }
    /**
     * @param {number} x
     * @param {number} y
     */
    setBottomRightCorner(x, y) {
        wasm.scene_setBottomRightCorner(this.__wbg_ptr, x, y);
    }
    /**
     * @returns {Array<any>}
     */
    getTopLeftCorner() {
        const ret = wasm.scene_getTopLeftCorner(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Array<any>}
     */
    getBottomRightCorner() {
        const ret = wasm.scene_getBottomRightCorner(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {WasmGradientImageOrColor} background
     */
    setBackground(background) {
        _assertClass(background, WasmGradientImageOrColor);
        var ptr0 = background.__destroy_into_raw();
        wasm.scene_setBackground(this.__wbg_ptr, ptr0);
    }
    /**
     * @param {WasmVectorObject} vec_obj
     */
    add(vec_obj) {
        _assertClass(vec_obj, WasmVectorObject);
        var ptr0 = vec_obj.__destroy_into_raw();
        wasm.scene_add(this.__wbg_ptr, ptr0);
    }
    /**
     * @param {number} index
     * @param {WasmVectorObject} vec_obj
     */
    insert(index, vec_obj) {
        _assertClass(vec_obj, WasmVectorObject);
        var ptr0 = vec_obj.__destroy_into_raw();
        wasm.scene_insert(this.__wbg_ptr, index, ptr0);
    }
    /**
     * @param {number} index
     */
    remove(index) {
        wasm.scene_remove(this.__wbg_ptr, index);
    }
    /**
     * @returns {Array<any>}
     */
    getObjects() {
        const ret = wasm.scene_getObjects(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {Array<any>} object_indices
     * @returns {Map<any, any>}
     */
    getObjectsFromIndices(object_indices) {
        const ret = wasm.scene_getObjectsFromIndices(this.__wbg_ptr, object_indices);
        return ret;
    }
    /**
     * @param {CanvasRenderingContext2D} context
     */
    setCanvasContext(context) {
        wasm.scene_setCanvasContext(this.__wbg_ptr, context);
    }
    /**
     * @param {number} duration_in_ms
     * @returns {Promise<void>}
     */
    sleep(duration_in_ms) {
        const ret = wasm.scene_sleep(this.__wbg_ptr, duration_in_ms);
        return ret;
    }
    /**
     * @param {Array<any>} objects
     */
    setObjects(objects) {
        wasm.scene_setObjects(this.__wbg_ptr, objects);
    }
    /**
     * @param {Function} animation_func
     * @param {Uint32Array} object_indices
     * @param {number} duration_in_frames
     * @param {Function} rate_func
     * @returns {Promise<void>}
     */
    play(animation_func, object_indices, duration_in_frames, rate_func) {
        const ptr0 = passArray32ToWasm0(object_indices, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scene_play(this.__wbg_ptr, animation_func, ptr0, len0, duration_in_frames, rate_func);
        return ret;
    }
    /**
     * @param {Function} animation_func
     * @param {Array<any>} objects
     * @param {number} t
     * @returns {Promise<void>}
     */
    makeFrame(animation_func, objects, t) {
        const ret = wasm.scene_makeFrame(this.__wbg_ptr, animation_func, objects, t);
        return ret;
    }
    /**
     * @param {number} duration_in_frames
     * @param {Uint32Array} object_indices
     * @returns {Promise<void>}
     */
    wait(duration_in_frames, object_indices) {
        const ptr0 = passArray32ToWasm0(object_indices, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scene_wait(this.__wbg_ptr, duration_in_frames, ptr0, len0);
        return ret;
    }
    /**
     * @param {Function} callback
     */
    setOnRendered(callback) {
        wasm.scene_setOnRendered(this.__wbg_ptr, callback);
    }
    /**
     * @param {Function} condition
     * @param {Uint32Array} object_indices
     * @returns {Promise<void>}
     */
    waitUntil(condition, object_indices) {
        const ptr0 = passArray32ToWasm0(object_indices, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.scene_waitUntil(this.__wbg_ptr, condition, ptr0, len0);
        return ret;
    }
    /**
     * @returns {Promise<void>}
     */
    onRendered() {
        const ret = wasm.scene_onRendered(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Map<any, any>}
     */
    getLoadedImages() {
        const ret = wasm.scene_getLoadedImages(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {CanvasRenderingContext2D}
     */
    getContext() {
        const ret = wasm.scene_getContext(this.__wbg_ptr);
        return ret;
    }
}

const WasmCameraFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmcamera_free(ptr >>> 0, 1));

export class WasmCamera {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmCamera.prototype);
        obj.__wbg_ptr = ptr;
        WasmCameraFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmCameraFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmcamera_free(ptr, 0);
    }
    /**
     * @param {Array<any>} position
     * @param {Array<any>} rotation
     * @param {number} focal_distance
     * @param {number} zoom
     */
    constructor(position, rotation, focal_distance, zoom) {
        const ret = wasm.wasmcamera_new(position, rotation, focal_distance, zoom);
        this.__wbg_ptr = ret >>> 0;
        WasmCameraFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {Array<any>}
     */
    getPosition() {
        const ret = wasm.wasmcamera_getPosition(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Array<any>}
     */
    getRotation() {
        const ret = wasm.wasmcamera_getRotation(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getFocalDistance() {
        const ret = wasm.wasmcamera_getFocalDistance(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getZoom() {
        const ret = wasm.wasmcamera_getZoom(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {WasmCamera}
     */
    clone() {
        const ret = wasm.wasmcamera_clone(this.__wbg_ptr);
        return WasmCamera.__wrap(ret);
    }
}

const WasmColorFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmcolor_free(ptr >>> 0, 1));

export class WasmColor {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmColor.prototype);
        obj.__wbg_ptr = ptr;
        WasmColorFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof WasmColor)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmColorFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmcolor_free(ptr, 0);
    }
    /**
     * @param {number} r
     * @param {number} g
     * @param {number} b
     * @param {number} a
     */
    constructor(r, g, b, a) {
        const ret = wasm.wasmcolor_new(r, g, b, a);
        this.__wbg_ptr = ret >>> 0;
        WasmColorFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {number}
     */
    getR() {
        const ret = wasm.wasmcolor_getR(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getG() {
        const ret = wasm.wasmcolor_getG(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getB() {
        const ret = wasm.wasmcolor_getB(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getA() {
        const ret = wasm.wasmcolor_getA(this.__wbg_ptr);
        return ret;
    }
}

const WasmGradientImageOrColorFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmgradientimageorcolor_free(ptr >>> 0, 1));

export class WasmGradientImageOrColor {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmGradientImageOrColor.prototype);
        obj.__wbg_ptr = ptr;
        WasmGradientImageOrColorFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmGradientImageOrColorFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmgradientimageorcolor_free(ptr, 0);
    }
    /**
     * @param {WasmColor} color
     * @returns {WasmGradientImageOrColor}
     */
    static fromColor(color) {
        _assertClass(color, WasmColor);
        var ptr0 = color.__destroy_into_raw();
        const ret = wasm.wasmgradientimageorcolor_fromColor(ptr0);
        return WasmGradientImageOrColor.__wrap(ret);
    }
    /**
     * @param {WasmLinearGradient} linear_gradient
     * @returns {WasmGradientImageOrColor}
     */
    static fromLinearGradient(linear_gradient) {
        _assertClass(linear_gradient, WasmLinearGradient);
        var ptr0 = linear_gradient.__destroy_into_raw();
        const ret = wasm.wasmgradientimageorcolor_fromLinearGradient(ptr0);
        return WasmGradientImageOrColor.__wrap(ret);
    }
    /**
     * @param {WasmRadialGradient} radial_gradient
     * @returns {WasmGradientImageOrColor}
     */
    static fromRadialGradient(radial_gradient) {
        _assertClass(radial_gradient, WasmRadialGradient);
        var ptr0 = radial_gradient.__destroy_into_raw();
        const ret = wasm.wasmgradientimageorcolor_fromRadialGradient(ptr0);
        return WasmGradientImageOrColor.__wrap(ret);
    }
    /**
     * @param {WasmImage} image
     * @returns {WasmGradientImageOrColor}
     */
    static fromImage(image) {
        _assertClass(image, WasmImage);
        var ptr0 = image.__destroy_into_raw();
        const ret = wasm.wasmgradientimageorcolor_fromImage(ptr0);
        return WasmGradientImageOrColor.__wrap(ret);
    }
    /**
     * @returns {boolean}
     */
    isColor() {
        const ret = wasm.wasmgradientimageorcolor_isColor(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {boolean}
     */
    isLinearGradient() {
        const ret = wasm.wasmgradientimageorcolor_isLinearGradient(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {boolean}
     */
    isRadialGradient() {
        const ret = wasm.wasmgradientimageorcolor_isRadialGradient(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {boolean}
     */
    isImage() {
        const ret = wasm.wasmgradientimageorcolor_isImage(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {WasmColor | undefined}
     */
    getColor() {
        const ret = wasm.wasmgradientimageorcolor_getColor(this.__wbg_ptr);
        return ret === 0 ? undefined : WasmColor.__wrap(ret);
    }
    /**
     * @returns {WasmLinearGradient | undefined}
     */
    getLinearGradient() {
        const ret = wasm.wasmgradientimageorcolor_getLinearGradient(this.__wbg_ptr);
        return ret === 0 ? undefined : WasmLinearGradient.__wrap(ret);
    }
    /**
     * @returns {WasmRadialGradient | undefined}
     */
    getRadialGradient() {
        const ret = wasm.wasmgradientimageorcolor_getRadialGradient(this.__wbg_ptr);
        return ret === 0 ? undefined : WasmRadialGradient.__wrap(ret);
    }
    /**
     * @returns {WasmImage | undefined}
     */
    getImage() {
        const ret = wasm.wasmgradientimageorcolor_getImage(this.__wbg_ptr);
        return ret === 0 ? undefined : WasmImage.__wrap(ret);
    }
    /**
     * @returns {WasmGradientImageOrColor}
     */
    clone() {
        const ret = wasm.wasmgradientimageorcolor_clone(this.__wbg_ptr);
        return WasmGradientImageOrColor.__wrap(ret);
    }
}

const WasmGradientStopFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmgradientstop_free(ptr >>> 0, 1));

export class WasmGradientStop {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmGradientStop.prototype);
        obj.__wbg_ptr = ptr;
        WasmGradientStopFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof WasmGradientStop)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmGradientStopFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmgradientstop_free(ptr, 0);
    }
    /**
     * @param {number} offset
     * @param {WasmColor} color
     */
    constructor(offset, color) {
        _assertClass(color, WasmColor);
        var ptr0 = color.__destroy_into_raw();
        const ret = wasm.wasmgradientstop_new(offset, ptr0);
        this.__wbg_ptr = ret >>> 0;
        WasmGradientStopFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {number}
     */
    getOffset() {
        const ret = wasm.wasmgradientstop_getOffset(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {WasmColor}
     */
    getColor() {
        const ret = wasm.wasmgradientstop_getColor(this.__wbg_ptr);
        return WasmColor.__wrap(ret);
    }
}

const WasmImageFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmimage_free(ptr >>> 0, 1));

export class WasmImage {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmImage.prototype);
        obj.__wbg_ptr = ptr;
        WasmImageFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmImageFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmimage_free(ptr, 0);
    }
    /**
     * @param {string} image_base64
     * @param {string} mime_type
     * @param {number} top
     * @param {number} left
     * @param {number} bottom
     * @param {number} right
     * @param {number} alpha
     */
    constructor(image_base64, mime_type, top, left, bottom, right, alpha) {
        const ptr0 = passStringToWasm0(image_base64, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passStringToWasm0(mime_type, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.wasmimage_new(ptr0, len0, ptr1, len1, top, left, bottom, right, alpha);
        this.__wbg_ptr = ret >>> 0;
        WasmImageFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {string}
     */
    getImageBase64() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.wasmimage_getImageBase64(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    getMimeType() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.wasmimage_getMimeType(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {number}
     */
    getTop() {
        const ret = wasm.wasmcolor_getG(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getLeft() {
        const ret = wasm.wasmcolor_getR(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getBottom() {
        const ret = wasm.wasmcolor_getA(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getRight() {
        const ret = wasm.wasmcolor_getB(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getAlpha() {
        const ret = wasm.wasmgradientstop_getOffset(this.__wbg_ptr);
        return ret;
    }
}

const WasmLightSourceFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmlightsource_free(ptr >>> 0, 1));

export class WasmLightSource {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmLightSource.prototype);
        obj.__wbg_ptr = ptr;
        WasmLightSourceFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmLightSourceFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmlightsource_free(ptr, 0);
    }
    /**
     * @param {Array<any>} position
     */
    constructor(position) {
        const ret = wasm.wasmlightsource_new(position);
        this.__wbg_ptr = ret >>> 0;
        WasmLightSourceFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {Array<any>}
     */
    getPosition() {
        const ret = wasm.wasmlightsource_getPosition(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {WasmLightSource}
     */
    clone() {
        const ret = wasm.wasmlightsource_clone(this.__wbg_ptr);
        return WasmLightSource.__wrap(ret);
    }
}

const WasmLinearGradientFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmlineargradient_free(ptr >>> 0, 1));

export class WasmLinearGradient {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmLinearGradient.prototype);
        obj.__wbg_ptr = ptr;
        WasmLinearGradientFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmLinearGradientFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmlineargradient_free(ptr, 0);
    }
    /**
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @param {(WasmGradientStop)[]} stops
     * @param {number} alpha
     */
    constructor(x1, y1, x2, y2, stops, alpha) {
        const ptr0 = passArrayJsValueToWasm0(stops, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmlineargradient_new(x1, y1, x2, y2, ptr0, len0, alpha);
        this.__wbg_ptr = ret >>> 0;
        WasmLinearGradientFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {number}
     */
    getX1() {
        const ret = wasm.wasmcolor_getR(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getY1() {
        const ret = wasm.wasmcolor_getG(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getX2() {
        const ret = wasm.wasmcolor_getB(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getY2() {
        const ret = wasm.wasmcolor_getA(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {(WasmGradientStop)[]}
     */
    getStops() {
        const ret = wasm.wasmlineargradient_getStops(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @returns {number}
     */
    getAlpha() {
        const ret = wasm.wasmgradientstop_getOffset(this.__wbg_ptr);
        return ret;
    }
}

const WasmRadialGradientFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmradialgradient_free(ptr >>> 0, 1));

export class WasmRadialGradient {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmRadialGradient.prototype);
        obj.__wbg_ptr = ptr;
        WasmRadialGradientFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmRadialGradientFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmradialgradient_free(ptr, 0);
    }
    /**
     * @param {number} cx
     * @param {number} cy
     * @param {number} r
     * @param {number} fx
     * @param {number} fy
     * @param {(WasmGradientStop)[]} stops
     * @param {number} alpha
     */
    constructor(cx, cy, r, fx, fy, stops, alpha) {
        const ptr0 = passArrayJsValueToWasm0(stops, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmradialgradient_new(cx, cy, r, fx, fy, ptr0, len0, alpha);
        this.__wbg_ptr = ret >>> 0;
        WasmRadialGradientFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {number}
     */
    getCx() {
        const ret = wasm.wasmcolor_getR(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getCy() {
        const ret = wasm.wasmcolor_getG(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getR() {
        const ret = wasm.wasmcolor_getB(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getFx() {
        const ret = wasm.wasmcolor_getA(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getFy() {
        const ret = wasm.wasmgradientstop_getOffset(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {(WasmGradientStop)[]}
     */
    getStops() {
        const ret = wasm.wasmradialgradient_getStops(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @returns {number}
     */
    getAlpha() {
        const ret = wasm.wasmradialgradient_getAlpha(this.__wbg_ptr);
        return ret;
    }
}

const WasmThreeDObjectFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmthreedobject_free(ptr >>> 0, 1));

export class WasmThreeDObject {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmThreeDObject.prototype);
        obj.__wbg_ptr = ptr;
        WasmThreeDObjectFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof WasmThreeDObject)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmThreeDObjectFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmthreedobject_free(ptr, 0);
    }
    /**
     * @param {Array<any>} points
     * @param {(WasmThreeDObject)[]} subobjects
     * @param {WasmGradientImageOrColor} fill
     * @param {WasmGradientImageOrColor} stroke
     * @param {number} stroke_width
     * @param {number} index
     */
    constructor(points, subobjects, fill, stroke, stroke_width, index) {
        const ptr0 = passArrayJsValueToWasm0(subobjects, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        _assertClass(fill, WasmGradientImageOrColor);
        var ptr1 = fill.__destroy_into_raw();
        _assertClass(stroke, WasmGradientImageOrColor);
        var ptr2 = stroke.__destroy_into_raw();
        const ret = wasm.wasmthreedobject_new(points, ptr0, len0, ptr1, ptr2, stroke_width, index);
        this.__wbg_ptr = ret >>> 0;
        WasmThreeDObjectFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {Array<any>}
     */
    getPoints() {
        const ret = wasm.wasmthreedobject_getPoints(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {(WasmThreeDObject)[]}
     */
    getSubobjects() {
        const ret = wasm.wasmthreedobject_getSubobjects(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @returns {WasmGradientImageOrColor}
     */
    getFill() {
        const ret = wasm.wasmthreedobject_getFill(this.__wbg_ptr);
        return WasmGradientImageOrColor.__wrap(ret);
    }
    /**
     * @returns {WasmGradientImageOrColor}
     */
    getStroke() {
        const ret = wasm.wasmthreedobject_getStroke(this.__wbg_ptr);
        return WasmGradientImageOrColor.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    getStrokeWidth() {
        const ret = wasm.wasmthreedobject_getStrokeWidth(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Array<any>}
     */
    getAnchorsAndHandles() {
        const ret = wasm.wasmthreedobject_getAnchorsAndHandles(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {Array<any>} anchors_and_handles
     * @returns {WasmThreeDObject}
     */
    setAnchorsAndHandles(anchors_and_handles) {
        const ret = wasm.wasmthreedobject_setAnchorsAndHandles(this.__wbg_ptr, anchors_and_handles);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {number} factor
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    scaleHandleToAnchorDistances(factor, recursive) {
        const ret = wasm.wasmthreedobject_scaleHandleToAnchorDistances(this.__wbg_ptr, factor, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {Array<any>} points
     * @returns {WasmThreeDObject}
     */
    setPoints(points) {
        const ret = wasm.wasmthreedobject_setPoints(this.__wbg_ptr, points);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {(WasmThreeDObject)[]} subobjects
     * @returns {WasmThreeDObject}
     */
    setSubobjects(subobjects) {
        const ptr0 = passArrayJsValueToWasm0(subobjects, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmthreedobject_setSubobjects(this.__wbg_ptr, ptr0, len0);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {WasmGradientImageOrColor} fill
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    setFill(fill, recursive) {
        _assertClass(fill, WasmGradientImageOrColor);
        var ptr0 = fill.__destroy_into_raw();
        const ret = wasm.wasmthreedobject_setFill(this.__wbg_ptr, ptr0, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {WasmGradientImageOrColor} stroke
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    setStroke(stroke, recursive) {
        _assertClass(stroke, WasmGradientImageOrColor);
        var ptr0 = stroke.__destroy_into_raw();
        const ret = wasm.wasmthreedobject_setStroke(this.__wbg_ptr, ptr0, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {number} stroke_width
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    setStrokeWidth(stroke_width, recursive) {
        const ret = wasm.wasmthreedobject_setStrokeWidth(this.__wbg_ptr, stroke_width, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @returns {Array<any>}
     */
    getCubicBezierTuples() {
        const ret = wasm.wasmthreedobject_getCubicBezierTuples(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} start_t
     * @param {number} end_t
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    getPartialCopy(start_t, end_t, recursive) {
        const ret = wasm.wasmthreedobject_getPartialCopy(this.__wbg_ptr, start_t, end_t, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {number} opacity
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    setFillOpacity(opacity, recursive) {
        const ret = wasm.wasmthreedobject_setFillOpacity(this.__wbg_ptr, opacity, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {number} opacity
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    setStrokeOpacity(opacity, recursive) {
        const ret = wasm.wasmthreedobject_setStrokeOpacity(this.__wbg_ptr, opacity, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    getFillOpacity() {
        const ret = wasm.wasmthreedobject_getFillOpacity(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getStrokeOpacity() {
        const ret = wasm.wasmthreedobject_getStrokeOpacity(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} key_x
     * @param {number} key_y
     * @param {number} key_z
     * @returns {Array<any>}
     */
    getCriticalPoint(key_x, key_y, key_z) {
        const ret = wasm.wasmthreedobject_getCriticalPoint(this.__wbg_ptr, key_x, key_y, key_z);
        return ret;
    }
    /**
     * @param {WasmThreeDObject} other
     * @param {Array<any>} direction
     * @param {number} buff
     * @param {Array<any>} aligned_edge
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    nextToOther(other, direction, buff, aligned_edge, recursive) {
        _assertClass(other, WasmThreeDObject);
        const ret = wasm.wasmthreedobject_nextToOther(this.__wbg_ptr, other.__wbg_ptr, direction, buff, aligned_edge, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {Array<any>} point
     * @param {Array<any>} direction
     * @param {number} buff
     * @param {Array<any>} aligned_edge
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    nextToPoint(point, direction, buff, aligned_edge, recursive) {
        const ret = wasm.wasmthreedobject_nextToPoint(this.__wbg_ptr, point, direction, buff, aligned_edge, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {Array<any>} direction
     * @param {number} buff
     * @param {Array<any>} aligned_edge
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    arrangeSubobjects(direction, buff, aligned_edge, recursive) {
        const ret = wasm.wasmthreedobject_arrangeSubobjects(this.__wbg_ptr, direction, buff, aligned_edge, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {number} factor
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    scale(factor, recursive) {
        const ret = wasm.wasmthreedobject_scale(this.__wbg_ptr, factor, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {Array<any>} factor
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    stretch(factor, recursive) {
        const ret = wasm.wasmthreedobject_stretch(this.__wbg_ptr, factor, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {Array<any>} shift
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    shift(shift, recursive) {
        const ret = wasm.wasmthreedobject_shift(this.__wbg_ptr, shift, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {number} angle
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    rotateX(angle, recursive) {
        const ret = wasm.wasmthreedobject_rotateX(this.__wbg_ptr, angle, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {number} angle
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    rotateY(angle, recursive) {
        const ret = wasm.wasmthreedobject_rotateY(this.__wbg_ptr, angle, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {number} angle
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    rotateZ(angle, recursive) {
        const ret = wasm.wasmthreedobject_rotateZ(this.__wbg_ptr, angle, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {WasmCamera} camera
     * @param {WasmLightSource} light_source
     * @returns {WasmVectorObject}
     */
    projectAndShade(camera, light_source) {
        _assertClass(camera, WasmCamera);
        _assertClass(light_source, WasmLightSource);
        const ret = wasm.wasmthreedobject_projectAndShade(this.__wbg_ptr, camera.__wbg_ptr, light_source.__wbg_ptr);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {Function} f
     * @param {boolean} recursive
     * @returns {Promise<WasmThreeDObject>}
     */
    applyFunction(f, recursive) {
        const ret = wasm.wasmthreedobject_applyFunction(this.__wbg_ptr, f, recursive);
        return ret;
    }
    /**
     * @param {Function} uv_function
     * @param {Array<any>} u_range
     * @param {Array<any>} v_range
     * @param {number} u_segments
     * @param {number} v_segments
     * @param {(WasmColor)[]} fills
     * @param {(WasmColor)[]} strokes
     * @param {number} stroke_width
     * @param {number | undefined} [index]
     * @returns {Promise<WasmThreeDObject>}
     */
    static fromUvFunction(uv_function, u_range, v_range, u_segments, v_segments, fills, strokes, stroke_width, index) {
        const ptr0 = passArrayJsValueToWasm0(fills, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ptr1 = passArrayJsValueToWasm0(strokes, wasm.__wbindgen_malloc);
        const len1 = WASM_VECTOR_LEN;
        const ret = wasm.wasmthreedobject_fromUvFunction(uv_function, u_range, v_range, u_segments, v_segments, ptr0, len0, ptr1, len1, stroke_width, isLikeNone(index) ? 0x100000001 : (index) >>> 0);
        return ret;
    }
    /**
     * @returns {Array<any>}
     */
    getBoundingBox() {
        const ret = wasm.wasmthreedobject_getBoundingBox(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Array<any>}
     */
    getCenter() {
        const ret = wasm.wasmthreedobject_getCenter(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Array<any>}
     */
    mergedPoints() {
        const ret = wasm.wasmthreedobject_mergedPoints(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {Array<any>} point
     * @param {boolean} recursive
     * @returns {WasmThreeDObject}
     */
    moveTo(point, recursive) {
        const ret = wasm.wasmthreedobject_moveTo(this.__wbg_ptr, point, recursive);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @returns {WasmThreeDObject}
     */
    clone() {
        const ret = wasm.wasmthreedobject_clone(this.__wbg_ptr);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    getIndex() {
        const ret = wasm.wasmthreedobject_getIndex(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} index
     * @returns {WasmThreeDObject}
     */
    setIndex(index) {
        const ret = wasm.wasmthreedobject_setIndex(this.__wbg_ptr, index);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @param {WasmVectorObject} vector_object
     * @returns {WasmThreeDObject}
     */
    static fromVectorObject(vector_object) {
        _assertClass(vector_object, WasmVectorObject);
        const ret = wasm.wasmthreedobject_fromVectorObject(vector_object.__wbg_ptr);
        return WasmThreeDObject.__wrap(ret);
    }
    /**
     * @returns {(WasmThreeDObject)[]}
     */
    getSubobjectsRecursively() {
        const ret = wasm.wasmthreedobject_getSubobjectsRecursively(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
}

const WasmVectorObjectFinalization = (typeof FinalizationRegistry === 'undefined')
    ? { register: () => {}, unregister: () => {} }
    : new FinalizationRegistry(ptr => wasm.__wbg_wasmvectorobject_free(ptr >>> 0, 1));

export class WasmVectorObject {

    static __wrap(ptr) {
        ptr = ptr >>> 0;
        const obj = Object.create(WasmVectorObject.prototype);
        obj.__wbg_ptr = ptr;
        WasmVectorObjectFinalization.register(obj, obj.__wbg_ptr, obj);
        return obj;
    }

    static __unwrap(jsValue) {
        if (!(jsValue instanceof WasmVectorObject)) {
            return 0;
        }
        return jsValue.__destroy_into_raw();
    }

    __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        WasmVectorObjectFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_wasmvectorobject_free(ptr, 0);
    }
    constructor() {
        const ret = wasm.wasmvectorobject_new();
        this.__wbg_ptr = ret >>> 0;
        WasmVectorObjectFinalization.register(this, this.__wbg_ptr, this);
        return this;
    }
    /**
     * @returns {number}
     */
    getIndex() {
        const ret = wasm.wasmvectorobject_getIndex(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @param {number} increment
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    incrementIndex(increment, recursive) {
        const ret = wasm.wasmvectorobject_incrementIndex(this.__wbg_ptr, increment, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @returns {Array<any>}
     */
    getPoints() {
        const ret = wasm.wasmvectorobject_getPoints(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {WasmVectorObject} new_subobject
     * @returns {WasmVectorObject}
     */
    add(new_subobject) {
        _assertClass(new_subobject, WasmVectorObject);
        var ptr0 = new_subobject.__destroy_into_raw();
        const ret = wasm.wasmvectorobject_add(this.__wbg_ptr, ptr0);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {number} index
     * @returns {WasmVectorObject}
     */
    remove(index) {
        const ret = wasm.wasmvectorobject_remove(this.__wbg_ptr, index);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {number} index
     * @returns {WasmVectorObject}
     */
    getSubobject(index) {
        const ret = wasm.wasmvectorobject_getSubobject(this.__wbg_ptr, index);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {number} start
     * @param {number} end
     * @returns {(WasmVectorObject)[]}
     */
    sliceSubobjects(start, end) {
        const ret = wasm.wasmvectorobject_sliceSubobjects(this.__wbg_ptr, start, end);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {number} index
     * @param {WasmVectorObject} new_subobject
     * @returns {WasmVectorObject}
     */
    setSubobject(index, new_subobject) {
        _assertClass(new_subobject, WasmVectorObject);
        var ptr0 = new_subobject.__destroy_into_raw();
        const ret = wasm.wasmvectorobject_setSubobject(this.__wbg_ptr, index, ptr0);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {number} start
     * @param {number} end
     * @param {(WasmVectorObject)[]} new_subobjects
     * @returns {WasmVectorObject}
     */
    setSliceSubobjects(start, end, new_subobjects) {
        const ptr0 = passArrayJsValueToWasm0(new_subobjects, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmvectorobject_setSliceSubobjects(this.__wbg_ptr, start, end, ptr0, len0);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @returns {WasmGradientImageOrColor}
     */
    getFill() {
        const ret = wasm.wasmvectorobject_getFill(this.__wbg_ptr);
        return WasmGradientImageOrColor.__wrap(ret);
    }
    /**
     * @returns {WasmGradientImageOrColor}
     */
    getStroke() {
        const ret = wasm.wasmvectorobject_getStroke(this.__wbg_ptr);
        return WasmGradientImageOrColor.__wrap(ret);
    }
    /**
     * @param {boolean | undefined} [with_points]
     * @returns {(WasmVectorObject)[]}
     */
    getSubobjectsRecursively(with_points) {
        const ret = wasm.wasmvectorobject_getSubobjectsRecursively(this.__wbg_ptr, isLikeNone(with_points) ? 0xFFFFFF : with_points ? 1 : 0);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {number} start
     * @param {number} end
     * @returns {WasmVectorObject}
     */
    getSubcurve(start, end) {
        const ret = wasm.wasmvectorobject_getSubcurve(this.__wbg_ptr, start, end);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @returns {number}
     */
    getStrokeWidth() {
        const ret = wasm.wasmvectorobject_getStrokeWidth(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {string}
     */
    getLineCap() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.wasmvectorobject_getLineCap(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @returns {string}
     */
    getLineJoin() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.wasmvectorobject_getLineJoin(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {number} start
     * @param {number} end
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    getPartialCopy(start, end, recursive) {
        const ret = wasm.wasmvectorobject_getPartialCopy(this.__wbg_ptr, start, end, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @returns {Array<any>}
     */
    getAnchorsAndHandles() {
        const ret = wasm.wasmvectorobject_getAnchorsAndHandles(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} scale
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    scaleHandleToAnchorDistances(scale, recursive) {
        const ret = wasm.wasmvectorobject_scaleHandleToAnchorDistances(this.__wbg_ptr, scale, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {Array<any>} anchors_and_handles
     * @returns {WasmVectorObject}
     */
    setAnchorsAndHandles(anchors_and_handles) {
        const ret = wasm.wasmvectorobject_setAnchorsAndHandles(this.__wbg_ptr, anchors_and_handles);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {number} n
     * @returns {Array<any>}
     */
    getNthCurvePoints(n) {
        const ret = wasm.wasmvectorobject_getNthCurvePoints(this.__wbg_ptr, n);
        return ret;
    }
    /**
     * @param {number} n
     * @param {number | undefined} [sample_points]
     * @returns {Float64Array}
     */
    getNthCurveLengthPieces(n, sample_points) {
        const ret = wasm.wasmvectorobject_getNthCurveLengthPieces(this.__wbg_ptr, n, isLikeNone(sample_points) ? 0x100000001 : (sample_points) >>> 0);
        var v1 = getArrayF64FromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 8, 8);
        return v1;
    }
    /**
     * @returns {number}
     */
    getNumCurves() {
        const ret = wasm.wasmvectorobject_getNumCurves(this.__wbg_ptr);
        return ret >>> 0;
    }
    /**
     * @returns {boolean}
     */
    isClosed() {
        const ret = wasm.wasmvectorobject_isClosed(this.__wbg_ptr);
        return ret !== 0;
    }
    /**
     * @returns {Array<any>}
     */
    getSubpaths() {
        const ret = wasm.wasmvectorobject_getSubpaths(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {Function} _function
     * @param {boolean} recursive
     * @param {Array<any> | undefined} [about_point]
     * @param {Array<any> | undefined} [about_edge]
     * @returns {Promise<WasmVectorObject>}
     */
    applyFunction(_function, recursive, about_point, about_edge) {
        const ret = wasm.wasmvectorobject_applyFunction(this.__wbg_ptr, _function, recursive, isLikeNone(about_point) ? 0 : addToExternrefTable0(about_point), isLikeNone(about_edge) ? 0 : addToExternrefTable0(about_edge));
        return ret;
    }
    /**
     * @param {number} n_pieces
     * @returns {WasmVectorObject}
     */
    getPieces(n_pieces) {
        const ret = wasm.wasmvectorobject_getPieces(this.__wbg_ptr, n_pieces);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @returns {Array<any>}
     */
    getCubicBezierTuples() {
        const ret = wasm.wasmvectorobject_getCubicBezierTuples(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {(WasmVectorObject)[]}
     */
    getSubobjects() {
        const ret = wasm.wasmvectorobject_getSubobjects(this.__wbg_ptr);
        var v1 = getArrayJsValueFromWasm0(ret[0], ret[1]).slice();
        wasm.__wbindgen_free(ret[0], ret[1] * 4, 4);
        return v1;
    }
    /**
     * @param {number} factor
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    scale(factor, recursive) {
        const ret = wasm.wasmvectorobject_scale(this.__wbg_ptr, factor, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {number} x_factor
     * @param {number} y_factor
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    stretch(x_factor, y_factor, recursive) {
        const ret = wasm.wasmvectorobject_stretch(this.__wbg_ptr, x_factor, y_factor, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {number} x_shift
     * @param {number} y_shift
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    shift(x_shift, y_shift, recursive) {
        const ret = wasm.wasmvectorobject_shift(this.__wbg_ptr, x_shift, y_shift, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @returns {Array<any>}
     */
    mergedPoints() {
        const ret = wasm.wasmvectorobject_mergedPoints(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Array<any>}
     */
    getBoundingBox() {
        const ret = wasm.wasmvectorobject_getBoundingBox(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Array<any>}
     */
    getCenter() {
        const ret = wasm.wasmvectorobject_getCenter(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {Array<any>}
     */
    getCenterOfMass() {
        const ret = wasm.wasmvectorobject_getCenterOfMass(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getHeight() {
        const ret = wasm.wasmvectorobject_getHeight(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getWidth() {
        const ret = wasm.wasmvectorobject_getWidth(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {number} index
     * @returns {WasmVectorObject}
     */
    setIndex(index) {
        const ret = wasm.wasmvectorobject_setIndex(this.__wbg_ptr, index);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {WasmGradientImageOrColor} fill
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    setFill(fill, recursive) {
        _assertClass(fill, WasmGradientImageOrColor);
        var ptr0 = fill.__destroy_into_raw();
        const ret = wasm.wasmvectorobject_setFill(this.__wbg_ptr, ptr0, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {number} opacity
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    setFillOpacity(opacity, recursive) {
        const ret = wasm.wasmvectorobject_setFillOpacity(this.__wbg_ptr, opacity, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {string} fill_rule
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    setFillRule(fill_rule, recursive) {
        const ptr0 = passStringToWasm0(fill_rule, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmvectorobject_setFillRule(this.__wbg_ptr, ptr0, len0, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {number} x
     * @param {number} y
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    moveTo(x, y, recursive) {
        const ret = wasm.wasmvectorobject_moveTo(this.__wbg_ptr, x, y, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @returns {string}
     */
    getFillRule() {
        let deferred1_0;
        let deferred1_1;
        try {
            const ret = wasm.wasmvectorobject_getFillRule(this.__wbg_ptr);
            deferred1_0 = ret[0];
            deferred1_1 = ret[1];
            return getStringFromWasm0(ret[0], ret[1]);
        } finally {
            wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
        }
    }
    /**
     * @param {WasmGradientImageOrColor} stroke
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    setStroke(stroke, recursive) {
        _assertClass(stroke, WasmGradientImageOrColor);
        var ptr0 = stroke.__destroy_into_raw();
        const ret = wasm.wasmvectorobject_setStroke(this.__wbg_ptr, ptr0, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {number} opacity
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    setStrokeOpacity(opacity, recursive) {
        const ret = wasm.wasmvectorobject_setStrokeOpacity(this.__wbg_ptr, opacity, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {number} width
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    setStrokeWidth(width, recursive) {
        const ret = wasm.wasmvectorobject_setStrokeWidth(this.__wbg_ptr, width, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {string} line_cap
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    setLineCap(line_cap, recursive) {
        const ptr0 = passStringToWasm0(line_cap, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmvectorobject_setLineCap(this.__wbg_ptr, ptr0, len0, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {string} line_join
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    setLineJoin(line_join, recursive) {
        const ptr0 = passStringToWasm0(line_join, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmvectorobject_setLineJoin(this.__wbg_ptr, ptr0, len0, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {Array<any>} points
     * @returns {WasmVectorObject}
     */
    setPoints(points) {
        const ret = wasm.wasmvectorobject_setPoints(this.__wbg_ptr, points);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {(WasmVectorObject)[]} subobjects
     * @returns {WasmVectorObject}
     */
    setSubobjects(subobjects) {
        const ptr0 = passArrayJsValueToWasm0(subobjects, wasm.__wbindgen_malloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.wasmvectorobject_setSubobjects(this.__wbg_ptr, ptr0, len0);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {number} angle
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    rotate(angle, recursive) {
        const ret = wasm.wasmvectorobject_rotate(this.__wbg_ptr, angle, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {number} key_x
     * @param {number} key_y
     * @returns {Array<any>}
     */
    getCriticalPoint(key_x, key_y) {
        const ret = wasm.wasmvectorobject_getCriticalPoint(this.__wbg_ptr, key_x, key_y);
        return ret;
    }
    /**
     * @returns {number}
     */
    getFillOpacity() {
        const ret = wasm.wasmvectorobject_getFillOpacity(this.__wbg_ptr);
        return ret;
    }
    /**
     * @returns {number}
     */
    getStrokeOpacity() {
        const ret = wasm.wasmvectorobject_getStrokeOpacity(this.__wbg_ptr);
        return ret;
    }
    /**
     * @param {WasmVectorObject} other
     * @returns {WasmVectorObject}
     */
    matchStyle(other) {
        _assertClass(other, WasmVectorObject);
        var ptr0 = other.__destroy_into_raw();
        const ret = wasm.wasmvectorobject_matchStyle(this.__wbg_ptr, ptr0);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {WasmVectorObject} other
     * @param {Array<any>} direction
     * @param {number} buff
     * @param {Array<any>} aligned_edge
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    nextToOther(other, direction, buff, aligned_edge, recursive) {
        _assertClass(other, WasmVectorObject);
        var ptr0 = other.__destroy_into_raw();
        const ret = wasm.wasmvectorobject_nextToOther(this.__wbg_ptr, ptr0, direction, buff, aligned_edge, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {Array<any>} direction
     * @param {number} buff
     * @param {Array<any>} aligned_edge
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    arrangeSubobjects(direction, buff, aligned_edge, recursive) {
        const ret = wasm.wasmvectorobject_arrangeSubobjects(this.__wbg_ptr, direction, buff, aligned_edge, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @param {Array<any>} point
     * @param {Array<any>} direction
     * @param {number} buff
     * @param {Array<any>} aligned_edge
     * @param {boolean} recursive
     * @returns {WasmVectorObject}
     */
    nextToPoint(point, direction, buff, aligned_edge, recursive) {
        const ret = wasm.wasmvectorobject_nextToPoint(this.__wbg_ptr, point, direction, buff, aligned_edge, recursive);
        return WasmVectorObject.__wrap(ret);
    }
    /**
     * @returns {WasmVectorObject}
     */
    clone() {
        const ret = wasm.wasmvectorobject_clone(this.__wbg_ptr);
        return WasmVectorObject.__wrap(ret);
    }
}

async function __wbg_load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbg_addColorStop_cf73ab1fa53542f0 = function() { return handleError(function (arg0, arg1, arg2, arg3) {
        arg0.addColorStop(arg1, getStringFromWasm0(arg2, arg3));
    }, arguments) };
    imports.wbg.__wbg_appendChild_d22bc7af6b96b3f1 = function() { return handleError(function (arg0, arg1) {
        const ret = arg0.appendChild(arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_beginPath_18ab569e70788cc1 = function(arg0) {
        arg0.beginPath();
    };
    imports.wbg.__wbg_bezierCurveTo_3b38e7092ccfc8a5 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
        arg0.bezierCurveTo(arg1, arg2, arg3, arg4, arg5, arg6);
    };
    imports.wbg.__wbg_call_3b770f0d6eb4720e = function() { return handleError(function (arg0, arg1, arg2, arg3) {
        const ret = arg0.call(arg1, arg2, arg3);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_call_500db948e69c7330 = function() { return handleError(function (arg0, arg1, arg2) {
        const ret = arg0.call(arg1, arg2);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_call_9bd6f269d4835e33 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {
        const ret = arg0.call(arg1, arg2, arg3, arg4);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_call_b0d8e36992d9900d = function() { return handleError(function (arg0, arg1) {
        const ret = arg0.call(arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_clearRect_2f56fc6c57073abe = function(arg0, arg1, arg2, arg3, arg4) {
        arg0.clearRect(arg1, arg2, arg3, arg4);
    };
    imports.wbg.__wbg_closePath_f2b82479f22f3aa3 = function(arg0) {
        arg0.closePath();
    };
    imports.wbg.__wbg_createElementNS_494cc14f5fdee138 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {
        const ret = arg0.createElementNS(arg1 === 0 ? undefined : getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
        return ret;
    }, arguments) };
    imports.wbg.__wbg_createElement_89923fcb809656b7 = function() { return handleError(function (arg0, arg1, arg2) {
        const ret = arg0.createElement(getStringFromWasm0(arg1, arg2));
        return ret;
    }, arguments) };
    imports.wbg.__wbg_createLinearGradient_9a998b7e6336dfe9 = function(arg0, arg1, arg2, arg3, arg4) {
        const ret = arg0.createLinearGradient(arg1, arg2, arg3, arg4);
        return ret;
    };
    imports.wbg.__wbg_createPattern_f61783ddfcab389d = function() { return handleError(function (arg0, arg1, arg2, arg3) {
        const ret = arg0.createPattern(arg1, getStringFromWasm0(arg2, arg3));
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    }, arguments) };
    imports.wbg.__wbg_createRadialGradient_bf2f6c287319a618 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
        const ret = arg0.createRadialGradient(arg1, arg2, arg3, arg4, arg5, arg6);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_delete_1869426209e60a28 = function(arg0, arg1) {
        const ret = arg0.delete(arg1);
        return ret;
    };
    imports.wbg.__wbg_document_f11bc4f7c03e1745 = function(arg0) {
        const ret = arg0.document;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_drawImage_e1b6c6bf1d06e584 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4, arg5) {
        arg0.drawImage(arg1, arg2, arg3, arg4, arg5);
    }, arguments) };
    imports.wbg.__wbg_error_a52e5799cd019c22 = function(arg0) {
        console.error(arg0);
    };
    imports.wbg.__wbg_eval_cd0c386c3899dd07 = function() { return handleError(function (arg0, arg1) {
        const ret = eval(getStringFromWasm0(arg0, arg1));
        return ret;
    }, arguments) };
    imports.wbg.__wbg_fillRect_d17933580f17fcb0 = function(arg0, arg1, arg2, arg3, arg4) {
        arg0.fillRect(arg1, arg2, arg3, arg4);
    };
    imports.wbg.__wbg_fill_60c74e6985048c77 = function(arg0, arg1) {
        arg0.fill(__wbindgen_enum_CanvasWindingRule[arg1]);
    };
    imports.wbg.__wbg_from_d68eaa96dba25449 = function(arg0) {
        const ret = Array.from(arg0);
        return ret;
    };
    imports.wbg.__wbg_getContext_5eaf5645cd6acb46 = function() { return handleError(function (arg0, arg1, arg2) {
        const ret = arg0.getContext(getStringFromWasm0(arg1, arg2));
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    }, arguments) };
    imports.wbg.__wbg_get_9aa3dff3f0266054 = function(arg0, arg1) {
        const ret = arg0[arg1 >>> 0];
        return ret;
    };
    imports.wbg.__wbg_get_bbccf8970793c087 = function() { return handleError(function (arg0, arg1) {
        const ret = Reflect.get(arg0, arg1);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_get_d014896fa1fe7b87 = function(arg0, arg1) {
        const ret = arg0.get(arg1);
        return ret;
    };
    imports.wbg.__wbg_has_3fa1c72267057967 = function(arg0, arg1) {
        const ret = arg0.has(arg1);
        return ret;
    };
    imports.wbg.__wbg_instanceof_CanvasRenderingContext2d_23b21317d73228be = function(arg0) {
        let result;
        try {
            result = arg0 instanceof CanvasRenderingContext2D;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_instanceof_HtmlCanvasElement_f764441ef5ddb63f = function(arg0) {
        let result;
        try {
            result = arg0 instanceof HTMLCanvasElement;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_instanceof_HtmlImageElement_bec0ae64fc910d67 = function(arg0) {
        let result;
        try {
            result = arg0 instanceof HTMLImageElement;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_instanceof_Map_98ecb30afec5acdb = function(arg0) {
        let result;
        try {
            result = arg0 instanceof Map;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_instanceof_Promise_0aa3a90cfe6672c9 = function(arg0) {
        let result;
        try {
            result = arg0 instanceof Promise;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_instanceof_Window_d2514c6a7ee7ba60 = function(arg0) {
        let result;
        try {
            result = arg0 instanceof Window;
        } catch (_) {
            result = false;
        }
        const ret = result;
        return ret;
    };
    imports.wbg.__wbg_isArray_1ba11a930108ec51 = function(arg0) {
        const ret = Array.isArray(arg0);
        return ret;
    };
    imports.wbg.__wbg_length_d65cf0786bfc5739 = function(arg0) {
        const ret = arg0.length;
        return ret;
    };
    imports.wbg.__wbg_log_db88956bd19b8074 = function(arg0, arg1) {
        console.log(getStringFromWasm0(arg0, arg1));
    };
    imports.wbg.__wbg_moveTo_3069b186b2004933 = function(arg0, arg1, arg2) {
        arg0.moveTo(arg1, arg2);
    };
    imports.wbg.__wbg_new_254fa9eac11932ae = function() {
        const ret = new Array();
        return ret;
    };
    imports.wbg.__wbg_new_3d446df9155128ef = function(arg0, arg1) {
        try {
            var state0 = {a: arg0, b: arg1};
            var cb0 = (arg0, arg1) => {
                const a = state0.a;
                state0.a = 0;
                try {
                    return __wbg_adapter_614(a, state0.b, arg0, arg1);
                } finally {
                    state0.a = a;
                }
            };
            const ret = new Promise(cb0);
            return ret;
        } finally {
            state0.a = state0.b = 0;
        }
    };
    imports.wbg.__wbg_new_bc96c6a1c0786643 = function() {
        const ret = new Map();
        return ret;
    };
    imports.wbg.__wbg_new_c60de43ba24f2df6 = function() { return handleError(function () {
        const ret = new Image();
        return ret;
    }, arguments) };
    imports.wbg.__wbg_newnoargs_fd9e4bf8be2bc16d = function(arg0, arg1) {
        const ret = new Function(getStringFromWasm0(arg0, arg1));
        return ret;
    };
    imports.wbg.__wbg_of_39b8e3338eb53ca4 = function(arg0, arg1, arg2, arg3) {
        const ret = Array.of(arg0, arg1, arg2, arg3);
        return ret;
    };
    imports.wbg.__wbg_of_437cdae2760f8b94 = function(arg0, arg1) {
        const ret = Array.of(arg0, arg1);
        return ret;
    };
    imports.wbg.__wbg_of_924412d32367b13d = function(arg0) {
        const ret = Array.of(arg0);
        return ret;
    };
    imports.wbg.__wbg_of_d3331a102e573656 = function(arg0, arg1, arg2) {
        const ret = Array.of(arg0, arg1, arg2);
        return ret;
    };
    imports.wbg.__wbg_push_6edad0df4b546b2c = function(arg0, arg1) {
        const ret = arg0.push(arg1);
        return ret;
    };
    imports.wbg.__wbg_queueMicrotask_2181040e064c0dc8 = function(arg0) {
        queueMicrotask(arg0);
    };
    imports.wbg.__wbg_queueMicrotask_ef9ac43769cbcc4f = function(arg0) {
        const ret = arg0.queueMicrotask;
        return ret;
    };
    imports.wbg.__wbg_resetTransform_9431291697de2616 = function() { return handleError(function (arg0) {
        arg0.resetTransform();
    }, arguments) };
    imports.wbg.__wbg_resolve_0bf7c44d641804f9 = function(arg0) {
        const ret = Promise.resolve(arg0);
        return ret;
    };
    imports.wbg.__wbg_scale_63a90ceae93e38bb = function() { return handleError(function (arg0, arg1, arg2) {
        arg0.scale(arg1, arg2);
    }, arguments) };
    imports.wbg.__wbg_setAttribute_148e0e65e20e5f27 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {
        arg0.setAttribute(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    }, arguments) };
    imports.wbg.__wbg_setTimeout_8d2afdcdb34b4e5a = function() { return handleError(function (arg0, arg1, arg2) {
        const ret = arg0.setTimeout(arg1, arg2);
        return ret;
    }, arguments) };
    imports.wbg.__wbg_set_76818dc3c59a63d5 = function(arg0, arg1, arg2) {
        const ret = arg0.set(arg1, arg2);
        return ret;
    };
    imports.wbg.__wbg_setfillStyle_2f279c840c680039 = function(arg0, arg1) {
        arg0.fillStyle = arg1;
    };
    imports.wbg.__wbg_setfillStyle_ae60d97e5d1891b5 = function(arg0, arg1) {
        arg0.fillStyle = arg1;
    };
    imports.wbg.__wbg_setfillStyle_f7b06b145d46019b = function(arg0, arg1, arg2) {
        arg0.fillStyle = getStringFromWasm0(arg1, arg2);
    };
    imports.wbg.__wbg_setglobalAlpha_77e0742e14c33e75 = function(arg0, arg1) {
        arg0.globalAlpha = arg1;
    };
    imports.wbg.__wbg_setheight_16d76e7fa9d506ea = function(arg0, arg1) {
        arg0.height = arg1 >>> 0;
    };
    imports.wbg.__wbg_setinnerHTML_2d75307ba8832258 = function(arg0, arg1, arg2) {
        arg0.innerHTML = getStringFromWasm0(arg1, arg2);
    };
    imports.wbg.__wbg_setlineCap_d1ecd1c2a52c7c06 = function(arg0, arg1, arg2) {
        arg0.lineCap = getStringFromWasm0(arg1, arg2);
    };
    imports.wbg.__wbg_setlineJoin_c571f71083837552 = function(arg0, arg1, arg2) {
        arg0.lineJoin = getStringFromWasm0(arg1, arg2);
    };
    imports.wbg.__wbg_setlineWidth_03305d3599ca8adb = function(arg0, arg1) {
        arg0.lineWidth = arg1;
    };
    imports.wbg.__wbg_setonload_482d0d1cba560c01 = function(arg0, arg1) {
        arg0.onload = arg1;
    };
    imports.wbg.__wbg_setsrc_99e2795c356bc837 = function(arg0, arg1, arg2) {
        arg0.src = getStringFromWasm0(arg1, arg2);
    };
    imports.wbg.__wbg_setstrokeStyle_7f8dbdddec47d488 = function(arg0, arg1, arg2) {
        arg0.strokeStyle = getStringFromWasm0(arg1, arg2);
    };
    imports.wbg.__wbg_setstrokeStyle_ac7aa916f53ffae8 = function(arg0, arg1) {
        arg0.strokeStyle = arg1;
    };
    imports.wbg.__wbg_setstrokeStyle_f1a52870ab69f052 = function(arg0, arg1) {
        arg0.strokeStyle = arg1;
    };
    imports.wbg.__wbg_setwidth_c588fe07a7982aca = function(arg0, arg1) {
        arg0.width = arg1 >>> 0;
    };
    imports.wbg.__wbg_static_accessor_GLOBAL_0be7472e492ad3e3 = function() {
        const ret = typeof global === 'undefined' ? null : global;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_GLOBAL_THIS_1a6eb482d12c9bfb = function() {
        const ret = typeof globalThis === 'undefined' ? null : globalThis;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_SELF_1dc398a895c82351 = function() {
        const ret = typeof self === 'undefined' ? null : self;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_static_accessor_WINDOW_ae1c80c7eea8d64a = function() {
        const ret = typeof window === 'undefined' ? null : window;
        return isLikeNone(ret) ? 0 : addToExternrefTable0(ret);
    };
    imports.wbg.__wbg_stroke_0feb24d5e9f9c915 = function(arg0) {
        arg0.stroke();
    };
    imports.wbg.__wbg_then_0438fad860fe38e1 = function(arg0, arg1) {
        const ret = arg0.then(arg1);
        return ret;
    };
    imports.wbg.__wbg_then_0ffafeddf0e182a4 = function(arg0, arg1, arg2) {
        const ret = arg0.then(arg1, arg2);
        return ret;
    };
    imports.wbg.__wbg_translate_fe29257d3c848e84 = function() { return handleError(function (arg0, arg1, arg2) {
        arg0.translate(arg1, arg2);
    }, arguments) };
    imports.wbg.__wbg_wasmcolor_unwrap = function(arg0) {
        const ret = WasmColor.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_wasmgradientstop_new = function(arg0) {
        const ret = WasmGradientStop.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_wasmgradientstop_unwrap = function(arg0) {
        const ret = WasmGradientStop.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_wasmthreedobject_new = function(arg0) {
        const ret = WasmThreeDObject.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_wasmthreedobject_unwrap = function(arg0) {
        const ret = WasmThreeDObject.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_wasmvectorobject_new = function(arg0) {
        const ret = WasmVectorObject.__wrap(arg0);
        return ret;
    };
    imports.wbg.__wbg_wasmvectorobject_unwrap = function(arg0) {
        const ret = WasmVectorObject.__unwrap(arg0);
        return ret;
    };
    imports.wbg.__wbindgen_boolean_get = function(arg0) {
        const v = arg0;
        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;
        return ret;
    };
    imports.wbg.__wbindgen_cb_drop = function(arg0) {
        const obj = arg0.original;
        if (obj.cnt-- == 1) {
            obj.a = 0;
            return true;
        }
        const ret = false;
        return ret;
    };
    imports.wbg.__wbindgen_closure_wrapper1478 = function(arg0, arg1, arg2) {
        const ret = makeClosure(arg0, arg1, 268, __wbg_adapter_34);
        return ret;
    };
    imports.wbg.__wbindgen_closure_wrapper1480 = function(arg0, arg1, arg2) {
        const ret = makeClosure(arg0, arg1, 268, __wbg_adapter_37);
        return ret;
    };
    imports.wbg.__wbindgen_closure_wrapper1482 = function(arg0, arg1, arg2) {
        const ret = makeClosure(arg0, arg1, 268, __wbg_adapter_40);
        return ret;
    };
    imports.wbg.__wbindgen_closure_wrapper1484 = function(arg0, arg1, arg2) {
        const ret = makeClosure(arg0, arg1, 268, __wbg_adapter_43);
        return ret;
    };
    imports.wbg.__wbindgen_closure_wrapper1486 = function(arg0, arg1, arg2) {
        const ret = makeClosure(arg0, arg1, 268, __wbg_adapter_46);
        return ret;
    };
    imports.wbg.__wbindgen_closure_wrapper2055 = function(arg0, arg1, arg2) {
        const ret = makeMutClosure(arg0, arg1, 311, __wbg_adapter_49);
        return ret;
    };
    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
        const ret = debugString(arg1);
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
        const ret = new Error(getStringFromWasm0(arg0, arg1));
        return ret;
    };
    imports.wbg.__wbindgen_init_externref_table = function() {
        const table = wasm.__wbindgen_export_2;
        const offset = table.grow(4);
        table.set(0, undefined);
        table.set(offset + 0, undefined);
        table.set(offset + 1, null);
        table.set(offset + 2, true);
        table.set(offset + 3, false);
        ;
    };
    imports.wbg.__wbindgen_is_falsy = function(arg0) {
        const ret = !arg0;
        return ret;
    };
    imports.wbg.__wbindgen_is_function = function(arg0) {
        const ret = typeof(arg0) === 'function';
        return ret;
    };
    imports.wbg.__wbindgen_is_undefined = function(arg0) {
        const ret = arg0 === undefined;
        return ret;
    };
    imports.wbg.__wbindgen_jsval_eq = function(arg0, arg1) {
        const ret = arg0 === arg1;
        return ret;
    };
    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {
        const obj = arg1;
        const ret = typeof(obj) === 'number' ? obj : undefined;
        getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);
    };
    imports.wbg.__wbindgen_number_new = function(arg0) {
        const ret = arg0;
        return ret;
    };
    imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
        const obj = arg1;
        const ret = typeof(obj) === 'string' ? obj : undefined;
        var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
        const ret = getStringFromWasm0(arg0, arg1);
        return ret;
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };

    return imports;
}

function __wbg_init_memory(imports, memory) {

}

function __wbg_finalize_init(instance, module) {
    wasm = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedDataViewMemory0 = null;
    cachedFloat64ArrayMemory0 = null;
    cachedUint32ArrayMemory0 = null;
    cachedUint8ArrayMemory0 = null;


    wasm.__wbindgen_start();
    return wasm;
}

function initSync(module) {
    if (wasm !== undefined) return wasm;


    if (typeof module !== 'undefined') {
        if (Object.getPrototypeOf(module) === Object.prototype) {
            ({module} = module)
        } else {
            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')
        }
    }

    const imports = __wbg_get_imports();

    __wbg_init_memory(imports);

    if (!(module instanceof WebAssembly.Module)) {
        module = new WebAssembly.Module(module);
    }

    const instance = new WebAssembly.Instance(module, imports);

    return __wbg_finalize_init(instance, module);
}

async function __wbg_init(module_or_path) {
    if (wasm !== undefined) return wasm;


    if (typeof module_or_path !== 'undefined') {
        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
            ({module_or_path} = module_or_path)
        } else {
            console.warn('using deprecated parameters for the initialization function; pass a single object instead')
        }
    }

    if (typeof module_or_path === 'undefined') {
        module_or_path = new URL('index_bg.wasm', import.meta.url);
    }
    const imports = __wbg_get_imports();

    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {
        module_or_path = fetch(module_or_path);
    }

    __wbg_init_memory(imports);

    const { instance, module } = await __wbg_load(await module_or_path, imports);

    return __wbg_finalize_init(instance, module);
}

export { initSync };
export default __wbg_init;
