# ========================================
# RESPONSABILITIES
# ========================================
"""
Provides the entry point for the nuxt build process
"""

# ========================================
# MIT License

# Copyright (c) 2024 Shared

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# ========================================


# ========================================
# IMPORTS
# ========================================

# PYTHON LIBRARIES
# ========================================
import logging
import os
import time
from pydantic import BaseModel
from fastapi import FastAPI
from pathlib import Path

# MODULE LIBRARIES
# ========================================
from fast2app.export.type_script import generate_interfaces
from fast2app.export.nuxt.nuxt_server_generation import (
    generate_nuxt_server,
    generate_nuxt_composables,
    get_runtime_config_variable_name,
)

from fast2app.utils import to_url, load_config
from fast2app.parsing import (
    parse_models,
    generate_input_models,
    check_fast_api_validity,
)


# ========================================
# FUNCTIONS
# ========================================


def build_nuxt_server(
    *args: FastAPI,
    export_folder_path: Path,
    export_composables: bool,
    logging_level: int = logging.DEBUG,
) -> tuple[Path, Path, Path, list[tuple[str, str]]]:
    """
    Build :

        - all the Typscript interface in <export_folder>/types/fastapi.ts
        - a nuxt server
        - the nuxt composables to directly call on the nuxt api

    Note:

        This function wiil remove any existing file that have been generated by this script before and
        leave the other files untouched

    Raises:
        ValueError:
            If the provided fast api apps are not valid :
                - if two apps have the same title
                - if the same route can be found in multiple apps
                - if the same route function can be found in multiple apps

    Args:
        args (tuple[FastAPI]):
            The fast api apps to process

        export_folder (Path):
            The nuxt app folder

        export_composables (bool):
            Whether composablesfor each routes are created

    Returns:
        tuple[Path, Path, Path, list[tuple[str, str]]]:
            the path to :
            - the generated nuxt server
            - the path to the generated interfaces
            - the composables

            The list of (<app title>,<runtime environement variables>) to add tu nuxt.config.ts

    """

    # SETUP
    # -------------------------------------

    logging.getLogger().setLevel(logging_level)

    # PATH
    logging.info(f"Building nuxt server from : {args}")

    logging.debug({"export_folder_path": export_folder_path})

    interface_path: Path = Path("types/fastapi.ts")

    server_path: Path = Path("server/api")

    composables_path: Path = Path("composables")

    # CHECK VALIDITY
    # -------------------------------------
    validity_check = check_fast_api_validity(*args)

    if not validity_check.is_valid:
        raise ValueError(validity_check.message)

    # GENERATE GENERAL INTERFACES
    # -------------------------------------
    interface_folder_path: Path = export_folder_path / interface_path
    _generate_interfaces(
        *args,
        interface_folder_path=interface_folder_path,
        export_composables=export_composables,
    )

    # GENERATE SERVER
    # -------------------------------------
    nuxt_server_folder_path: Path = export_folder_path / server_path
    logging.info({"nuxt_server_folder_path": nuxt_server_folder_path})
    _remove_nuxt_server_watermarked_files(
        nuxt_server_folder_path=nuxt_server_folder_path
    )
    _generate_nuxt_server(
        *args,
        nuxt_server_folder_path=nuxt_server_folder_path,
    )

    # GENERATE COMPOSABLES
    # -------------------------------------
    composables_folder_path: Path = export_folder_path / composables_path
    _remove_nuxt_composables_watermarked_files(
        composables_folder_path=composables_folder_path
    )
    if export_composables:
        _generate_nuxt_composables(
            *args,
            composables_folder_path=composables_folder_path,
        )

    # runtime confiv variable
    runtime_config_variables: list[tuple[str, str]] = [
        (app.title, get_runtime_config_variable_name(app_title=app.title))
        for app in args
    ]

    # RETURN
    return (
        nuxt_server_folder_path,
        interface_folder_path,
        composables_folder_path,
        runtime_config_variables,
    )


# ========================================
# PRIVATE FUNCTIONS
# ========================================


def _generate_interfaces(
    *args: FastAPI, interface_folder_path: Path, export_composables: bool
) -> None:
    """
    Generates the interfaces in the provides folder

    Args:
        args (tuple[FastAPI]):
            The fast api apps to process

        interface_folder_path (Path):
            The export folder for the types

        export_composables(bool):
            Whether composablesfor each routes are created
    """

    info_message: str = f"Generating interfaces in `{interface_folder_path}`"
    print(info_message)
    logging.info(info_message)

    # MODEL
    model_classes: set[type[BaseModel]] = set()

    # MODELS
    for app in args:
        model_classes = model_classes.union(parse_models(app=app))

    # INPUT MODELS
    if export_composables:
        for app in args:
            model_classes = model_classes.union(generate_input_models(app=app))

    # GENERATION

    generate_interfaces(model_classes=model_classes, export_path=interface_folder_path)


def _remove_nuxt_server_watermarked_files(nuxt_server_folder_path: Path) -> None:
    """
    Removes all the files in the folder that match the global watermark

    Args
        nuxt_server_folder_path (Path):
            The nuxt server folder path
    """
    info_message: str = f"Removing watermarked files in `{nuxt_server_folder_path}`"
    print(info_message)
    logging.info(info_message)
    _removed_watermarked_files(folder_path=nuxt_server_folder_path)


def _generate_nuxt_server(*args: FastAPI, nuxt_server_folder_path: Path) -> None:
    """
    Geerates nuxt server

    Args:
        args (tuple[FastAPI]):
            The fast api apps to process

        nuxt_server_folder_path (Path):
            The nuxt server folder path
    """
    info_message: str = f"Generating nuxt server in `{nuxt_server_folder_path}`"
    print(info_message)
    logging.info(info_message)

    for app in args:
        server_folder_path: Path = nuxt_server_folder_path / to_url(app.title)
        generate_nuxt_server(
            app=app,
            server_folder_path=server_folder_path,
        )


def _remove_nuxt_composables_watermarked_files(composables_folder_path: Path) -> None:
    """
    Removes all the files in the folder that match the global watermark

    Args
        nuxt_server_folder_path (Path):
            The nuxt server folder path
    """
    info_message: str = f"Removing watermarked files in `{composables_folder_path}`"
    print(info_message)
    logging.info(info_message)

    _removed_watermarked_files(folder_path=composables_folder_path)


def _generate_nuxt_composables(*args: FastAPI, composables_folder_path: Path) -> None:
    """
    Geerates nuxt server

    Args:
        args (tuple[FastAPI]):
            The fast api apps to process

        composables_folder_path (Path):
            The composables folder path
    """
    info_message: str = f"Generating composables files in `{composables_folder_path}`"
    print(info_message)
    logging.info(info_message)
    for app in args:
        generate_nuxt_composables(
            app=app,
            composables_folder_path=composables_folder_path,
        )


def _removed_watermarked_files(folder_path: Path) -> None:
    """
    Removes all the files in the folder and subfolders that match the global watermark.
    Removes the folder if it ends up being empty.
    Does not do anything if the provided path is not a directory.

    Args:
        folder_path (Path): The folder path
    """
    if not folder_path.is_dir():
        message = f"The provided path '{folder_path}' is not a valid directory."
        print(message)
        logging.info(message)
        return

    RANDOM_WATER_MARK = _get_watermark()

    # Iterate through the directory content
    for file_path in folder_path.iterdir():
        if file_path.is_file():
            try:
                with open(file_path, "r", encoding="utf-8") as file:
                    content = file.read()
                    if RANDOM_WATER_MARK in content:
                        file.close()  # Ensure file is closed
                        time.sleep(0.1)  # Small delay
                        os.remove(file_path)
                        logging.info(f"Removed file: {file_path}")
            except Exception as e:
                logging.error(f"Error processing file {file_path}: {str(e)}")

        # If it's a directory, call the function recursively
        elif file_path.is_dir():
            logging.info(f"Entering directory: {file_path}")
            _removed_watermarked_files(file_path)

    # Remove the directory if it is empty
    try:
        if not any(folder_path.iterdir()):  # Check if directory is empty
            os.rmdir(folder_path)
            logging.info(f"Removed empty directory: {folder_path}")
    except Exception as e:
        logging.error(f"Error removing directory {folder_path}: {str(e)}")

    logging.info(f"Finished removing watermarked files in {folder_path}")


# ========================================
# WATER MARK
# ========================================


def _get_watermark() -> str:
    """
    Get the watermark
    Returns:
        str: The watermark v alue
    """
    # Get the Path of the current script
    script_path = Path(__file__).resolve()

    # Get the directory containing the script
    script_dir = script_path.parent

    config: dict = load_config(folder_path=script_dir)

    return config["RANDOM_WATER_MARK"]
