from collections.abc import Callable, Sequence
import enum
from typing import Annotated, overload

from numpy.typing import ArrayLike


class AbstractScaler:
    pass

class ChebyshevApproximation1D:
    def __init__(self, *, expansions: Sequence[ChebyshevExpansion]) -> None: ...

    def get_x_for_y(self, *, y: float, bits: int = 64, max_iter: int = 100, boundsftol: float = 1e-13) -> list[tuple[float, int]]: ...

    def eval(self, arg: float, /) -> float: ...

    @property
    def xmin(self) -> float: ...

    @property
    def xmax(self) -> float: ...

    def eval_many(self, arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg1: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], /) -> None: ...

    def count_x_for_y_many(self, arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg1: int, arg2: int, arg3: float, arg4: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], /) -> None: ...

    @property
    def expansions(self) -> list[ChebyshevExpansion]: ...

    @property
    def x_at_extrema(self) -> list[float]: ...

    @property
    def monotonic_intervals(self) -> list[IntervalMatch]: ...

    def get_intervals_containing_y(self, arg: float, /) -> list[IntervalMatch]: ...

class ChebyshevExpansion:
    def __init__(self, *, xmin: float, xmax: float, coeff: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]) -> None: ...

    @property
    def xmin(self) -> float: ...

    @property
    def xmax(self) -> float: ...

    @property
    def coeff(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    def eval(self, arg: float, /) -> float: ...

    def eval_many(self, arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg1: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], /) -> None: ...

    def eval_Eigen(self, arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg1: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], /) -> None: ...

    def solve_for_x(self, arg0: float, arg1: float, arg2: float, arg3: int, arg4: int, arg5: float, /) -> float: ...

    def solve_for_x_count(self, arg0: float, arg1: float, arg2: float, arg3: int, arg4: int, arg5: float, /) -> tuple[float, int]: ...

    def solve_for_x_many(self, arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg1: float, arg2: float, arg3: int, arg4: int, arg5: float, arg6: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg7: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], /) -> None: ...

class CoordinateSequence:
    def __init__(self) -> None: ...

    def add(self, arg0: float, arg1: float, /) -> None: ...

    def getX(self, arg: int, /) -> float: ...

    def getY(self, arg: int, /) -> float: ...

    def closeRing(self, arg: bool, /) -> None: ...

    def getSize(self) -> int: ...

class Envelope:
    @property
    def x_min(self) -> float: ...

    @property
    def y_min(self) -> float: ...

    @property
    def x_max(self) -> float: ...

    @property
    def y_max(self) -> float: ...

class FlashPhase:
    @property
    def rho_molm3(self) -> float: ...

    @property
    def qmolar(self) -> float: ...

    @property
    def mole_fractions(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

class FlashSolution:
    @property
    def T_K(self) -> float: ...

    @property
    def Nphases(self) -> int: ...

    @property
    def phases(self) -> list[FlashPhase]: ...

class Geometry:
    def getNumGeometries(self) -> int: ...

    def getGeometryN(self, arg: int, /) -> Geometry: ...

    def intersection(self, arg: Geometry, /) -> Geometry: ...

    def difference(self, arg: Geometry, /) -> Geometry: ...

    def DelaunayTriangulate(self) -> Geometry: ...

    def fastTriangulate(self) -> Geometry: ...

    def getNumPoints(self) -> int: ...

    def getXY(self) -> tuple[Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]]:
        """
        Convenience function to return the X, Y coordinates as numpy arrays in Python
        """

    def containsPoint(self, arg: Point, /) -> bool: ...

    def getCoordinates(self) -> CoordinateSequence: ...

    @property
    def isValid(self) -> bool: ...

    @property
    def isSimple(self) -> bool: ...

    def get_PreparedGeometry(self) -> PreparedGeometry: ...

    def getCentroid(self) -> Point: ...

    def run_DouglasPeuckerSimplifier(self, tolerance: float) -> Geometry: ...

    def run_TopologyPreservingSimplifier(self, tolerance: float) -> Geometry: ...

    def make_valid(self) -> Geometry: ...

class GeometryFactory:
    def createPolygon(self, arg: Geometry, /) -> Geometry: ...

class GeometryFactoryHolder:
    def __init__(self) -> None: ...

    def createPolygon(self, arg: CoordinateSequence, /) -> Geometry: ...

    def createPoint(self, arg0: float, arg1: float, /) -> Point: ...

    def makeclosedpolygon(self, x: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], y: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')]) -> Geometry:
        """A convenience function to make a closed polygon given numpy arrays"""

class HelmholtzInterface:
    pass

class IntervalMatch:
    @property
    def xmin(self) -> float: ...

    @property
    def xmax(self) -> float: ...

    @property
    def ymin(self) -> float: ...

    @property
    def ymax(self) -> float: ...

    @property
    def expansioninfo(self) -> list[MonotonicExpansionMatch]: ...

class L2Tree:
    @overload
    def get_nearest_indexd2(self, x: float, y: float) -> tuple[int, float]: ...

    @overload
    def get_nearest_indexd2(self, pt: Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')]) -> tuple[int, float]: ...

    def get_nearest_indexd2_many(self, x: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], y: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], idx: Annotated[ArrayLike, dict(dtype='int32', shape=(None), order='C', device='cpu')], d2: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')]) -> None: ...

    def get_used_bytes(self) -> int: ...

class L2TreeHolder:
    def __init__(self, x: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], y: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], tree_depth: int, xscaler: AbstractScaler | None = None, yscaler: AbstractScaler | None = None) -> None: ...

    @property
    def tree(self) -> L2Tree: ...

    @tree.setter
    def tree(self, arg: L2Tree, /) -> None: ...

class LeafContents:
    @property
    def status(self) -> PQTStatus: ...

class MainFlasher:
    def __init__(self, *, regions: RegionedFlasher, superancillary: SuperAncillary, helm: HelmholtzInterface) -> None: ...

    def flash(self, proppair: PropertyPairs, val1: float, val2: float) -> FlashSolution | None: ...

    def flash_many(self, proppair: PropertyPairs, val1: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], val2: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], T: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], rho: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], q: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')]) -> None: ...

    @property
    def regioned_flasher(self) -> RegionedFlasher: ...

class MaxAbsErrorCondition(StoppingCondition):
    def __init__(self, threshold: float) -> None: ...

class MinMaxLogScaler(AbstractScaler):
    def __init__(self, x_min: float, x_max: float) -> None: ...

class MinMaxScaler(AbstractScaler):
    def __init__(self, x_min: float, x_max: float) -> None: ...

class MonotonicExpansionMatch:
    @property
    def xmin(self) -> float: ...

    @property
    def xmax(self) -> float: ...

    @property
    def ymin(self) -> float: ...

    @property
    def ymax(self) -> float: ...

    @property
    def idx(self) -> int: ...

class NRIterator:
    @property
    def verbose(self) -> bool: ...

    @verbose.setter
    def verbose(self, arg: bool, /) -> None: ...

    def get_T(self) -> float: ...

    def get_rho(self) -> float: ...

    def get_vals(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')]: ...

    def reset(self, arg0: float, arg1: float, /) -> None: ...

    def calc_step(self, arg0: float, arg1: float, /) -> tuple[Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')], "teqp::cppinterface::IterationMatrices"]: ...

    def calc_just_step(self, arg0: float, arg1: float, /) -> Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')]: ...

    def get_nonconstant_indices(self) -> list[int]: ...

    def calc_r(self, arg0: float, arg1: float, /) -> Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')]: ...

    def calc_J(self, arg0: float, arg1: float, /) -> Annotated[ArrayLike, dict(dtype='float64', shape=(2, 2), order='F')]: ...

    def calc_vals(self, arg0: float, arg1: float, /) -> Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')]: ...

    def calc_maxabsr(self, arg0: float, arg1: float, /) -> float: ...

    def get_maxabsr(self) -> float: ...

    def take_steps(self, N: int, apply_stopping: bool) -> StoppingConditionReason: ...

    def path_integration(self, arg0: float, arg1: float, arg2: int, /) -> tuple[float, float, float, float]: ...

    def get_step_count(self) -> int: ...

class NanXDXErrorCondition(StoppingCondition):
    def __init__(self) -> None: ...

class PQTStatus(enum.Enum):
    inside = 0

    outside = 1

    intersection = 2

class Point(Geometry):
    def getX(self) -> float: ...

    def getY(self) -> float: ...

class PolyQuadNode:
    def xmin(self) -> float: ...

    def xmax(self) -> float: ...

    def ymin(self) -> float: ...

    def ymax(self) -> float: ...

    def getNode(self, arg0: float, arg1: float, arg2: bool, /) -> PolyQuadNode: ...

    def get_contents(self) -> LeafContents: ...

    @property
    def terminal(self) -> bool: ...

    @property
    def NW(self) -> PolyQuadNode: ...

    @property
    def NE(self) -> PolyQuadNode: ...

    @property
    def SW(self) -> PolyQuadNode: ...

    @property
    def SE(self) -> PolyQuadNode: ...

class PolyQuadTree:
    def __init__(self, arg0: Sequence[float], arg1: Sequence[float], /) -> None: ...

    def do_splits(self, arg: int, /) -> None: ...

    def area_stats(self) -> None: ...

    def get_polygon_xy(self, arg: PolyQuadNode, /) -> tuple[list[float], list[float]] | None: ...

    def is_complete(self, arg: PolyQuadNode, /) -> bool: ...

    def is_intersection(self, arg: PolyQuadNode, /) -> bool: ...

    def get_status(self, arg: PolyQuadNode, /) -> PQTStatus: ...

    def get_leaves(self) -> list[PolyQuadNode]: ...

    @property
    def tree(self) -> PolyQuadNode: ...

class PreparedGeometry:
    def contains(self, arg: Geometry, /) -> bool: ...

    def nearestPoints(self, arg: Geometry, /) -> CoordinateSequence: ...

class PropertyPairs(enum.Enum):
    HS = 9

    ST = 0

    HT = 10

    TU = 11

    DP = 2

    PS = 7

    DH = 3

    DS = 4

    HP = 6

    PU = 8

    PT = 13

    SU = 12

    HU = 14

    DT = 1

    DU = 5

class PropertySet:
    @property
    def T(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @property
    def p(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @property
    def h(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @property
    def s(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @property
    def u(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    @property
    def rho(self) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    def get_array(self, arg: str, /) -> Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]: ...

    def get_arrays(self, arg: PropertyPairs, /) -> tuple[Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]]: ...

class QuadRegion2D:
    def __init__(self, *, x: Sequence[float], y: Sequence[float]) -> None: ...

    def do_splits(self, arg: int, /) -> None: ...

    def get_envelope(self) -> Envelope: ...

    def get_quadtree_ro(self) -> PolyQuadTree: ...

    def get_quadtree_rw(self) -> PolyQuadTree: ...

    def do_Delaunay_triangulation(self) -> Geometry: ...

    def do_fast_triangulation(self) -> Geometry: ...

    @property
    def bounding_polygon(self) -> Geometry: ...

    def sample_random(self, arg0: int, arg1: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg2: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], /) -> None: ...

    def sample_gridded(self, arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg1: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg2: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg3: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], /) -> int: ...

    def get_coords_xy(self) -> tuple[list[float], list[float]]: ...

    def get_nonsimple_xy(self) -> tuple[list[float], list[float]]: ...

    def sample_gridded_w_tree(self, arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg1: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg2: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg3: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], /) -> int: ...

class RegionedFlashReturn:
    @property
    def T(self) -> float:
        """Temperature, K"""

    @property
    def rho(self) -> float:
        """Molar density, mol/m3"""

    @property
    def reason(self) -> StoppingConditionReason:
        """Enumerated value for stopping reason"""

    @property
    def step_count(self) -> int:
        """How many Newton steps were takenm"""

    @property
    def maxabsr(self) -> float:
        """Maximum absolute residual"""

    @property
    def msg(self) -> str:
        """Message associated with stoppping reason"""

    @property
    def newton_duration_us(self) -> float:
        """How long the Newton part took, in microseconds"""

    @property
    def total_duration_us(self) -> float:
        """How long the total calculation took, in microseconds"""

    @property
    def candidate_duration_us(self) -> float:
        """How long the candidate determination part took, in microseconds"""

class RegionedFlasher:
    def __init__(self, *, ideal_gas: str, resid: str, mole_fractions: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')]) -> None: ...

    def add_region(self, *, T: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], rho: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], NT: int, Nrho: int) -> None:
        """Add a region to the set of regions"""

    def remove_all_regions(self) -> None:
        """Remove all the regions to restore object to its initial state"""

    def get_regions_ro(self) -> list[ThermodynamicRegion]:
        """Get a read-only view of the regions"""

    def get_regions_rw(self) -> list[ThermodynamicRegion]:
        """Get read-write access to the regions"""

    def get_quadtree_intersections(self, arg0: PropertyPairs, arg1: float, arg2: float, /) -> list[QuadRegion2D]: ...

    def get_NRIterator(self, arg0: Sequence[str], arg1: Annotated[ArrayLike, dict(dtype='float64', shape=(2), order='C')], arg2: float, arg3: float, arg4: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C')], arg5: tuple[bool, bool], arg6: Sequence[StoppingCondition], /) -> NRIterator:
        """Construct a Newton iterator object"""

    def get_starting_Trho(self, arg0: PropertyPairs, arg1: float, arg2: float, /) -> list[tuple[ThermodynamicRegion, TrhoLookup]]:
        """Get the starting temperature, density pair from the K-D tree"""

    def flash(self, proppair: PropertyPairs, val1: float, val2: float) -> RegionedFlashReturn:
        """Do a flash calculation"""

    def flash_many(self, proppair: PropertyPairs, val1: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], val2: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], T: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], rho: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], steps: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], maxabs: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], newtontime: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], candtime: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')]) -> None:
        """Do many flash calculations, for testing in Python"""

class StoppingCondition:
    pass

class StoppingConditionReason(enum.Enum):
    fatal = 3

    success = 2

    keep_going = 1

class SuperAncillary:
    def __init__(self, arg: str, /) -> None: ...

    def eval_sat(self, *, T: float, k: str, q: int) -> float: ...

    def eval_sat_many(self, *, T: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], k: str, q: int, y: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')]) -> None: ...

    def get_yval(self, *, T: float, q: float, k: str) -> float: ...

    def get_yval_many(self, *, T: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], k: str, q: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], y: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')]) -> None: ...

    def get_approx1d(self, *, k: str, q: int) -> ChebyshevApproximation1D: ...

    @property
    def invlnp(self) -> ChebyshevApproximation1D: ...

    def solve_for_T(self, *, propval: float, k: str, q: bool, bits: int = 64, max_iter: int = 100, boundsftol: float = 1e-13) -> list[tuple[float, int]]: ...

    def get_T_from_p(self, *, p: float) -> float: ...

    def get_vaporquality(self, *, T: float, propval: float, k: str) -> float: ...

    def add_variable(self, *, k: str, caller: Callable[[float, float], float]) -> None: ...

    def solve_for_Tq_DX(self, arg0: float, arg1: float, arg2: str, arg3: int, arg4: int, arg5: float, /) -> SuperAncillaryTwoPhaseSolution | None: ...

    def solve_for_Tq_DX_many(self, arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg1: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg2: str, arg3: int, arg4: int, arg5: float, arg6: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg7: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg8: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], /) -> None: ...

    def flash(self, arg0: PropertyPairs, arg1: float, arg2: float, /) -> SuperAncillaryTwoPhaseSolution | None: ...

    def flash_many(self, arg0: PropertyPairs, arg1: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg2: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg3: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg4: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg5: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], /) -> None: ...

class SuperAncillaryTwoPhaseSolution:
    @property
    def T(self) -> float: ...

    @property
    def q(self) -> float: ...

    @property
    def counter(self) -> int: ...

class ThermodynamicRegion:
    @property
    def transformed_regions(self) -> dict[PropertyPairs, QuadRegion2D]: ...

    @property
    def propset_bounding(self) -> PropertySet: ...

    @property
    def propset_Trhogrid(self) -> PropertySet: ...

    def add_pair(self, *, proppair: PropertyPairs, Nsplit: int, and_kdtree: bool = True) -> None: ...

    def has_pair(self, arg: PropertyPairs, /) -> bool: ...

    def get_transformed_region(self, arg: PropertyPairs, /) -> QuadRegion2D: ...

    def get_kdtree(self, arg: PropertyPairs, /) -> L2Tree: ...

    def get_starting_Trho_many(self, proppair: PropertyPairs, val1: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], val2: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], T: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], rho: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], d2: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')]) -> None: ...

class TrhoLookup:
    @property
    def T(self) -> float: ...

    @property
    def rho(self) -> float: ...

    @property
    def d2(self) -> float: ...

def add(arg0: int, arg1: int, /) -> int: ...

def get_pair_from_chars(arg0: str, arg1: str, /) -> PropertyPairs: ...

def get_pair_log_scaling(arg: PropertyPairs, /) -> tuple[bool, bool]: ...

def get_property_chars(arg: PropertyPairs, /) -> tuple[str, str]: ...

def indexer(arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg1: int, /) -> float: ...

def indexer33(arg0: Annotated[ArrayLike, dict(dtype='float64', shape=(3, 3), order='C', device='cpu')], arg1: int, arg2: int, arg3: str, /) -> float: ...

def sample_random(arg0: Geometry, arg1: int, arg2: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], arg3: Annotated[ArrayLike, dict(dtype='float64', shape=(None), order='C', device='cpu')], /) -> None: ...

class teqpHelmholtzInterface(HelmholtzInterface):
    def __init__(self, *, ideal_gas: str, residual: str) -> None: ...

def toms748_solve(arg0: Callable[[float], float], arg1: float, arg2: float, arg3: int, arg4: int, /) -> tuple[tuple[float, float], int]: ...
