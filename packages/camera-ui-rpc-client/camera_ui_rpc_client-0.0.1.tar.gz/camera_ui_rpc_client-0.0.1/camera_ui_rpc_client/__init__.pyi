import abc
from .base.connection import RPCConnectionManager
from .base.messaging import BaseMessaging
from .base.rpc import RPCConnection
from .typings import ClientConnectionOptions as ClientConnectionOptions, ClientMetrics as ClientMetrics, ClientStatus as ClientStatus, ConnectionMessage as ConnectionMessage, ConnectionState as ConnectionState, Message as Message, RPCOptions as RPCOptions, ResponseMessage as ResponseMessage
from .utils.subscriptions import SubscriptionWrapper
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from collections.abc import Awaitable
from typing import Any, Callable, TypeVar

logger: Incomplete
T = TypeVar('T')
R = TypeVar('R')

class ClientInstance(BaseMessaging, ABC, metaclass=abc.ABCMeta):
    options: Incomplete
    _client: Incomplete
    _status: Incomplete
    _error: Incomplete
    _metrics_task: Incomplete
    _task_set: Incomplete
    def __init__(self, options: ClientConnectionOptions) -> None: ...
    async def start(self) -> None: ...
    async def stop(self) -> None: ...
    async def send_to_plugin(self, plugin_id: str, data: Any) -> None: ...
    async def send_to_service(self, service_id: str, data: Any) -> None: ...
    async def send_to_server(self, data: Any) -> None: ...
    async def request_from_plugin(self, plugin_id: str, data: Any, timeout: int | None = None) -> ResponseMessage[Any]: ...
    async def request_from_service(self, service_id: str, data: Any, timeout: int | None = None) -> ResponseMessage[Any]: ...
    async def request_from_server(self, data: Any, timeout: int | None = None) -> ResponseMessage[Any]: ...
    async def on_plugin_message(self, plugin_id: str | None, handler: Callable[[T], R | Awaitable[R | None]]) -> None: ...
    async def on_service_message(self, service_id: str | None, handler: Callable[[T], R | Awaitable[R | None]]) -> None: ...
    async def on_server_message(self, handler: Callable[[T], R | Awaitable[R | None]]) -> SubscriptionWrapper: ...
    async def register_rpc_handler(self, namespace: str, handler: dict[str, Callable[..., Any]] | object) -> None: ...
    async def unregister_rpc_handler(self, namespace: str) -> None: ...
    async def create_rpc_proxy(self, type: type[T], namespace: str, rpc_options: RPCOptions | None = None) -> T: ...
    async def create_rpc_connection(self, namespace: str, rpc_options: RPCOptions | None = None) -> RPCConnection: ...
    async def disconnect_rpc_connection(self, namespace: str) -> None: ...
    def get_status(self) -> ClientStatus: ...
    def is_connected(self) -> bool: ...
    def get_connection_manager(self) -> RPCConnectionManager: ...
    def get_connection_anager(self) -> RPCConnectionManager: ...
    def is_running(self) -> bool: ...
    def is_server_running(self) -> bool: ...
    @abstractmethod
    async def on_start(self) -> None: ...
    @abstractmethod
    async def on_stop(self) -> None: ...
    async def on_before_start(self) -> None: ...
    def on_after_start(self) -> None: ...
    async def on_before_stop(self) -> None: ...
    def on_after_stop(self) -> None: ...
    async def _setup_subscriptions(self) -> None: ...
    def _start_metrics_collection(self) -> None: ...
    def _stop_metrics_collection(self) -> None: ...
    async def _metrics_collection_loop(self) -> None:
        """Continuous loop for collecting and publishing metrics."""
    def _aggregate_metrics(self) -> ClientMetrics:
        """Aggregate metrics from all connection managers."""
    async def _handle_ping(self, _: Message[ConnectionMessage]) -> None: ...
    async def _update_status(self, state: ConnectionState, error: Exception | None = None) -> None: ...
