import enum
from collections.abc import Container, Sequence, Set
from typing import ClassVar, Optional, SupportsFloat, cast

NumberType = float
SupportsNumberType = SupportsFloat

class LPObjType(enum.IntEnum):
    MAX = cast(ClassVar[LPObjType], ...)
    MIN = cast(ClassVar[LPObjType], ...)
    NONE = cast(ClassVar[LPObjType], ...)

class LPSolverType(enum.IntEnum):
    CRISS_CROSS = cast(ClassVar[LPSolverType], ...)
    DUAL_SIMPLEX = cast(ClassVar[LPSolverType], ...)

class LPStatusType(enum.IntEnum):
    DUAL_INCONSISTENT = cast(ClassVar[LPStatusType], ...)
    DUAL_UNBOUNDED = cast(ClassVar[LPStatusType], ...)
    INCONSISTENT = cast(ClassVar[LPStatusType], ...)
    OPTIMAL = cast(ClassVar[LPStatusType], ...)
    STRUC_DUAL_INCONSISTENT = cast(ClassVar[LPStatusType], ...)
    STRUC_INCONSISTENT = cast(ClassVar[LPStatusType], ...)
    UNBOUNDED = cast(ClassVar[LPStatusType], ...)
    UNDECIDED = cast(ClassVar[LPStatusType], ...)

class LinProg:
    @property
    def array(self) -> Sequence[Sequence[NumberType]]: ...
    @property
    def dual_solution(self) -> Sequence[tuple[int, NumberType]]: ...
    @property
    def obj_type(self) -> LPObjType: ...
    @obj_type.setter
    def obj_type(self, value: LPObjType) -> None: ...
    @property
    def obj_value(self) -> NumberType: ...
    @property
    def primal_solution(self) -> Sequence[NumberType]: ...
    @property
    def status(self) -> LPStatusType: ...
    @property
    def solver(self) -> LPSolverType: ...

class Matrix:
    @property
    def array(self) -> Sequence[Sequence[NumberType]]: ...
    @property
    def lin_set(self) -> Set[int]: ...
    @lin_set.setter
    def lin_set(self, value: Container[int]) -> None: ...
    @property
    def obj_func(self) -> Sequence[NumberType]: ...
    @obj_func.setter
    def obj_func(self, value: Sequence[NumberType]) -> None: ...
    @property
    def obj_type(self) -> LPObjType: ...
    @obj_type.setter
    def obj_type(self, value: LPObjType) -> None: ...
    @property
    def rep_type(self) -> RepType: ...
    @rep_type.setter
    def rep_type(self, value: RepType) -> None: ...

class Polyhedron:
    @property
    def rep_type(self) -> RepType: ...

class RepType(enum.IntEnum):
    GENERATOR = cast(ClassVar[RepType], ...)
    INEQUALITY = cast(ClassVar[RepType], ...)
    UNSPECIFIED = cast(ClassVar[RepType], ...)

class RowOrderType(enum.IntEnum):
    LEX_MAX = cast(ClassVar[RowOrderType], ...)
    LEX_MIN = cast(ClassVar[RowOrderType], ...)
    MAX_CUTOFF = cast(ClassVar[RowOrderType], ...)
    MAX_INDEX = cast(ClassVar[RowOrderType], ...)
    MIN_CUTOFF = cast(ClassVar[RowOrderType], ...)
    MIN_INDEX = cast(ClassVar[RowOrderType], ...)
    MIX_CUTOFF = cast(ClassVar[RowOrderType], ...)
    RANDOM_ROW = cast(ClassVar[RowOrderType], ...)

def block_elimination(mat: Matrix, col_set: Container[int]) -> Matrix: ...
def copy_adjacency(poly: Polyhedron) -> Sequence[Set[int]]: ...
def copy_generators(poly: Polyhedron) -> Matrix: ...
def copy_incidence(poly: Polyhedron) -> Sequence[Set[int]]: ...
def copy_inequalities(poly: Polyhedron) -> Matrix: ...
def copy_input(poly: Polyhedron) -> Matrix: ...
def copy_input_adjacency(poly: Polyhedron) -> Sequence[Set[int]]: ...
def copy_input_incidence(poly: Polyhedron) -> Sequence[Set[int]]: ...
def copy_output(poly: Polyhedron) -> Matrix: ...
def fourier_elimination(mat: Matrix) -> Matrix: ...
def implicit_linearity(mat: Matrix, row: int) -> Optional[Sequence[NumberType]]: ...
def implicit_linearity_rows(mat: Matrix) -> Set[int]: ...
def linprog_from_array(
    array: Sequence[Sequence[SupportsNumberType]], obj_type: LPObjType
) -> LinProg: ...
def linprog_from_matrix(mat: Matrix) -> LinProg: ...
def linprog_solve(
    lp: LinProg, solver: LPSolverType = LPSolverType.DUAL_SIMPLEX
) -> None: ...
def matrix_adjacency(mat: Matrix) -> Sequence[Set[int]]: ...
def matrix_append_to(mat1: Matrix, mat2: Matrix) -> None: ...
def matrix_canonicalize(
    mat: Matrix,
) -> tuple[Set[int], Set[int], Sequence[Optional[int]]]: ...
def matrix_canonicalize_linearity(
    mat: Matrix,
) -> tuple[Set[int], Sequence[Optional[int]]]: ...
def matrix_copy(mat: Matrix) -> Matrix: ...
def matrix_from_array(
    array: Sequence[Sequence[SupportsNumberType]],
    lin_set: Container[int] = (),
    rep_type: RepType = RepType.UNSPECIFIED,
    obj_type: LPObjType = LPObjType.NONE,
    obj_func: Optional[Sequence[SupportsNumberType]] = None,
) -> Matrix: ...
def matrix_rank(
    mat: Matrix, ignored_rows: Container[int] = (), ignored_cols: Container[int] = ()
) -> tuple[Set[int], Set[int], int]: ...
def matrix_redundancy_remove(
    mat: Matrix,
) -> tuple[Set[int], Sequence[Optional[int]]]: ...
def matrix_weak_adjacency(mat: Matrix) -> Sequence[Set[int]]: ...
def polyhedron_from_matrix(
    mat: Matrix, row_order: Optional[RowOrderType] = None
) -> Polyhedron: ...
def redundant(mat: Matrix, row: int) -> Sequence[NumberType] | None: ...
def redundant_rows(mat: Matrix) -> Set[int]: ...
def s_redundant(mat: Matrix, row: int) -> Optional[Sequence[NumberType]]: ...
def s_redundant_rows(mat: Matrix) -> Set[int]: ...
