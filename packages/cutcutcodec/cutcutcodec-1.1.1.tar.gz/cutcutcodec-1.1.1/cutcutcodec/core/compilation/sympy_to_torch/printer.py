#!/usr/bin/env python3

"""Static C compilation of atomic sympy expression.

This is enable to write a C code, compile it with gcc,
and import the file as a python function.

It is slowler to initialise than the dynamic version but it is faster to evaluate.
This static evaluation do not support broadcasting.

Implemented functions:

    * sympy.Abs
    * sympy.Add `+`
    * sympy.atan
    * sympy.cbrt
    * sympy.cos
    * sympy.exp
    * sympy.Max
    * sympy.Min
    * sympy.Mul `*`
    * sympy.Pow `/` and `**`
    * sympy.sin
    * sympy.sqrt

Not implemented functions:

    * sympy.acos
    * sympy.acosh
    * sympy.Add `+` and `-`
    * sympy.And
    * sympy.arg
    * sympy.asin
    * sympy.asinh
    * sympy.atan2
    * sympy.atanh
    * sympy.ceiling
    * sympy.cosh
    * sympy.Determinant
    * sympy.Eq
    * sympy.erf
    * sympy.floor
    * sympy.GreaterThan
    * sympy.HadamardProduct
    * sympy.im
    * sympy.LessThan
    * sympy.log
    * sympy.loggamma
    * sympy.MatAdd
    * sympy.Mod `%`
    * sympy.Ne
    * sympy.Not
    * sympy.Or
    * sympy.re
    * sympy.sign
    * sympy.sinh
    * sympy.StrictGreaterThan
    * sympy.StrictLessThan
    * sympy.tan
    * sympy.tanh
    * sympy.Trace
    * sympy.Tuple
"""

from fractions import Fraction
import collections
import re
import typing

from sympy.core.basic import Atom, Basic
from sympy.core.containers import Tuple
from sympy.core.numbers import Integer, One, Rational
from sympy.core.power import Pow
from sympy.core.relational import Equality
from sympy.core.symbol import Symbol
from sympy.functions.elementary.complexes import im as sympy_im, re as sympy_re

from cutcutcodec.core.exceptions import CompilationError


C_TYPES = (
    "float", "double", "long double", "float complex", "double complex", "long double complex"
)
NP_TYPES = (
    "NPY_FLOAT", "NPY_DOUBLE", "NPY_LONGDOUBLE", "NPY_CFLOAT", "NPY_CDOUBLE", "NPY_CLONGDOUBLE"
)


def _printer(
    tree: list[tuple[Symbol, typing.Union[Basic, None]]],
    alloc: dict[Symbol, set[Symbol]],
    args: set[Symbol],
) -> str:
    """Return the complete C source code of the module with the tree function numpy compatible.

    Parameters
    ----------
    tree : list[tuple[sympy.core.symbol.Symbol, typing.Union[sympy.core.basic.Basic, None]]]
        Each steps.
    alloc : dict[sympy.core.symbol.Symbol, set[sympy.core.symbol.Symbol]]
        The intermediate variables to be declared and there respective dimensions.
    args : set[sympy.core.symbol.Symbol]
        All the inputs arguments required for this function.

    Returns
    -------
    code : str
        The complete C source code of the compilable python module.
        The entry point is the ``lambdify`` function.
    """
    out_symbs = list(tree[-1][1]) if isinstance(tree[-1][1], Tuple) else [tree[-1][0]]
    kernel_args = args | set(out_symbs)

    # frozen C / python environement
    header = (
        "#define PY_SSIZE_T_CLEA\n"
        # for detection and management of nestead threads
        "#include <unistd.h>\n"
        "#include <sys/syscall.h>\n"
        "#ifndef SYS_gettid\n"
        "#error 'SYS_gettid unavailable on this system'\n"
        "#endif\n"
        "#define gettid() ((pid_t)syscall(SYS_gettid))\n"
        # classical imports
        "#include <complex.h>\n"
        "#include <math.h>\n"
        "#include <numpy/arrayobject.h>\n"
        "#include <omp.h>\n"
        "#include <Python.h>\n"
        "#include <stdio.h>\n"
        "#undef I"
    )
    python_context = (  # python module integration of the function
        "static PyMethodDef lambdifyMethods[] = {\n"
        '  {"lambdify", py_lambdify, METH_VARARGS, "Function for sympy expr evaluation."},\n'
        "  {NULL, NULL, 0, NULL}\n"
        "};\n"
        "static struct PyModuleDef lambdify = {\n"
        "  PyModuleDef_HEAD_INIT,\n"
        '  "lambdify",\n'
        '  "Autogenerated sympy lambdify module.",\n'
        "  -1,\n"
        "  lambdifyMethods\n"
        "};\n"
        "PyMODINIT_FUNC PyInit_lambdify(void)\n"
        "{\n"
        "  import_array();\n"
        "  return PyModule_Create(&lambdify);\n"
        "};"
    )

    # kernel, define the ``c_lambdify`` functions
    kernels: dict[str, set[str]] = {}  # source code of each function and the context functions
    errors = []
    for c_type in C_TYPES:
        try:
            kernels[c_type] = _printer_kernel(
                tree=tree,
                alloc=set(alloc)-set(out_symbs),
                args=kernel_args,
                c_type=c_type,
            )
        except CompilationError as err:
            errors.append(err)
    if not kernels:
        raise CompilationError(
            "failed to compile the expression for all c types",
            *(arg for err in errors for arg in err.args)
        )

    # kernel parser
    parser = _printer_parser(
        kernel_args=sorted(map(str, kernel_args)),
        out_is_tuple=isinstance(tree[-1][1], Tuple),
        args=args,
        out_symbs=out_symbs,
        valid_c_types=sorted(kernels),
    )

    # final assembly
    return (
        header + "\n\n"
        + "\n\n".join(sorted(func for funcs in kernels.values() for func in funcs)) + "\n\n"
        + parser + "\n\n"
        + python_context
    )


def _printer_kernel(
    tree: list[tuple[Symbol, typing.Union[Basic, None]]],
    alloc: set[Symbol],
    args: list[Symbol],
    c_type: str,
) -> set[str]:
    """Return the source code of the C function's kernel.

    Parameters
    ----------
    tree : list[tuple[sympy.core.symbol.Symbol, typing.Union[sympy.core.basic.Basic, None]]]
        Each steps.
    alloc : set[sympy.core.symbol.Symbol]
        The intermediate variables to be declared.
    args : set[sympy.core.symbol.Symbol]
        All the inputs arguments required for this function.
    c_type : str
        The C type of the numbers. Could be `float` or `double`.

    Returns
    -------
    str
        The C source code of the kernel function, no python context.

    Examples
    --------
    >>> from pprint import pprint
    >>> from sympy.abc import c, x
    >>> from sympy import Number, Tuple, sin, symbols
    >>> import numpy as np
    >>> from cutcutcodec.core.compilation.sympy_to_torch.printer import _printer_kernel
    >>> _, _0, _1, _2, _3, _4, _5 = symbols("_ _:6")
    >>> tree = [(_0, c**(-2)), (_1, 1/x), (_2, _0*_1), (_3, Number(0)), (_1, sin(x)), (_1, sin(_1)),
    ...         (_1, _1 + 1), (_0, c), (_4, x), (_5, _2), (_, Tuple(_3, _0, c, _4, x, _2, _5, _1))]
    >>> alloc = {_0: {c}, _1: {c}, _2: {c}, _3: {c}, _4: {c}, _5: {c}}
    >>> kernel = _printer_kernel(tree, alloc, [_2, _3, c, _4, x, _0, _5, _1], "float")
    >>> for k in sorted(kernel):  # doctest: +ELLIPSIS
    ...     print(k)
    ...
    void lambdify_float(const npy_intp _dim, float *_0, float *_1, ..., float *x) {
      npy_intp _i;
      #pragma omp parallel for simd schedule(static)
      for ( _i = 0; _i < _dim; ++_i ) {
        float _0, _1, _2, _3, _4, _5;
        _0[_i] = 1.0f / c[_i] * c[_i];
        _1[_i] = 1.0f / x[_i];
        _2[_i] = _0[_i] * _1[_i];
        _3[_i] = 0.0f;
        _1[_i] = sinf(x[_i]);
        _1[_i] = sinf(_1[_i]);
        _1[_i] += 1.0f;
        _0[_i] = c[_i];
        _4[_i] = x[_i];
        _5[_i] = _2[_i];
      }
    }
    >>>
    """
    context = set()
    code_lines = []

    # signature
    args_ = [
        "const npy_intp _dim",
        *(f"{c_type} *{a}" for a in sorted(map(str, args))),
    ]
    code_lines.append(f"void lambdify_{c_type.replace(' ', '_')}({', '.join(args_)})" + " {")

    # global declaration
    code_lines.append("  npy_intp _i;")

    # main for declaration
    code_lines.append("  #pragma omp parallel for simd schedule(static)")
    code_lines.append("  for ( _i = 0; _i < _dim; ++_i ) {")

    # expression on one item
    kernel_lines = []
    indexing = collections.defaultdict(lambda: "", {a: "[_i]" for a in args})
    for out, expr in (tree[:-1] if isinstance(tree[-1][1], Tuple) else tree):
        new_context, new_alloc, new_lines = _print_atomic(expr, out, indexing, c_type)
        context |= new_context
        alloc |= new_alloc
        kernel_lines.extend([f"    {line}" for line in new_lines])
    if alloc:
        code_lines.append(f"    {c_type} {', '.join(sorted(map(str, alloc)))};")
    code_lines.extend(kernel_lines)
    code_lines.append("  }")  # close for

    # close main function
    code_lines.append("}")
    return context | {"\n".join(code_lines)}


def _printer_parser(
    kernel_args: list[str],
    out_is_tuple: bool,
    args: set[Symbol],
    out_symbs: list[Symbol],
    valid_c_types: list[str],
) -> str:
    """Write the code of the C python parser.

    Help to ``cutcutcodec.core.sympy_to_torch.printer._printer``.

    Parameters
    ----------
    kernel_args : list[str]
        The ordered list of the input symbol name of the kernels functions.
    out_is_tuple : boolean
        True if the returned value has to be packed inside a tuple.
    args : set[sympy.core.symbol.Symbol]
        All the inputs arguments required for this function.
    out_symbs : list[sympy.core.symbol.Symbol]
        The ordered list of the symbols to return.
    valid_c_types : list[str]
        The c type list where the kernel compilation is successful
    """
    ref_symb = min(args, key=str)

    # function api and variables declaration
    parser = ""
    parser += "static PyObject *py_lambdify(PyObject *self, PyObject *args) {\n"
    parser += "  PyArrayObject " + ", ".join(f"*{a}" for a in sorted(map(str, kernel_args))) + ";\n"
    parser += "  npy_intp _dim;\n"
    if out_is_tuple:
        parser += "  PyObject *_out;\n"

    # parse the input arguments
    args_ = [
        "args",
        ('"' + "O!"*len(args) + '"'),
        *(f"&PyArray_Type, &{a}" for a in sorted(map(str, args)))
    ]
    parser += f"  if ( !PyArg_ParseTuple({', '.join(args_)}) )" + "{\n"
    parser += "    return NULL;\n"
    parser += "  }\n"
    parser += f"  _dim = PyArray_DIM({ref_symb}, 0);\n"

    # allocation of the new tensors
    args_ = sorted(map(str, set(out_symbs)-args))
    for i, new in enumerate(args_):
        parser += (
            f"  {new} = (PyArrayObject *)PyArray_SimpleNew(1, &_dim, PyArray_TYPE({ref_symb}));\n"
        )
        parser += f"  if ( NULL == {new} ) " + "{\n"
        parser += (
            f'    PyErr_SetString(PyExc_RuntimeError, "failed to create a new {new} array");\n'
        )
        for j in range(i):
            parser += f"    Py_DECREF({args_[j]});\n"
        parser += "    return NULL;\n"
        parser += "  }\n"

    # increment ref of out tensors
    for out_ in sorted(set(out_symbs) & args, key=str):
        parser += f"  Py_INCREF((PyObject *){out_});\n"

    # thread management
    parser += "  if (gettid() == getpid()) {\n"
    parser += "    omp_set_num_threads(omp_get_num_procs());\n"
    parser += "  }\n"
    parser += "  else {\n"
    parser += "    omp_set_num_threads(1);\n"
    parser += "  }\n"

    # call the C func
    parser += f"  switch(PyArray_TYPE({ref_symb})) " + "{\n"
    for c_type in valid_c_types:
        parser += f"  case {NP_TYPES[C_TYPES.index(c_type)]}:\n"
        parser += "    Py_BEGIN_ALLOW_THREADS\n"
        args_ = [
            "_dim",
            *(f"({c_type} *)PyArray_DATA({a})" for a in sorted(map(str, kernel_args))),
        ]
        parser += f"    lambdify_{c_type.replace(' ', '_')}({', '.join(args_)});\n"
        parser += "    Py_END_ALLOW_THREADS\n"  # unlock the GIL, allow thread
        if out_is_tuple:
            args_ = [
                str(len(out_symbs)),
                *(f"(PyObject *){o}" for o in out_symbs),
            ]
            parser += f"    _out = PyTuple_Pack({', '.join(args_)});\n"
            for out_ in out_symbs:
                parser += f"    Py_DECREF({out_});\n"
            parser += "    return _out;\n"
        else:
            parser += f"    return (PyObject *){out_symbs[0]};\n"
    parser += "  default:\n"
    parser += '    PyErr_SetString(PyExc_TypeError, "the array type is not supported");\n'
    for out_ in out_symbs:
        parser += f"    Py_DECREF({out_});\n"
    parser += "    return NULL;\n"
    parser += "  }\n"
    parser += "}"

    return parser


def _atom2str(elem: Atom, indexing: collections.defaultdict[Symbol, str], c_type: str) -> str:
    """Help for `_print_atomic`."""
    if elem.is_symbol:
        return f"{elem}{indexing[elem]}"
    if elem.is_number:
        if c_type in {"float", "double", "long double"}:
            if elem.is_real or elem.is_integer:
                suffix = {"float": "f", "double": "", "long double": "L"}[c_type]
                return f"{float(elem)}{suffix}"
            raise CompilationError(f"impossible to compile {elem} as C type {c_type}")
        if c_type in {"float complex", "double complex", "long double complex"} and elem.is_complex:
            suffix = {
                "float complex": "f", "double complex": "", "long double complex": "L"
            }[c_type]
            return (
                f"({float(sympy_re(elem))}{suffix} + {float(sympy_im(elem))}{suffix} * _Complex_I)"
            )
        raise CompilationError(f"failed to compile {elem} in C")
    raise CompilationError(f"{elem} should be atomic but is not")


def _print_atomic(
    expr: Basic, out: Symbol, indexing: collections.defaultdict[Symbol, str], c_type: str
) -> tuple[set[str], set[Symbol], list[str]]:
    """Write the sympy atomic expression as a valid C source code lines.

    Parameters
    ----------
    expr : sympy.core.basic.Basic
        The sympy atomic expression to eval.
    out : sympy.core.symbol.Symbol
        The variable set, assume that this var is already declared.
    indexing : collections.defaultdict[sympy.core.symbol.Symbol, str]
        The way to acces to the content of the vars, at the current dimension.
        An empty string mean than the var is directely accessible with no indexingation.
        Otherwise, the value corresponds to the content of the braquets.
        For example, "[_i]" means ``var[_i]`` and "[_j - 2]" means ``var[_j - 2]``.
    c_type : str
        The C data type of the variables.

    Returns
    -------
    context : set[str]
        The functions requiered for the returned code lines.
    alloc : set[sympy.core.symbol.Symbol]
        The variables witch need to be declared before this code lines
    code_lines : list[str]
        The C code lignes corresponding to the given expression.

    Raises
    ------
    cutcutcodec.core.exceptions.CompilationError
        If no printer is available for this expression.
    """
    if expr.is_Atom:
        return (
            set(),
            set(),
            [f"{_atom2str(out, indexing, c_type)} = {_atom2str(expr, indexing, c_type)};"],
        )
    try:
        func = globals()[f"_{expr.__class__.__name__.lower()}"]
    except KeyError as err:
        raise CompilationError(
            f"no function {expr.__class__.__name__} for {expr} in {c_type}"
        ) from err
    return func(out, indexing, c_type, *expr.args)


def _abs(
    out: Symbol, indexing: collections.defaultdict[Symbol, str], c_type: str, arg: Atom
) -> tuple[set[str], set[Symbol], list[str]]:
    """C abs operation.

    Examples
    --------
    >>> from sympy.abc import x
    >>> from sympy.functions.elementary.complexes import Abs
    >>> import numpy as np
    >>> from cutcutcodec.core.compilation.sympy_to_torch.lambdify import _lambdify_c
    >>> from cutcutcodec.core.compilation.sympy_to_torch.printer import _print_atomic, _printer
    >>> func = _lambdify_c(_printer([(x, Abs(x))], {}, {x}))
    >>> func(np.array([np.nan, -np.inf, -2., 2., np.inf]))
    array([nan, inf,  2.,  2., inf])
    >>> func(np.array([3+4j, -3+4j, 3-4j, -3-4j]))
    array([5.+0.j, 5.+0.j, 5.+0.j, 5.+0.j])
    >>>
    """
    cfunc = {
        "float": "fabsf",
        "double": "fabs",
        "long double": "fabsl",
        "float complex": "(float complex)fabsf",
        "double complex": "(double complex)cabs",
        "long double complex": "(long double complex)fabsl",
    }[c_type]
    code = f"{_atom2str(out, indexing, c_type)} = {cfunc}({_atom2str(arg, indexing, c_type)});"
    return set(), set(), [code]


def _add(
    out: Symbol, indexing: collections.defaultdict[Symbol, str], c_type: str, *parts: Atom
) -> tuple[set[str], set[Symbol], list[str]]:
    """C + operation.

    Examples
    --------
    >>> from collections import defaultdict
    >>> from sympy.abc import x, y, z
    >>> from cutcutcodec.core.compilation.sympy_to_torch.printer import _print_atomic
    >>> _print_atomic(1 + x, x, defaultdict(lambda: ""), "float")
    (set(), set(), ['x += 1.0f;'])
    >>> _print_atomic(1 + x, y, defaultdict(lambda: ""), "float")
    (set(), set(), ['y = 1.0f + x;'])
    >>> _print_atomic(1 + x + y, z, defaultdict(lambda: ""), "float")
    (set(), set(), ['z = 1.0f + x;', 'z += y;'])
    >>>
    """
    out_str = _atom2str(out, indexing, c_type)
    if len(parts) == 0:
        parts = (Integer(0),)
    if len(parts) == 1:
        return set(), set(), [f"{out_str} = {_atom2str(parts[0], indexing, c_type)};"]
    try:
        ind = parts.index(out)
    except ValueError:
        code_lines = [
            f"{out_str} = "
            f"{_atom2str(parts[0], indexing, c_type)} + {_atom2str(parts[1], indexing, c_type)};"
        ]
        parts = parts[2:]
    else:
        code_lines = []
        parts = tuple(p for i, p in enumerate(parts) if i != ind)
    code_lines.extend([f"{out_str} += {_atom2str(p, indexing, c_type)};" for p in parts])
    return set(), set(), code_lines


def _atan(
    out: Symbol, indexing: collections.defaultdict[Symbol, str], c_type: str, arg: Atom
) -> tuple[set[str], set[Symbol], list[str]]:
    """C atan operation.

    Examples
    --------
    >>> from sympy.abc import x
    >>> from sympy.functions.elementary.trigonometric import atan
    >>> import numpy as np
    >>> from cutcutcodec.core.compilation.sympy_to_torch.lambdify import _lambdify_c
    >>> from cutcutcodec.core.compilation.sympy_to_torch.printer import _print_atomic, _printer
    >>> func = _lambdify_c(_printer([(x, atan(x))], {}, {x}))
    >>> func(np.array([np.nan]))
    array([nan])
    >>> func(np.array([-np.inf, -1.0, 0.0, 1.0, np.inf])) / np.pi
    array([-0.5 , -0.25,  0.  ,  0.25,  0.5 ])
    >>>
    """
    if (cfunc := {
        "float": "atanf",
        "double": "atan",
        "long double": "atanl",
    }.get(c_type, None)) is None:
        raise CompilationError(f"atan is not implemented for {c_type}")
    code = f"{_atom2str(out, indexing, c_type)} = {cfunc}({_atom2str(arg, indexing, c_type)});"
    return set(), set(), [code]


def _cos(
    out: Symbol, indexing: collections.defaultdict[Symbol, str], c_type: str, arg: Atom
) -> tuple[set[str], set[Symbol], list[str]]:
    """C cos operation.

    Examples
    --------
    >>> from sympy.abc import x
    >>> from sympy.functions.elementary.trigonometric import cos
    >>> import numpy as np
    >>> from cutcutcodec.core.compilation.sympy_to_torch.lambdify import _lambdify_c
    >>> from cutcutcodec.core.compilation.sympy_to_torch.printer import _print_atomic, _printer
    >>> func = _lambdify_c(_printer([(x, cos(x))], {}, {x}))
    >>> func(np.array([np.nan]))
    array([nan])
    >>> func(np.array([0., 0.78539816, 2.35619449, 3.14159265, 3.92699082, 5.49778714, 6.28318531]))
    array([ 1.        ,  0.70710678, -0.70710678, -1.        , -0.70710678,
            0.70710678,  1.        ])
    >>> func(np.array([1+1j]))
    array([0.83373003-0.98889771j])
    >>>
    """
    cfunc = {
        "float": "cosf",
        "double": "cos",
        "long double": "cosl",
        "float complex": "ccosf",
        "double complex": "ccos",
        "long double complex": "ccosl",
    }[c_type]
    code = f"{_atom2str(out, indexing, c_type)} = {cfunc}({_atom2str(arg, indexing, c_type)});"
    return set(), set(), [code]


def _exp(
    out: Symbol, indexing: collections.defaultdict[Symbol, str], c_type: str, arg: Atom
) -> tuple[set[str], set[Symbol], list[str]]:
    """C exp operation.

    Examples
    --------
    >>> from sympy.abc import x
    >>> from sympy.functions.elementary.trigonometric import exp
    >>> import numpy as np
    >>> from cutcutcodec.core.compilation.sympy_to_torch.lambdify import _lambdify_c
    >>> from cutcutcodec.core.compilation.sympy_to_torch.printer import _print_atomic, _printer
    >>> func = _lambdify_c(_printer([(x, exp(x))], {}, {x}))
    >>> func(np.array([np.nan]))
    array([nan])
    >>> func(np.array([-np.inf, -1.0, 0.0, 1.0, np.inf]))
    array([0.        , 0.36787944, 1.        , 2.71828183,        inf])
    >>> func(np.array([1+1j]))
    array([1.46869394+2.28735529j])
    >>>
    """
    cfunc = {
        "float": "expf",
        "double": "exp",
        "long double": "expl",
        "float complex": "cexpf",
        "double complex": "cexp",
        "long double complex": "cexpl",
    }[c_type]
    code = f"{_atom2str(out, indexing, c_type)} = {cfunc}({_atom2str(arg, indexing, c_type)});"
    return set(), set(), [code]


def _max(
    out: Symbol, indexing: collections.defaultdict[Symbol, str], c_type: str, *parts: Atom
) -> tuple[set[str], set[Symbol], list[str]]:
    """C maximum operation.

    Examples
    --------
    >>> from collections import defaultdict
    >>> from sympy.abc import x, y
    >>> from sympy.functions.elementary.miscellaneous import Max
    >>> from cutcutcodec.core.compilation.sympy_to_torch.printer import _print_atomic
    >>> _print_atomic(Max(2, x), x, defaultdict(lambda: ""), "float")
    (set(), set(), ['x = 2.0f > x ? 2.0f : x;'])
    >>> _print_atomic(Max(2, x), y, defaultdict(lambda: ""), "float complex")  # doctest: +ELLIPSIS
    (set(), set(), ['y = (crealf((2.0f + 0.0f * _Complex_I))... ? (2.0f + 0.0f * _Complex_I) : x;'])
    >>> _print_atomic(Max(2, x, y), x, defaultdict(lambda: ""), "float")
    (set(), set(), ['x = 2.0f > x ? 2.0f : x;', 'x = x > y ? x : y;'])
    >>>
    """
    out_str = _atom2str(out, indexing, c_type)
    if len(parts) == 0:
        raise ValueError("failed to print the function maximum with 0 arguments")
    if len(parts) == 1:
        return set(), set(), [f"{out_str} = {_atom2str(parts[0], indexing, c_type)};"]
    e_1 = _atom2str(parts[0], indexing, c_type)
    e_2 = _atom2str(parts[1], indexing, c_type)
    rel = {
        "float": "_",
        "double": "_",
        "long double": "_",
        "float complex": "(crealf(_)*crealf(_) + cimagf(_)*cimagf(_))",
        "double complex": "(creal(_)*creal(_) + cimag(_)*cimag(_))",
        "long double complex": "(creall(_)*creall(_) + cimagl(_)*cimagl(_))",
    }[c_type]
    code = [f"{out_str} = {rel.replace('_', e_1)} > {rel.replace('_', e_2)} ? {e_1} : {e_2};"]
    while len(parts) > 2:
        parts = (out,) + parts[2:]
        code.extend(_max(out, indexing, c_type, *parts)[2])
    return set(), set(), code


def _min(
    out: Symbol, indexing: collections.defaultdict[Symbol, str], c_type: str, *parts: Atom
) -> tuple[set[str], set[Symbol], list[str]]:
    out_str = _atom2str(out, indexing, c_type)
    if len(parts) == 0:
        raise ValueError("failed to print the function maximum with 0 arguments")
    if len(parts) == 1:
        return set(), set(), [f"{out_str} = {_atom2str(parts[0], indexing, c_type)};"]
    e_1 = _atom2str(parts[0], indexing, c_type)
    e_2 = _atom2str(parts[1], indexing, c_type)
    rel = {
        "float": "_",
        "double": "_",
        "long double": "_",
        "float complex": "(crealf(_)*crealf(_) + cimagf(_)*cimagf(_))",
        "double complex": "(creal(_)*creal(_) + cimag(_)*cimag(_))",
        "long double complex": "(creall(_)*creall(_) + cimagl(_)*cimagl(_))",
    }[c_type]
    code = [f"{out_str} = {rel.replace('_', e_1)} < {rel.replace('_', e_2)} ? {e_1} : {e_2};"]
    while len(parts) > 2:
        parts = (out,) + parts[2:]
        code.extend(_max(out, indexing, c_type, *parts)[2])
    return set(), set(), code


def _mul(
    out: Symbol, indexing: collections.defaultdict[Symbol, str], c_type: str, *parts: Atom
) -> tuple[set[str], set[Symbol], list[str]]:
    """C * operation.

    Examples
    --------
    >>> from collections import defaultdict
    >>> from sympy.abc import x, y, z
    >>> from cutcutcodec.core.compilation.sympy_to_torch.printer import _print_atomic
    >>> _print_atomic(2 * x, x, defaultdict(lambda: ""), "float")
    (set(), set(), ['x *= 2.0f;'])
    >>> _print_atomic(2 * x, y, defaultdict(lambda: ""), "float")
    (set(), set(), ['y = 2.0f * x;'])
    >>> _print_atomic(2 * x * y, z, defaultdict(lambda: ""), "float")
    (set(), set(), ['z = 2.0f * x;', 'z *= y;'])
    >>>
    """
    out_str = _atom2str(out, indexing, c_type)
    if len(parts) == 0:
        parts = (Integer(1),)
    if len(parts) == 1:
        return set(), set(), [f"{out_str} = {_atom2str(parts[0], indexing, c_type)};"]
    try:
        ind = parts.index(out)
    except ValueError:
        code_lines = [
            f"{out_str} = "
            f"{_atom2str(parts[0], indexing, c_type)} * {_atom2str(parts[1], indexing, c_type)};"
        ]
        parts = parts[2:]
    else:
        code_lines = []
        parts = tuple(p for i, p in enumerate(parts) if i != ind)
    code_lines.extend([f"{out_str} *= {_atom2str(p, indexing, c_type)};" for p in parts])
    return set(), set(), code_lines


def _pow(
    out: Symbol, indexing: collections.defaultdict[Symbol, str], c_type: str, base: Atom, exp: Atom
) -> tuple[set[str], set[Symbol], list[str]]:
    """C ** operation.

    Examples
    --------
    >>> from collections import defaultdict
    >>> from sympy.abc import x, y, z
    >>> import numpy as np
    >>> from cutcutcodec.core.compilation.sympy_to_torch.lambdify import _lambdify_c
    >>> from cutcutcodec.core.compilation.sympy_to_torch.printer import _print_atomic, _printer
    >>>
    >>> _print_atomic(x**y, z, defaultdict(lambda: ""), "float")
    (set(), set(), ['z = powf(x, y);'])
    >>> _print_atomic(1/x, z, defaultdict(lambda: ""), "float")
    (set(), set(), ['z = 1.0f / x;'])
    >>> _print_atomic(x**2, y, defaultdict(lambda: ""), "float")
    (set(), set(), ['y = x * x;'])
    >>> _print_atomic(x**.5, y, defaultdict(lambda: ""), "float")
    (set(), set(), ['y = sqrtf(x);'])
    >>> _print_atomic(x**(1/3), y, defaultdict(lambda: ""), "float")
    (set(), set(), ['y = cbrtf(x);'])
    >>> _print_atomic(x**(-7/2), y, defaultdict(lambda: ""), "double")
    (set(), {_buf}, ['y = x * x;', '_buf = x * y;', 'y *= y;', 'y *= _buf;', 'y = 1.0 / sqrt(y);'])
    >>>
    >>> func = _lambdify_c(_printer([(x, x**y)], {}, {x, y}))
    >>> func(
    ...     np.array([2.0   , np.nan, 0.0, 0.0,  0.0, -0.0,    2.0,     2.0]),
    ...     np.array([np.nan,    2.0, 0.0, 1.0, -1.0, -1.0, np.inf, -np.inf])
    ... )
    array([ nan,  nan,   1.,   0.,  inf, -inf,  inf,   0.])
    >>> func(np.array([1+1j]), np.array([1+1j]))
    array([0.27395725+0.58370076j])
    >>> func = _lambdify_c(_printer([(x, x**2)], {}, {x}))
    >>> func(np.array([np.nan, -np.inf, -2.0, -1.0, 1.0, 2.0, np.inf]))
    array([nan, inf,  4.,  1.,  1.,  4., inf])
    >>> func = _lambdify_c(_printer([(x, 1/x)], {}, {x}))
    >>> func(np.array([np.nan, -np.inf, -2.0, -1.0, -0.0, 0.0, 1.0, 2.0, np.inf]))
    array([ nan, -0. , -0.5, -1. , -inf,  inf,  1. ,  0.5,  0. ])
    >>> func = _lambdify_c(_printer([(x, x**.5)], {}, {x}))
    >>> func(np.array([np.nan, -np.inf, -1.0, 0.0, 1.0, 4.0, np.inf]))
    array([nan, nan, nan,  0.,  1.,  2., inf])
    >>> func = _lambdify_c(_printer([(x, x**(1/3))], {}, {x}))
    >>> func(np.array([np.nan, -np.inf, -8.0, -1.0, 0.0, 1.0, 8.0, np.inf]))
    array([ nan, -inf,  -2.,  -1.,   0.,   1.,   2.,  inf])
    >>> func = _lambdify_c(_printer([(x, x**(-7/2))], {}, {x}))
    >>> func(np.array([0.820335356007638]))
    array([2.])
    >>>
    """
    out_str = _atom2str(out, indexing, c_type)

    if exp.is_number:
        exp_frac = Fraction(float(exp)).limit_denominator()

        # a**-b <=> 1/(a**b)
        if exp_frac.denominator <= 3 and exp_frac < 0:
            context, alloc, lines = _pow(out, indexing, c_type, base, -exp)
            if (match := re.search(r" = (?P<inst>.+);$", lines[-1])) is not None:
                lines[-1] = (
                    f"{out_str} = {_atom2str(One(), indexing, c_type)} / {match['inst']};"
                    if re.fullmatch(r"\S+(?:[\(\[].*[\)\]])?", match["inst"]) else
                    f"{out_str} = {_atom2str(One(), indexing, c_type)} / ({match['inst']});"
                )
            else:
                lines.append(f"{out_str} = {_atom2str(One(), indexing, c_type)}/{out_str};")
            return context, alloc, lines

        # a**(n/m) <=> (a**n)**(1/m)
        if (
            cfunc := {  # a**(1/2) <=> sqrt(a) or a**(1/3) <=> cbrt(a)
                (2, "float"): "sqrtf",
                (2, "double"): "sqrt",
                (2, "long double"): "sqrtl",
                (2, "float complex"): "csqrtf",
                (2, "double complex"): "csqrt",
                (2, "long double complex"): "csqrtl",
                (3, "float"): "cbrtf",
                (3, "double"): "cbrt",
                (3, "long double"): "cbrtl",
            }.get((exp_frac.denominator, c_type), None)
        ) is not None:
            context, alloc, lines = _pow(out, indexing, c_type, base, Rational(exp_frac.numerator))
            if (match := re.search(r" = (?P<inst>.+);$", lines[-1])) is not None:
                lines[-1] = f"{out_str} = {cfunc}({match['inst']});"
            else:
                lines.append(f"{out_str} = {cfunc}({out_str});")
            return context, alloc, lines

        # a**n, n integer, use a**n <=> (a**2)**(n/2)
        if exp_frac.denominator == 1:
            return _pow_pos_integer(out, indexing, c_type, base, Integer(exp_frac.numerator))

    # general case
    cfunc = {
        "float": "powf",
        "double": "pow",
        "long double": "powl",
        "float complex": "cpowf",
        "double complex": "cpow",
        "long double complex": "cpowl",
    }[c_type]
    return (
        set(),
        set(),
        [
            f"{out_str} = {cfunc}("
            f"{_atom2str(base, indexing, c_type)}, {_atom2str(exp, indexing, c_type)});"
        ],
    )


def _pow_pos_integer(
    out: Symbol, indexing: collections.defaultdict[Symbol, str], c_type: str, base: Atom, exp: Atom
) -> tuple[set[str], set[Symbol], list[str]]:
    """Manage the special case of power where the exponant is a positive integer.

    Examples
    --------
    >>> from collections import defaultdict
    >>> from sympy.abc import x, y
    >>> from cutcutcodec.core.compilation.sympy_to_torch.printer import _pow_pos_integer
    >>>
    >>> # case allocation in new var
    >>> _pow_pos_integer(y, defaultdict(lambda: ""), "float", x, 0)
    (set(), set(), ['y = 1.0f;'])
    >>> _pow_pos_integer(y, defaultdict(lambda: ""), "float", x, 1)
    (set(), set(), ['y = x;'])
    >>> _pow_pos_integer(y, defaultdict(lambda: ""), "float", x, 2)
    (set(), set(), ['y = x * x;'])
    >>> _pow_pos_integer(y, defaultdict(lambda: ""), "float", x, 3)
    (set(), set(), ['y = x * x;', 'y *= x;'])
    >>> _pow_pos_integer(y, defaultdict(lambda: ""), "float", x, 4)
    (set(), set(), ['y = x * x;', 'y *= y;'])
    >>> _pow_pos_integer(y, defaultdict(lambda: ""), "float", x, 5)
    (set(), set(), ['y = x * x;', 'y *= y;', 'y *= x;'])
    >>> _pow_pos_integer(y, defaultdict(lambda: ""), "float", x, 6)
    (set(), {_buf}, ['y = x * x;', '_buf = y;', 'y *= y;', 'y *= _buf;'])
    >>> _pow_pos_integer(y, defaultdict(lambda: ""), "float", x, 7)
    (set(), {_buf}, ['y = x * x;', '_buf = x * y;', 'y *= y;', 'y *= _buf;'])
    >>> _pow_pos_integer(y, defaultdict(lambda: ""), "float", x, 8)
    (set(), set(), ['y = x * x;', 'y *= y;', 'y *= y;'])
    >>> _pow_pos_integer(y, defaultdict(lambda: ""), "float", x, 9)
    (set(), set(), ['y = x * x;', 'y *= y;', 'y *= y;', 'y *= x;'])
    >>> _pow_pos_integer(y, defaultdict(lambda: ""), "float", x, 10)
    (set(), {_buf}, ['y = x * x;', '_buf = y;', 'y *= y;', 'y *= y;', 'y *= _buf;'])
    >>>
    >>> # case allocation inplace
    >>> _pow_pos_integer(x, defaultdict(lambda: ""), "float", x, 0)
    (set(), set(), ['x = 1.0f;'])
    >>> _pow_pos_integer(x, defaultdict(lambda: ""), "float", x, 1)
    (set(), set(), ['x = x;'])
    >>> _pow_pos_integer(x, defaultdict(lambda: ""), "float", x, 2)
    (set(), set(), ['x *= x;'])
    >>> _pow_pos_integer(x, defaultdict(lambda: ""), "float", x, 3)
    (set(), {_buf}, ['_buf = x;', 'x *= x;', 'x *= _buf;'])
    >>> _pow_pos_integer(x, defaultdict(lambda: ""), "float", x, 4)
    (set(), set(), ['x *= x;', 'x *= x;'])
    >>> _pow_pos_integer(x, defaultdict(lambda: ""), "float", x, 5)
    (set(), {_buf}, ['_buf = x;', 'x *= x;', 'x *= x;', 'x *= _buf;'])
    >>> _pow_pos_integer(x, defaultdict(lambda: ""), "float", x, 6)
    (set(), {_buf}, ['x *= x;', '_buf = x;', 'x *= x;', 'x *= _buf;'])
    >>> _pow_pos_integer(x, defaultdict(lambda: ""), "float", x, 7)
    (set(), {_buf}, ['_buf = x;', 'x *= x;', '_buf *= x;', 'x *= x;', 'x *= _buf;'])
    >>> _pow_pos_integer(x, defaultdict(lambda: ""), "float", x, 8)
    (set(), set(), ['x *= x;', 'x *= x;', 'x *= x;'])
    >>> _pow_pos_integer(x, defaultdict(lambda: ""), "float", x, 9)
    (set(), {_buf}, ['_buf = x;', 'x *= x;', 'x *= x;', 'x *= x;', 'x *= _buf;'])
    >>> _pow_pos_integer(x, defaultdict(lambda: ""), "float", x, 10)
    (set(), {_buf}, ['x *= x;', '_buf = x;', 'x *= x;', 'x *= x;', 'x *= _buf;'])
    >>>
    """
    if exp in {0, 1}:
        return _mul(out, indexing, c_type, *([base]*exp))
    context, alloc, lines = set(), set(), []

    # formal general code
    symb_code = []
    buf = Symbol("_buf")
    state = {out: base, buf: Integer(1)}
    while exp > 1:
        if exp % 2:  # odd exponant
            symb_code.append(Equality(
                buf,
                (
                    (state[buf] if state[buf].is_Atom else buf)
                    * (state[out] if state[out].is_Atom else out)
                )
            ))
            state[buf] = state[buf] * state[out]
            state[out] = state[out].subs(state, simultaneous=True)
        symb_code.append(Equality(out, (state[out] if state[out].is_Atom else out)**2))
        state[out] = state[out] * state[out]
        state[buf] = state[buf].subs(state, simultaneous=True)
        exp //= 2
    symb_code.append(
        Equality(
            out,
            (
                (state[out] if state[out].is_Atom else out)
                * (state[buf] if state[buf].is_Atom else buf)
            )
        )
    )

    # simplify
    symb_code = [eq for eq in symb_code if isinstance(eq, Equality)]  # remove `x = x` lines
    if any(buf in eq.args[1].free_symbols for eq in symb_code):
        alloc.add(buf)
    else:  # if buf is not used
        symb_code = [eq for eq in symb_code if eq.args[0] != buf]  # remove `buf = ...` lines
    # remove first item of var declaration
    buf = {  # at each line index, associate the new declared var
        i: eq.args[0] for i, eq in enumerate(symb_code) if eq.args[0] not in eq.args[1].free_symbols
    }
    buf = set.union(  # the index to remove
        set(), *(set([i for i, v_ in buf.items() if v_ is v][:-1]) for v in set(buf.values()))
    )
    symb_code = [eq for i, eq in enumerate(symb_code) if i not in buf]

    # # verification
    # state = {base: base}
    # for equ in symb_code:
    #     state[equ.args[0]] = equ.args[1].xreplace(state)
    # print(state[out])

    # convert into C code
    for var, buf in (eq.args for eq in symb_code):
        if buf.is_Atom:
            new_context, new_alloc, new_lines = _mul(var, indexing, c_type, buf)
        elif isinstance(buf, Pow):
            new_context, new_alloc, new_lines = _mul(var, indexing, c_type, *([buf.base]*buf.exp))
        else:  # case Mul
            new_context, new_alloc, new_lines = _mul(var, indexing, c_type, *buf.args)
        context |= new_context
        alloc |= new_alloc
        lines.extend(new_lines)

    return context, alloc, lines


def _sin(
    out: Symbol, indexing: collections.defaultdict[Symbol, str], c_type: str, arg: Atom
) -> tuple[set[str], set[Symbol], list[str]]:
    """C sin operation.

    Examples
    --------
    >>> from sympy.abc import x
    >>> from sympy.functions.elementary.trigonometric import sin
    >>> import numpy as np
    >>> from cutcutcodec.core.compilation.sympy_to_torch.lambdify import _lambdify_c
    >>> from cutcutcodec.core.compilation.sympy_to_torch.printer import _print_atomic, _printer
    >>> func = _lambdify_c(_printer([(x, sin(x))], {}, {x}))
    >>> func(np.array([np.nan]))
    array([nan])
    >>> func(np.array([0.78539816, 1.57079633, 2.35619449, 3.92699082, 4.71238898, 5.49778714]))
    array([ 0.70710678,  1.        ,  0.70710678, -0.70710678, -1.        ,
           -0.70710678])
    >>> func(np.array([1+1j]))
    array([1.29845758+0.63496391j])
    >>>
    """
    cfunc = {
        "float": "sinf",
        "double": "sin",
        "long double": "sinl",
        "float complex": "csinf",
        "double complex": "csin",
        "long double complex": "csinl",
    }[c_type]
    code = f"{_atom2str(out, indexing, c_type)} = {cfunc}({_atom2str(arg, indexing, c_type)});"
    return set(), set(), [code]
